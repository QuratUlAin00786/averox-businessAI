var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/manufacturing-schema.ts
import { relations } from "drizzle-orm";
import { pgTable, serial, text, date, timestamp, integer, numeric, boolean, pgEnum, json, varchar } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var materialType, storageLocationType, storageUnitType, valuationMethod, batchStatus, vendorStatus, vendorContractType, materials, materialCategories, storageLocations, vendors, vendorContracts, vendorProducts, batchLots, materialValuations, materialValuationMethods, mrpForecasts, mrpForecastItems, materialRequirements, materialsRelations, materialCategoriesRelations, storageLocationsRelations, vendorsRelations, vendorContractsRelations, vendorProductsRelations, batchLotsRelations, materialValuationsRelations, mrpForecastsRelations, mrpForecastItemsRelations, materialRequirementsRelations, insertMaterialSchema, insertMaterialCategorySchema, insertStorageLocationSchema, insertVendorSchema, insertVendorContractSchema, insertVendorProductSchema, insertBatchLotSchema, insertMaterialValuationSchema, insertMaterialValuationMethodSchema, insertMrpForecastSchema, insertMrpForecastItemSchema, insertMaterialRequirementSchema;
var init_manufacturing_schema = __esm({
  "shared/manufacturing-schema.ts"() {
    "use strict";
    materialType = pgEnum("material_type", [
      "Raw Material",
      "Component",
      "Packaging Material",
      "Consumable",
      "Finished Good",
      "Semi-Finished Good",
      "Byproduct",
      "Waste",
      "Spare Part"
    ]);
    storageLocationType = pgEnum("storage_location_type", [
      "Warehouse",
      "Area",
      "Zone",
      "Bin",
      "Shelf",
      "Rack",
      "Cell"
    ]);
    storageUnitType = pgEnum("storage_unit_type", [
      "Small",
      "Medium",
      "Large",
      "Extra Large",
      "Pallet",
      "Bulk"
    ]);
    valuationMethod = pgEnum("valuation_method", [
      "FIFO",
      "LIFO",
      "Moving Average",
      "Standard Cost",
      "Specific Identification"
    ]);
    batchStatus = pgEnum("batch_status", [
      "Available",
      "Reserved",
      "On Hold",
      "In QA",
      "Rejected",
      "Consumed",
      "Expired",
      "Recalled"
    ]);
    vendorStatus = pgEnum("vendor_status", [
      "Active",
      "Inactive",
      "On Hold",
      "Pending Approval",
      "Blacklisted"
    ]);
    vendorContractType = pgEnum("vendor_contract_type", [
      "Supply",
      "Service",
      "Maintenance",
      "Framework",
      "Consignment",
      "Distribution"
    ]);
    materials = pgTable("materials", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      code: varchar("code", { length: 50 }).notNull().unique(),
      description: text("description"),
      type: materialType("type").notNull(),
      uom: text("uom").notNull(),
      // Unit of Measure
      price: numeric("price").default("0"),
      leadTime: integer("lead_time"),
      // in days
      reorderPoint: numeric("reorder_point"),
      eoq: numeric("eoq"),
      // Economic Order Quantity
      safetyStock: numeric("safety_stock"),
      minStock: numeric("min_stock"),
      maxStock: numeric("max_stock"),
      defaultLocationId: integer("default_location_id"),
      defaultValuationMethod: valuationMethod("default_valuation_method"),
      isActive: boolean("is_active").default(true),
      trackByBatch: boolean("track_by_batch").default(false),
      trackBySerial: boolean("track_by_serial").default(false),
      shelfLife: integer("shelf_life"),
      // in days
      technicalSpecifications: json("technical_specifications"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by"),
      categoryId: integer("category_id"),
      taxable: boolean("taxable").default(false),
      attributes: json("attributes")
    });
    materialCategories = pgTable("material_categories", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      description: text("description"),
      parentId: integer("parent_id"),
      isActive: boolean("is_active").default(true),
      attributes: json("attributes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    storageLocations = pgTable("storage_locations", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      code: varchar("code", { length: 50 }).notNull().unique(),
      type: storageLocationType("type").notNull(),
      parentId: integer("parent_id"),
      description: text("description"),
      address: text("address"),
      capacity: numeric("capacity"),
      capacityUom: text("capacity_uom"),
      isActive: boolean("is_active").default(true),
      attributes: json("attributes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    vendors = pgTable("vendors", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      code: varchar("code", { length: 50 }).notNull().unique(),
      contactPerson: text("contact_person"),
      email: text("email"),
      phone: text("phone"),
      address: text("address"),
      taxId: text("tax_id"),
      status: vendorStatus("status").default("Active"),
      paymentTerms: text("payment_terms"),
      deliveryTerms: text("delivery_terms"),
      website: text("website"),
      notes: text("notes"),
      qualityRating: numeric("quality_rating"),
      deliveryRating: numeric("delivery_rating"),
      priceRating: numeric("price_rating"),
      categoryId: integer("category_id"),
      attributes: json("attributes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    vendorContracts = pgTable("vendor_contracts", {
      id: serial("id").primaryKey(),
      vendorId: integer("vendor_id").notNull(),
      contractNumber: varchar("contract_number", { length: 50 }).notNull().unique(),
      type: vendorContractType("type").notNull(),
      startDate: date("start_date").notNull(),
      endDate: date("end_date"),
      isActive: boolean("is_active").default(true),
      terms: text("terms"),
      notes: text("notes"),
      attachmentUrl: text("attachment_url"),
      autoRenew: boolean("auto_renew").default(false),
      notificationDays: integer("notification_days"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    vendorProducts = pgTable("vendor_products", {
      id: serial("id").primaryKey(),
      vendorId: integer("vendor_id").notNull(),
      materialId: integer("material_id").notNull(),
      vendorProductCode: varchar("vendor_product_code", { length: 100 }),
      vendorProductName: text("vendor_product_name"),
      price: numeric("price").notNull(),
      currency: varchar("currency", { length: 3 }).default("USD"),
      leadTime: integer("lead_time"),
      // in days
      minOrderQty: numeric("min_order_qty"),
      isPreferred: boolean("is_preferred").default(false),
      notes: text("notes"),
      lastPurchaseDate: date("last_purchase_date"),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at")
    });
    batchLots = pgTable("batch_lots", {
      id: serial("id").primaryKey(),
      batchNumber: varchar("batch_number", { length: 100 }).notNull().unique(),
      materialId: integer("material_id").notNull(),
      quantity: numeric("quantity").notNull(),
      remainingQuantity: numeric("remaining_quantity").notNull(),
      uom: text("uom").notNull(),
      status: batchStatus("status").default("Available"),
      manufacturingDate: date("manufacturing_date"),
      expirationDate: date("expiration_date"),
      receivedDate: date("received_date"),
      cost: numeric("cost"),
      locationId: integer("location_id"),
      vendorId: integer("vendor_id"),
      purchaseOrderNumber: text("purchase_order_number"),
      qualityStatus: text("quality_status"),
      attributes: json("attributes"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    materialValuations = pgTable("material_valuations", {
      id: serial("id").primaryKey(),
      materialId: integer("material_id").notNull(),
      valuationMethod: valuationMethod("valuation_method").notNull(),
      valuationDate: date("valuation_date").notNull(),
      unitValue: numeric("unit_value").notNull(),
      totalValue: numeric("total_value").notNull(),
      quantity: numeric("quantity").notNull(),
      currency: varchar("currency", { length: 3 }).default("USD"),
      calculationDetails: json("calculation_details"),
      periodId: integer("period_id"),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    materialValuationMethods = pgTable("material_valuation_methods", {
      id: serial("id").primaryKey(),
      name: valuationMethod("name").notNull(),
      description: text("description"),
      isDefault: boolean("is_default").default(false),
      isActive: boolean("is_active").default(true),
      defaultForMaterialTypes: json("default_for_material_types"),
      // Array of material types
      calculationLogic: text("calculation_logic"),
      lastCalculated: timestamp("last_calculated"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    mrpForecasts = pgTable("mrp_forecasts", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      description: text("description"),
      startDate: date("start_date").notNull(),
      endDate: date("end_date").notNull(),
      status: text("status").default("Draft"),
      creationMethod: text("creation_method").default("Manual"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at"),
      createdBy: integer("created_by"),
      updatedBy: integer("updated_by")
    });
    mrpForecastItems = pgTable("mrp_forecast_items", {
      id: serial("id").primaryKey(),
      forecastId: integer("forecast_id").notNull(),
      materialId: integer("material_id").notNull(),
      quantity: numeric("quantity").notNull(),
      periodStart: date("period_start").notNull(),
      periodEnd: date("period_end").notNull(),
      confidence: numeric("confidence"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at")
    });
    materialRequirements = pgTable("material_requirements", {
      id: serial("id").primaryKey(),
      materialId: integer("material_id").notNull(),
      requirementDate: date("requirement_date").notNull(),
      quantity: numeric("quantity").notNull(),
      source: text("source").notNull(),
      // Sales Order, Forecast, etc.
      sourceId: integer("source_id"),
      // Reference to the source record
      priority: text("priority").default("Normal"),
      status: text("status").default("Planned"),
      fulfilled: boolean("fulfilled").default(false),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at")
    });
    materialsRelations = relations(materials, ({ one, many }) => ({
      category: one(materialCategories, {
        fields: [materials.categoryId],
        references: [materialCategories.id]
      }),
      defaultLocation: one(storageLocations, {
        fields: [materials.defaultLocationId],
        references: [storageLocations.id]
      }),
      batches: many(batchLots),
      valuations: many(materialValuations),
      vendorProducts: many(vendorProducts)
    }));
    materialCategoriesRelations = relations(materialCategories, ({ one, many }) => ({
      parent: one(materialCategories, {
        fields: [materialCategories.parentId],
        references: [materialCategories.id]
      }),
      children: many(materialCategories),
      materials: many(materials)
    }));
    storageLocationsRelations = relations(storageLocations, ({ one, many }) => ({
      parent: one(storageLocations, {
        fields: [storageLocations.parentId],
        references: [storageLocations.id]
      }),
      children: many(storageLocations),
      materials: many(materials, { relationName: "defaultLocation" }),
      batches: many(batchLots)
    }));
    vendorsRelations = relations(vendors, ({ many }) => ({
      contracts: many(vendorContracts),
      products: many(vendorProducts),
      batches: many(batchLots)
    }));
    vendorContractsRelations = relations(vendorContracts, ({ one }) => ({
      vendor: one(vendors, {
        fields: [vendorContracts.vendorId],
        references: [vendors.id]
      })
    }));
    vendorProductsRelations = relations(vendorProducts, ({ one }) => ({
      vendor: one(vendors, {
        fields: [vendorProducts.vendorId],
        references: [vendors.id]
      }),
      material: one(materials, {
        fields: [vendorProducts.materialId],
        references: [materials.id]
      })
    }));
    batchLotsRelations = relations(batchLots, ({ one }) => ({
      material: one(materials, {
        fields: [batchLots.materialId],
        references: [materials.id]
      }),
      location: one(storageLocations, {
        fields: [batchLots.locationId],
        references: [storageLocations.id]
      }),
      vendor: one(vendors, {
        fields: [batchLots.vendorId],
        references: [vendors.id]
      })
    }));
    materialValuationsRelations = relations(materialValuations, ({ one }) => ({
      material: one(materials, {
        fields: [materialValuations.materialId],
        references: [materials.id]
      })
    }));
    mrpForecastsRelations = relations(mrpForecasts, ({ many }) => ({
      items: many(mrpForecastItems)
    }));
    mrpForecastItemsRelations = relations(mrpForecastItems, ({ one }) => ({
      forecast: one(mrpForecasts, {
        fields: [mrpForecastItems.forecastId],
        references: [mrpForecasts.id]
      }),
      material: one(materials, {
        fields: [mrpForecastItems.materialId],
        references: [materials.id]
      })
    }));
    materialRequirementsRelations = relations(materialRequirements, ({ one }) => ({
      material: one(materials, {
        fields: [materialRequirements.materialId],
        references: [materials.id]
      })
    }));
    insertMaterialSchema = createInsertSchema(materials).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaterialCategorySchema = createInsertSchema(materialCategories).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStorageLocationSchema = createInsertSchema(storageLocations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertVendorSchema = createInsertSchema(vendors).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertVendorContractSchema = createInsertSchema(vendorContracts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertVendorProductSchema = createInsertSchema(vendorProducts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBatchLotSchema = createInsertSchema(batchLots).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaterialValuationSchema = createInsertSchema(materialValuations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaterialValuationMethodSchema = createInsertSchema(materialValuationMethods).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMrpForecastSchema = createInsertSchema(mrpForecasts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMrpForecastItemSchema = createInsertSchema(mrpForecastItems).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaterialRequirementSchema = createInsertSchema(materialRequirements).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  accounts: () => accounts,
  activities: () => activities,
  apiKeys: () => apiKeys,
  apiProviderEnum: () => apiProviderEnum,
  assignments: () => assignments,
  batchLots: () => batchLots,
  batchLotsRelations: () => batchLotsRelations,
  batchStatus: () => batchStatus,
  billOfMaterials: () => billOfMaterials,
  bomItems: () => bomItems,
  cementManufacturing: () => cementManufacturing,
  communicationChannelEnum: () => communicationChannelEnum,
  communicationDirectionEnum: () => communicationDirectionEnum,
  communicationStatusEnum: () => communicationStatusEnum,
  communications: () => communications,
  contacts: () => contacts,
  customFieldGroupMapping: () => customFieldGroupMapping,
  customFieldGroups: () => customFieldGroups,
  customFieldTypeEnum: () => customFieldTypeEnum,
  customFieldValues: () => customFieldValues,
  customFields: () => customFields,
  equipment: () => equipment,
  equipmentStatusEnum: () => equipmentStatusEnum,
  eventTypeEnum: () => eventTypeEnum,
  events: () => events,
  formulaIngredients: () => formulaIngredients,
  insertAccountSchema: () => insertAccountSchema,
  insertActivitySchema: () => insertActivitySchema,
  insertApiKeySchema: () => insertApiKeySchema,
  insertAssignmentSchema: () => insertAssignmentSchema,
  insertBatchLotSchema: () => insertBatchLotSchema,
  insertBillOfMaterialsSchema: () => insertBillOfMaterialsSchema,
  insertBomItemSchema: () => insertBomItemSchema,
  insertCommunicationSchema: () => insertCommunicationSchema,
  insertContactSchema: () => insertContactSchema,
  insertCustomFieldGroupMappingSchema: () => insertCustomFieldGroupMappingSchema,
  insertCustomFieldGroupSchema: () => insertCustomFieldGroupSchema,
  insertCustomFieldSchema: () => insertCustomFieldSchema,
  insertCustomFieldValueSchema: () => insertCustomFieldValueSchema,
  insertEquipmentSchema: () => insertEquipmentSchema,
  insertEventSchema: () => insertEventSchema,
  insertInventoryTransactionSchema: () => insertInventoryTransactionSchema,
  insertInvoiceItemSchema: () => insertInvoiceItemSchema,
  insertInvoiceSchema: () => insertInvoiceSchema,
  insertLeadSchema: () => insertLeadSchema,
  insertLeadSourceSchema: () => insertLeadSourceSchema,
  insertMaintenanceRequestSchema: () => insertMaintenanceRequestSchema,
  insertManufacturingShiftSchema: () => insertManufacturingShiftSchema,
  insertMaterialCategorySchema: () => insertMaterialCategorySchema,
  insertMaterialConsumptionSchema: () => insertMaterialConsumptionSchema,
  insertMaterialRequirementSchema: () => insertMaterialRequirementSchema,
  insertMaterialSchema: () => insertMaterialSchema,
  insertMaterialValuationMethodSchema: () => insertMaterialValuationMethodSchema,
  insertMaterialValuationSchema: () => insertMaterialValuationSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertModulePermissionSchema: () => insertModulePermissionSchema,
  insertMrpForecastItemSchema: () => insertMrpForecastItemSchema,
  insertMrpForecastSchema: () => insertMrpForecastSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertOpportunitySchema: () => insertOpportunitySchema,
  insertProductCategorySchema: () => insertProductCategorySchema,
  insertProductSchema: () => insertProductSchema,
  insertProductionOrderOperationSchema: () => insertProductionOrderOperationSchema,
  insertProductionOrderSchema: () => insertProductionOrderSchema,
  insertProposalActivitySchema: () => insertProposalActivitySchema,
  insertProposalCollaboratorSchema: () => insertProposalCollaboratorSchema,
  insertProposalCommentSchema: () => insertProposalCommentSchema,
  insertProposalElementSchema: () => insertProposalElementSchema,
  insertProposalSchema: () => insertProposalSchema,
  insertProposalTemplateSchema: () => insertProposalTemplateSchema,
  insertPurchaseOrderItemSchema: () => insertPurchaseOrderItemSchema,
  insertPurchaseOrderSchema: () => insertPurchaseOrderSchema,
  insertQualityCheckParameterSchema: () => insertQualityCheckParameterSchema,
  insertQualityCheckSchema: () => insertQualityCheckSchema,
  insertQualityInspectionResultSchema: () => insertQualityInspectionResultSchema,
  insertQualityInspectionSchema: () => insertQualityInspectionSchema,
  insertQualityParameterSchema: () => insertQualityParameterSchema,
  insertRolePermissionSchema: () => insertRolePermissionSchema,
  insertRoutingOperationSchema: () => insertRoutingOperationSchema,
  insertRoutingSchema: () => insertRoutingSchema,
  insertShiftAssignmentSchema: () => insertShiftAssignmentSchema,
  insertShopifyCustomerSchema: () => insertShopifyCustomerSchema,
  insertShopifyOrderSchema: () => insertShopifyOrderSchema,
  insertShopifyProductSchema: () => insertShopifyProductSchema,
  insertShopifyStoreSchema: () => insertShopifyStoreSchema,
  insertSocialCampaignSchema: () => insertSocialCampaignSchema,
  insertSocialIntegrationSchema: () => insertSocialIntegrationSchema,
  insertSocialMessageSchema: () => insertSocialMessageSchema,
  insertStorageLocationSchema: () => insertStorageLocationSchema,
  insertSubscriptionPackageSchema: () => insertSubscriptionPackageSchema,
  insertSupportTicketSchema: () => insertSupportTicketSchema,
  insertSystemSettingSchema: () => insertSystemSettingSchema,
  insertTaskSchema: () => insertTaskSchema,
  insertTeamMemberSchema: () => insertTeamMemberSchema,
  insertTeamSchema: () => insertTeamSchema,
  insertTicketAttachmentSchema: () => insertTicketAttachmentSchema,
  insertTicketCommentSchema: () => insertTicketCommentSchema,
  insertUserPermissionSchema: () => insertUserPermissionSchema,
  insertUserSchema: () => insertUserSchema,
  insertUserSubscriptionSchema: () => insertUserSubscriptionSchema,
  insertVendorContractSchema: () => insertVendorContractSchema,
  insertVendorProductSchema: () => insertVendorProductSchema,
  insertVendorSchema: () => insertVendorSchema,
  insertWarehouseSchema: () => insertWarehouseSchema,
  insertWarehouseZoneSchema: () => insertWarehouseZoneSchema,
  insertWorkCenterSchema: () => insertWorkCenterSchema,
  insertWorkflowSchema: () => insertWorkflowSchema,
  inventoryTransactionTypeEnum: () => inventoryTransactionTypeEnum,
  inventoryTransactions: () => inventoryTransactions,
  invoiceItems: () => invoiceItems,
  invoiceStatusEnum: () => invoiceStatusEnum,
  invoices: () => invoices,
  leadSources: () => leadSources,
  leadStatusEnum: () => leadStatusEnum,
  leads: () => leads,
  maintenanceRequests: () => maintenanceRequests,
  maintenanceStatusEnum: () => maintenanceStatusEnum,
  maintenanceTypeEnum: () => maintenanceTypeEnum,
  manufacturingCosts: () => manufacturingCosts,
  manufacturingFormulas: () => manufacturingFormulas,
  manufacturingShifts: () => manufacturingShifts,
  manufacturingTypeEnum: () => manufacturingTypeEnum,
  materialCategories: () => materialCategories,
  materialCategoriesRelations: () => materialCategoriesRelations,
  materialConsumptions: () => materialConsumptions,
  materialRequirements: () => materialRequirements,
  materialRequirementsRelations: () => materialRequirementsRelations,
  materialType: () => materialType,
  materialTypeEnum: () => materialTypeEnum,
  materialValuationMethods: () => materialValuationMethods,
  materialValuations: () => materialValuations,
  materialValuationsRelations: () => materialValuationsRelations,
  materials: () => materials,
  materialsRelations: () => materialsRelations,
  messageStatusEnum: () => messageStatusEnum,
  messages: () => messages,
  modulePermissions: () => modulePermissions,
  mrpForecastItems: () => mrpForecastItems,
  mrpForecastItemsRelations: () => mrpForecastItemsRelations,
  mrpForecasts: () => mrpForecasts,
  mrpForecastsRelations: () => mrpForecastsRelations,
  notificationTypeEnum: () => notificationTypeEnum,
  notifications: () => notifications,
  opportunities: () => opportunities,
  opportunityStageEnum: () => opportunityStageEnum,
  orderStatuses: () => orderStatuses,
  paymentMethodEnum: () => paymentMethodEnum,
  permissionActionEnum: () => permissionActionEnum,
  pharmaManufacturing: () => pharmaManufacturing,
  productCategoriesTable: () => productCategoriesTable,
  productionOrderOperations: () => productionOrderOperations,
  productionOrderStatusEnum: () => productionOrderStatusEnum,
  productionOrders: () => productionOrders,
  productionPriorityEnum: () => productionPriorityEnum,
  products: () => products,
  proposalActivities: () => proposalActivities,
  proposalCollaborators: () => proposalCollaborators,
  proposalComments: () => proposalComments,
  proposalElementTypeEnum: () => proposalElementTypeEnum,
  proposalElements: () => proposalElements,
  proposalStatusEnum: () => proposalStatusEnum,
  proposalTemplates: () => proposalTemplates,
  proposals: () => proposals,
  purchaseOrderItems: () => purchaseOrderItems,
  purchaseOrderStatusEnum: () => purchaseOrderStatusEnum,
  purchaseOrders: () => purchaseOrders,
  qualityCheckParameters: () => qualityCheckParameters,
  qualityCheckResultEnum: () => qualityCheckResultEnum,
  qualityCheckStatusEnum: () => qualityCheckStatusEnum,
  qualityChecks: () => qualityChecks,
  qualityInspectionResultEnum: () => qualityInspectionResultEnum,
  qualityInspectionResults: () => qualityInspectionResults,
  qualityInspections: () => qualityInspections,
  qualityParameterResultEnum: () => qualityParameterResultEnum,
  qualityParameters: () => qualityParameters,
  rolePermissions: () => rolePermissions,
  routingOperations: () => routingOperations,
  routings: () => routings,
  shiftAssignments: () => shiftAssignments,
  shopifyCustomers: () => shopifyCustomers,
  shopifyOrders: () => shopifyOrders,
  shopifyProductCategoryEnum: () => shopifyProductCategoryEnum,
  shopifyProducts: () => shopifyProducts,
  shopifyStores: () => shopifyStores,
  socialCampaigns: () => socialCampaigns,
  socialIntegrations: () => socialIntegrations,
  socialMessages: () => socialMessages,
  socialPlatformEnum: () => socialPlatformEnum,
  storageLocationType: () => storageLocationType,
  storageLocations: () => storageLocations,
  storageLocationsRelations: () => storageLocationsRelations,
  storageUnitType: () => storageUnitType,
  subscriptionPackages: () => subscriptionPackages,
  subscriptionStatusEnum: () => subscriptionStatusEnum,
  supportTickets: () => supportTickets,
  systemSettings: () => systemSettings,
  taskPriorityEnum: () => taskPriorityEnum,
  taskStatusEnum: () => taskStatusEnum,
  tasks: () => tasks,
  teamMembers: () => teamMembers,
  teams: () => teams,
  textileManufacturing: () => textileManufacturing,
  ticketAttachments: () => ticketAttachments,
  ticketComments: () => ticketComments,
  ticketPriorities: () => ticketPriorities,
  ticketStatuses: () => ticketStatuses,
  ticketTypes: () => ticketTypes,
  unitOfMeasureEnum: () => unitOfMeasureEnum,
  userPermissions: () => userPermissions,
  userRoleEnum: () => userRoleEnum,
  userSubscriptions: () => userSubscriptions,
  users: () => users,
  valuationMethod: () => valuationMethod,
  vendorContractType: () => vendorContractType,
  vendorContracts: () => vendorContracts,
  vendorContractsRelations: () => vendorContractsRelations,
  vendorProducts: () => vendorProducts,
  vendorProductsRelations: () => vendorProductsRelations,
  vendorStatus: () => vendorStatus,
  vendors: () => vendors,
  vendorsRelations: () => vendorsRelations,
  warehouseZones: () => warehouseZones,
  warehouses: () => warehouses,
  workCenterStatusEnum: () => workCenterStatusEnum,
  workCenters: () => workCenters,
  workflows: () => workflows
});
import { pgTable as pgTable2, text as text2, serial as serial2, integer as integer2, boolean as boolean2, timestamp as timestamp2, pgEnum as pgEnum2, date as date2, numeric as numeric2, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
import { z } from "zod";
var qualityCheckStatusEnum, qualityCheckResultEnum, qualityParameterResultEnum, qualityChecks, qualityCheckParameters, insertQualityCheckSchema, insertQualityCheckParameterSchema, leadStatusEnum, opportunityStageEnum, taskPriorityEnum, taskStatusEnum, eventTypeEnum, subscriptionStatusEnum, userRoleEnum, permissionActionEnum, socialPlatformEnum, messageStatusEnum, notificationTypeEnum, apiProviderEnum, communicationChannelEnum, communicationDirectionEnum, communicationStatusEnum, invoiceStatusEnum, inventoryTransactionTypeEnum, productionOrderStatusEnum, productionPriorityEnum, qualityInspectionResultEnum, maintenanceTypeEnum, maintenanceStatusEnum, equipmentStatusEnum, workCenterStatusEnum, manufacturingTypeEnum, materialTypeEnum, unitOfMeasureEnum, paymentMethodEnum, purchaseOrderStatusEnum, proposalStatusEnum, proposalElementTypeEnum, customFieldTypeEnum, systemSettings, insertSystemSettingSchema, users, contacts, accounts, leads, opportunities, tasks, events, activities, subscriptionPackages, notifications, insertNotificationSchema, messages, insertMessageSchema, userSubscriptions, socialIntegrations, socialMessages, leadSources, socialCampaigns, apiKeys, workflows, customFields, insertCustomFieldSchema, customFieldValues, insertCustomFieldValueSchema, customFieldGroups, insertCustomFieldGroupSchema, customFieldGroupMapping, insertCustomFieldGroupMappingSchema, communications, proposalTemplates, proposals, proposalElements, proposalCollaborators, proposalComments, proposalActivities, productCategoriesRef, productCategoriesTable, products, modulePermissions, rolePermissions, userPermissions, teamsRef, teams, teamMembers, assignments, inventoryTransactions, invoices, invoiceItems, purchaseOrders, purchaseOrderItems, insertUserSchema, insertContactSchema, insertAccountSchema, insertLeadSchema, insertOpportunitySchema, insertTaskSchema, insertEventSchema, insertActivitySchema, insertSubscriptionPackageSchema, insertUserSubscriptionSchema, insertSocialIntegrationSchema, insertSocialMessageSchema, insertLeadSourceSchema, insertSocialCampaignSchema, insertWorkflowSchema, insertApiKeySchema, insertCommunicationSchema, insertProposalTemplateSchema, insertProposalSchema, insertProposalElementSchema, insertProposalCollaboratorSchema, insertProposalCommentSchema, insertProposalActivitySchema, insertProductCategorySchema, insertProductSchema, insertInventoryTransactionSchema, insertInvoiceSchema, insertInvoiceItemSchema, insertPurchaseOrderSchema, insertPurchaseOrderItemSchema, warehouses, warehouseZones, workCenters, billOfMaterials, bomItems, routings, routingOperations, productionOrders, productionOrderOperations, materialConsumptions, qualityInspections, qualityParameters, qualityInspectionResults, equipment, maintenanceRequests, manufacturingShifts, shiftAssignments, pharmaManufacturing, textileManufacturing, cementManufacturing, manufacturingCosts, manufacturingFormulas, formulaIngredients, insertWarehouseSchema, insertWarehouseZoneSchema, insertWorkCenterSchema, insertBillOfMaterialsSchema, insertBomItemSchema, insertRoutingSchema, insertRoutingOperationSchema, insertProductionOrderSchema, insertProductionOrderOperationSchema, insertMaterialConsumptionSchema, insertQualityInspectionSchema, insertQualityParameterSchema, insertQualityInspectionResultSchema, insertEquipmentSchema, insertMaintenanceRequestSchema, insertManufacturingShiftSchema, insertShiftAssignmentSchema, insertModulePermissionSchema, insertRolePermissionSchema, insertUserPermissionSchema, insertTeamSchema, insertTeamMemberSchema, insertAssignmentSchema, ticketPriorities, ticketStatuses, ticketTypes, supportTickets, ticketComments, ticketAttachments, shopifyStores, shopifyProductCategoryEnum, shopifyProducts, shopifyCustomers, orderStatuses, shopifyOrders, insertSupportTicketSchema, insertTicketCommentSchema, insertTicketAttachmentSchema, insertShopifyStoreSchema, insertShopifyProductSchema, insertShopifyCustomerSchema, insertShopifyOrderSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_manufacturing_schema();
    qualityCheckStatusEnum = pgEnum2("quality_check_status", ["Planned", "In Progress", "Completed", "Cancelled"]);
    qualityCheckResultEnum = pgEnum2("quality_check_result", ["Pass", "Fail", "Conditional Pass", "Not Applicable"]);
    qualityParameterResultEnum = pgEnum2("quality_parameter_result", ["Pass", "Fail", "Not Tested"]);
    qualityChecks = pgTable2("quality_checks", {
      id: serial2("id").primaryKey(),
      inspection_number: text2("inspection_number").notNull(),
      type: text2("type").notNull(),
      // Incoming, In-Process, Final, etc.
      status: qualityCheckStatusEnum("status").default("Planned"),
      result: qualityCheckResultEnum("result"),
      production_order_id: integer2("production_order_id"),
      // References added in relations
      batch_lot_id: integer2("batch_lot_id"),
      // References added in relations
      product_id: integer2("product_id").references(() => products.id),
      inspector_id: integer2("inspector_id").references(() => users.id),
      inspection_date: timestamp2("inspection_date"),
      notes: text2("notes"),
      sample_size: integer2("sample_size"),
      acceptance_criteria: text2("acceptance_criteria"),
      created_at: timestamp2("created_at").defaultNow(),
      updated_at: timestamp2("updated_at"),
      created_by: integer2("created_by")
    });
    qualityCheckParameters = pgTable2("quality_check_parameters", {
      id: serial2("id").primaryKey(),
      quality_check_id: integer2("quality_check_id").references(() => qualityChecks.id).notNull(),
      parameter_name: text2("parameter_name").notNull(),
      specification: text2("specification"),
      result: qualityParameterResultEnum("result"),
      measured_value: text2("measured_value"),
      notes: text2("notes"),
      created_at: timestamp2("created_at").defaultNow(),
      updated_at: timestamp2("updated_at")
    });
    insertQualityCheckSchema = createInsertSchema2(qualityChecks).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertQualityCheckParameterSchema = createInsertSchema2(qualityCheckParameters).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    leadStatusEnum = pgEnum2("lead_status", ["New", "Qualified", "Contacted", "Not Interested", "Converted"]);
    opportunityStageEnum = pgEnum2("opportunity_stage", ["Lead Generation", "Qualification", "Proposal", "Negotiation", "Closing"]);
    taskPriorityEnum = pgEnum2("task_priority", ["High", "Medium", "Normal"]);
    taskStatusEnum = pgEnum2("task_status", ["Not Started", "In Progress", "Completed", "Deferred"]);
    eventTypeEnum = pgEnum2("event_type", ["Meeting", "Call", "Demonstration", "Follow-up", "Other"]);
    subscriptionStatusEnum = pgEnum2("subscription_status", ["Active", "Pending", "Expired", "Canceled", "Trial"]);
    userRoleEnum = pgEnum2("user_role", ["Admin", "Manager", "User", "ReadOnly"]);
    permissionActionEnum = pgEnum2("permission_action", ["view", "create", "update", "delete", "export", "import", "assign"]);
    socialPlatformEnum = pgEnum2("social_platform", ["Facebook", "LinkedIn", "Twitter", "Instagram", "WhatsApp", "Email", "Messenger", "Other"]);
    messageStatusEnum = pgEnum2("message_status", ["Unread", "Read", "Replied", "Archived"]);
    notificationTypeEnum = pgEnum2("notification_type", ["task", "meeting", "opportunity", "lead", "system", "message"]);
    apiProviderEnum = pgEnum2("api_provider", ["OpenAI", "Stripe", "Facebook", "LinkedIn", "Twitter", "WhatsApp", "Other"]);
    communicationChannelEnum = pgEnum2("communication_channel", ["Email", "WhatsApp", "SMS", "Phone", "Messenger", "LinkedIn", "Twitter", "Facebook", "Instagram", "Other"]);
    communicationDirectionEnum = pgEnum2("communication_direction", ["Inbound", "Outbound"]);
    communicationStatusEnum = pgEnum2("communication_status", ["Unread", "Read", "Replied", "Archived"]);
    invoiceStatusEnum = pgEnum2("invoice_status", ["Draft", "Sent", "Paid", "Overdue", "Cancelled", "Refunded"]);
    inventoryTransactionTypeEnum = pgEnum2("inventory_transaction_type", ["Purchase", "Sale", "Adjustment", "Return", "Transfer", "Production", "Consumption", "QualityReject", "ScrapDisposal", "IntakeForProduction", "ProductionOutput"]);
    productionOrderStatusEnum = pgEnum2("production_order_status", ["Draft", "Scheduled", "InProgress", "Completed", "OnHold", "Cancelled"]);
    productionPriorityEnum = pgEnum2("production_priority", ["Critical", "High", "Medium", "Low"]);
    qualityInspectionResultEnum = pgEnum2("quality_inspection_result", ["Pass", "Fail", "PendingReview", "Acceptable", "Rework"]);
    maintenanceTypeEnum = pgEnum2("maintenance_type", ["Preventive", "Corrective", "Predictive", "Condition-Based"]);
    maintenanceStatusEnum = pgEnum2("maintenance_status", ["Scheduled", "InProgress", "Completed", "Deferred", "Cancelled"]);
    equipmentStatusEnum = pgEnum2("equipment_status", ["Operational", "UnderMaintenance", "Idle", "Decommissioned", "Faulty"]);
    workCenterStatusEnum = pgEnum2("work_center_status", ["Active", "Inactive", "AtCapacity", "UnderMaintenance"]);
    manufacturingTypeEnum = pgEnum2("manufacturing_type", ["Discrete", "Process", "Repetitive", "Batch", "Lean", "Custom"]);
    materialTypeEnum = pgEnum2("material_type", ["RawMaterial", "Intermediate", "FinishedGood", "Packaging", "Consumable", "Spare"]);
    unitOfMeasureEnum = pgEnum2("unit_of_measure", ["Each", "Kilogram", "Gram", "Liter", "Milliliter", "Meter", "SquareMeter", "CubicMeter", "Hour", "Minute", "Ton", "Dozen"]);
    paymentMethodEnum = pgEnum2("payment_method", ["Cash", "Credit Card", "Bank Transfer", "Check", "PayPal", "Other"]);
    purchaseOrderStatusEnum = pgEnum2("purchase_order_status", ["Draft", "Sent", "Received", "Cancelled", "Partially Received"]);
    proposalStatusEnum = pgEnum2("proposal_status", ["Draft", "Sent", "Accepted", "Rejected", "Expired", "Revoked"]);
    proposalElementTypeEnum = pgEnum2("proposal_element_type", ["Header", "Text", "Image", "Table", "List", "Quote", "ProductList", "Signature", "PageBreak", "Custom"]);
    customFieldTypeEnum = pgEnum2("custom_field_type", ["Text", "Number", "Date", "Boolean", "Dropdown", "MultiSelect", "Email", "Phone", "URL", "TextArea", "Currency"]);
    systemSettings = pgTable2("system_settings", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id),
      settingKey: text2("setting_key").notNull(),
      settingValue: jsonb("setting_value").notNull(),
      scope: text2("scope").default("user"),
      // 'user' or 'global'
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    insertSystemSettingSchema = createInsertSchema2(systemSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    users = pgTable2("users", {
      id: serial2("id").primaryKey(),
      username: text2("username").notNull().unique(),
      password: text2("password").notNull(),
      firstName: text2("first_name"),
      lastName: text2("last_name"),
      email: text2("email").notNull().unique(),
      role: text2("role").default("User"),
      avatar: text2("avatar"),
      createdAt: timestamp2("created_at").defaultNow(),
      // Stripe integration fields
      stripeCustomerId: text2("stripe_customer_id").unique(),
      stripeSubscriptionId: text2("stripe_subscription_id").unique(),
      // Account management
      isActive: boolean2("is_active").default(true),
      lastLogin: timestamp2("last_login"),
      isVerified: boolean2("is_verified").default(false),
      company: text2("company"),
      packageId: integer2("package_id")
    });
    contacts = pgTable2("contacts", {
      id: serial2("id").primaryKey(),
      firstName: text2("first_name").notNull(),
      lastName: text2("last_name").notNull(),
      email: text2("email"),
      phone: text2("phone"),
      title: text2("title"),
      accountId: integer2("account_id").references(() => accounts.id),
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      address: text2("address"),
      city: text2("city"),
      state: text2("state"),
      zip: text2("zip"),
      country: text2("country"),
      notes: text2("notes"),
      isActive: boolean2("is_active").default(true)
    });
    accounts = pgTable2("accounts", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      industry: text2("industry"),
      website: text2("website"),
      phone: text2("phone"),
      email: text2("email"),
      billingAddress: text2("billing_address"),
      billingCity: text2("billing_city"),
      billingState: text2("billing_state"),
      billingZip: text2("billing_zip"),
      billingCountry: text2("billing_country"),
      // Location fields
      address: text2("address"),
      city: text2("city"),
      state: text2("state"),
      zip: text2("zip"),
      country: text2("country"),
      // Other fields
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      annualRevenue: numeric2("annual_revenue"),
      employeeCount: integer2("employee_count"),
      notes: text2("notes"),
      isActive: boolean2("is_active").default(true),
      type: text2("type"),
      // Added account type field
      numberOfEmployees: integer2("number_of_employees")
      // Added for better UI display
    });
    leads = pgTable2("leads", {
      id: serial2("id").primaryKey(),
      firstName: text2("first_name").notNull(),
      lastName: text2("last_name").notNull(),
      email: text2("email"),
      phone: text2("phone"),
      company: text2("company"),
      title: text2("title"),
      status: leadStatusEnum("status").default("New"),
      source: text2("source"),
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      notes: text2("notes"),
      isConverted: boolean2("is_converted").default(false),
      convertedToContactId: integer2("converted_to_contact_id").references(() => contacts.id),
      convertedToAccountId: integer2("converted_to_account_id").references(() => accounts.id),
      convertedToOpportunityId: integer2("converted_to_opportunity_id").references(() => opportunities.id)
    });
    opportunities = pgTable2("opportunities", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      accountId: integer2("account_id").references(() => accounts.id),
      stage: opportunityStageEnum("stage").default("Lead Generation"),
      amount: numeric2("amount"),
      expectedCloseDate: date2("expected_close_date"),
      probability: integer2("probability"),
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      notes: text2("notes"),
      isClosed: boolean2("is_closed").default(false),
      isWon: boolean2("is_won").default(false)
    });
    tasks = pgTable2("tasks", {
      id: serial2("id").primaryKey(),
      title: text2("title").notNull(),
      description: text2("description"),
      dueDate: date2("due_date"),
      priority: taskPriorityEnum("priority").default("Normal"),
      status: taskStatusEnum("status").default("Not Started"),
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      relatedToType: text2("related_to_type"),
      // 'contact', 'account', 'lead', 'opportunity'
      relatedToId: integer2("related_to_id"),
      isReminder: boolean2("is_reminder").default(false),
      reminderDate: timestamp2("reminder_date")
    });
    events = pgTable2("events", {
      id: serial2("id").primaryKey(),
      title: text2("title").notNull(),
      description: text2("description"),
      startDate: timestamp2("start_date").notNull(),
      endDate: timestamp2("end_date").notNull(),
      location: text2("location"),
      locationType: text2("location_type").default("physical"),
      // 'physical' or 'virtual'
      eventType: eventTypeEnum("event_type").default("Meeting"),
      status: text2("status").default("Confirmed"),
      // 'Confirmed', 'Tentative', 'Cancelled'
      ownerId: integer2("owner_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      isAllDay: boolean2("is_all_day").default(false),
      isRecurring: boolean2("is_recurring").default(false),
      recurringRule: text2("recurring_rule")
    });
    activities = pgTable2("activities", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id),
      action: text2("action").notNull(),
      detail: text2("detail"),
      relatedToType: text2("related_to_type"),
      // 'contact', 'account', 'lead', 'opportunity', 'task', 'event'
      relatedToId: integer2("related_to_id"),
      createdAt: timestamp2("created_at").defaultNow(),
      icon: text2("icon").default("added")
      // 'added', 'completed', 'commented', 'scheduled'
    });
    subscriptionPackages = pgTable2("subscription_packages", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description").notNull(),
      price: numeric2("price").notNull(),
      interval: text2("interval").notNull(),
      // 'monthly', 'yearly'
      stripePriceId: text2("stripe_price_id"),
      features: text2("features").array(),
      maxUsers: integer2("max_users").notNull(),
      maxContacts: integer2("max_contacts").notNull(),
      maxStorage: integer2("max_storage").notNull(),
      // in GB
      isActive: boolean2("is_active").default(true),
      displayOrder: integer2("display_order").default(0),
      createdAt: timestamp2("created_at").defaultNow()
    });
    notifications = pgTable2("notifications", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      type: notificationTypeEnum("type").default("system"),
      title: text2("title").notNull(),
      description: text2("description").notNull(),
      read: boolean2("read").default(false),
      createdAt: timestamp2("created_at").defaultNow(),
      link: text2("link"),
      relatedToType: text2("related_to_type"),
      // Which entity this notification is related to
      relatedToId: integer2("related_to_id")
      // ID of the related entity
    });
    insertNotificationSchema = createInsertSchema2(notifications).omit({
      id: true,
      createdAt: true
    });
    messages = pgTable2("messages", {
      id: serial2("id").primaryKey(),
      senderId: integer2("sender_id").references(() => users.id).notNull(),
      recipientId: integer2("recipient_id").references(() => users.id).notNull(),
      content: text2("content").notNull(),
      read: boolean2("read").default(false),
      createdAt: timestamp2("created_at").defaultNow(),
      urgent: boolean2("urgent").default(false)
    });
    insertMessageSchema = createInsertSchema2(messages).omit({
      id: true,
      createdAt: true
    });
    userSubscriptions = pgTable2("user_subscriptions", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      packageId: integer2("package_id").references(() => subscriptionPackages.id).notNull(),
      status: subscriptionStatusEnum("status").default("Pending"),
      startDate: timestamp2("start_date").notNull(),
      endDate: timestamp2("end_date"),
      stripeSubscriptionId: text2("stripe_subscription_id"),
      canceledAt: timestamp2("canceled_at"),
      currentPeriodStart: timestamp2("current_period_start"),
      currentPeriodEnd: timestamp2("current_period_end"),
      createdAt: timestamp2("created_at").defaultNow(),
      trialEndsAt: timestamp2("trial_ends_at")
    });
    socialIntegrations = pgTable2("social_integrations", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      platform: socialPlatformEnum("platform").notNull(),
      name: text2("name").notNull(),
      accountId: text2("account_id").notNull(),
      accessToken: text2("access_token"),
      refreshToken: text2("refresh_token"),
      tokenExpiry: timestamp2("token_expiry"),
      settings: jsonb("settings"),
      // Replaced config with settings
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      isActive: boolean2("is_active").default(true)
    });
    socialMessages = pgTable2("social_messages", {
      id: serial2("id").primaryKey(),
      integrationId: integer2("integration_id").references(() => socialIntegrations.id).notNull(),
      externalId: text2("external_id").notNull(),
      // ID from external platform
      leadId: integer2("lead_id").references(() => leads.id),
      contactId: integer2("contact_id").references(() => contacts.id),
      sender: text2("sender").notNull(),
      // 'system' or 'user'
      recipient: text2("recipient").notNull(),
      // 'system' or 'user'
      message: text2("message").notNull(),
      attachments: jsonb("attachments"),
      // Array of attachment objects
      metadata: jsonb("metadata"),
      // Platform-specific metadata
      status: messageStatusEnum("status").default("Unread"),
      // We only use created_at for timestamps, not sent_at
      receivedAt: timestamp2("received_at"),
      createdAt: timestamp2("created_at").defaultNow(),
      isDeleted: boolean2("is_deleted").default(false),
      // Fields for relating messages to different entities
      relatedToType: text2("related_to_type"),
      // 'account', 'opportunity', etc.
      relatedToId: integer2("related_to_id")
      // ID of the related entity
    });
    leadSources = pgTable2("lead_sources", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      isActive: boolean2("is_active").default(true),
      platform: socialPlatformEnum("platform"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    socialCampaigns = pgTable2("social_campaigns", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      platform: socialPlatformEnum("platform").notNull(),
      startDate: timestamp2("start_date"),
      endDate: timestamp2("end_date"),
      status: text2("status").default("Draft"),
      // Draft, Active, Paused, Completed
      ownerId: integer2("owner_id").references(() => users.id),
      content: text2("content"),
      // Note: targetAudience is currently in metrics json
      integrationId: integer2("integration_id"),
      metrics: jsonb("metrics"),
      // Performance metrics including target audience data
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      isActive: boolean2("is_active").default(true)
    });
    apiKeys = pgTable2("api_keys", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      provider: text2("provider").notNull(),
      key: text2("key").notNull(),
      secret: text2("secret"),
      additionalFields: jsonb("additional_fields"),
      // For service-specific fields like TWILIO_PHONE_NUMBER
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      usageCount: integer2("usage_count").default(0),
      lastUsed: timestamp2("last_used"),
      ownerId: integer2("owner_id").references(() => users.id).notNull(),
      // Added userId to track which subscriber owns this key
      userId: integer2("user_id").references(() => users.id).notNull()
    });
    workflows = pgTable2("workflows", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      entityType: text2("entity_type").notNull(),
      // 'lead', 'contact', 'opportunity', etc.
      entityFilter: jsonb("entity_filter"),
      // JSON condition to trigger workflow
      actions: jsonb("actions").notNull(),
      // Array of actions to perform
      isActive: boolean2("is_active").default(true),
      createdBy: integer2("created_by").references(() => users.id),
      updatedBy: integer2("updated_by").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      version: integer2("version").default(1),
      settings: jsonb("settings")
      // Configuration options
    });
    customFields = pgTable2("custom_fields", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      label: text2("label").notNull(),
      type: customFieldTypeEnum("type").notNull(),
      entityType: text2("entity_type").notNull(),
      // 'contact', 'account', 'lead', 'opportunity', etc.
      options: jsonb("options"),
      // For dropdown and multi-select types
      isRequired: boolean2("is_required").default(false),
      defaultValue: text2("default_value"),
      placeholder: text2("placeholder"),
      description: text2("description"),
      sortOrder: integer2("sort_order").default(0),
      isActive: boolean2("is_active").default(true),
      isSystem: boolean2("is_system").default(false),
      // System fields can't be deleted
      createdBy: integer2("created_by").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      validationRules: jsonb("validation_rules"),
      // JSON with validation rule config
      showInList: boolean2("show_in_list").default(false),
      // Show in list views
      showInDetail: boolean2("show_in_detail").default(true),
      // Show in detail views
      showInForm: boolean2("show_in_form").default(true)
      // Show in forms
    });
    insertCustomFieldSchema = createInsertSchema2(customFields).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customFieldValues = pgTable2("custom_field_values", {
      id: serial2("id").primaryKey(),
      fieldId: integer2("field_id").references(() => customFields.id).notNull(),
      entityId: integer2("entity_id").notNull(),
      // ID of the entity (contact, account, etc.)
      entityType: text2("entity_type").notNull(),
      // 'contact', 'account', 'lead', 'opportunity', etc.
      value: text2("value"),
      // String representation of the value
      textValue: text2("text_value"),
      // For text or long text
      numberValue: numeric2("number_value"),
      // For numeric fields
      dateValue: timestamp2("date_value"),
      // For date/time
      booleanValue: boolean2("boolean_value"),
      // For checkboxes
      arrayValue: jsonb("array_value"),
      // For multi-select
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    insertCustomFieldValueSchema = createInsertSchema2(customFieldValues).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customFieldGroups = pgTable2("custom_field_groups", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      entityType: text2("entity_type").notNull(),
      // 'contact', 'account', 'lead', 'opportunity', etc.
      label: text2("label").notNull(),
      description: text2("description"),
      sortOrder: integer2("sort_order").default(0),
      isActive: boolean2("is_active").default(true),
      createdBy: integer2("created_by").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    insertCustomFieldGroupSchema = createInsertSchema2(customFieldGroups).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customFieldGroupMapping = pgTable2("custom_field_group_mapping", {
      id: serial2("id").primaryKey(),
      fieldId: integer2("field_id").references(() => customFields.id).notNull(),
      groupId: integer2("group_id").references(() => customFieldGroups.id).notNull(),
      sortOrder: integer2("sort_order").default(0),
      createdAt: timestamp2("created_at").defaultNow()
    });
    insertCustomFieldGroupMappingSchema = createInsertSchema2(customFieldGroupMapping).omit({
      id: true,
      createdAt: true
    });
    communications = pgTable2("communications", {
      id: serial2("id").primaryKey(),
      contactId: integer2("contact_id").references(() => contacts.id),
      leadId: integer2("lead_id").references(() => leads.id),
      channel: communicationChannelEnum("channel").notNull(),
      direction: communicationDirectionEnum("direction").notNull(),
      content: text2("content").notNull(),
      status: communicationStatusEnum("status").default("Unread"),
      sentAt: timestamp2("sent_at").notNull(),
      receivedAt: timestamp2("received_at"),
      attachments: jsonb("attachments"),
      // Array of attachment objects
      metadata: jsonb("metadata"),
      // Platform-specific metadata
      createdAt: timestamp2("created_at").defaultNow(),
      ownerId: integer2("owner_id").references(() => users.id),
      contactType: text2("contact_type")
      // 'lead' or 'customer'
    });
    proposalTemplates = pgTable2("proposal_templates", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      content: jsonb("content").notNull(),
      // JSON structure for template layout and sections
      thumbnail: text2("thumbnail"),
      // URL or path to template thumbnail
      isDefault: boolean2("is_default").default(false),
      createdBy: integer2("created_by").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      isActive: boolean2("is_active").default(true),
      category: text2("category").default("General"),
      // E.g., "Sales", "Service", "General", etc.
      tags: text2("tags").array()
    });
    proposals = pgTable2("proposals", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      opportunityId: integer2("opportunity_id").references(() => opportunities.id).notNull(),
      accountId: integer2("account_id").references(() => accounts.id).notNull(),
      status: proposalStatusEnum("status").default("Draft"),
      content: jsonb("content").notNull(),
      // JSON structure for proposal content
      templateId: integer2("template_id").references(() => proposalTemplates.id),
      createdBy: integer2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      sentAt: timestamp2("sent_at"),
      expiresAt: timestamp2("expires_at"),
      acceptedAt: timestamp2("accepted_at"),
      rejectedAt: timestamp2("rejected_at"),
      totalAmount: numeric2("total_amount"),
      currency: text2("currency").default("USD"),
      versionNumber: integer2("version_number").default(1),
      previousVersionId: integer2("previous_version_id").references(() => proposals.id),
      settings: jsonb("settings"),
      // Configuration options like page size, fonts, colors
      metadata: jsonb("metadata")
      // Additional data like view count, time spent viewing
    });
    proposalElements = pgTable2("proposal_elements", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      elementType: proposalElementTypeEnum("element_type").notNull(),
      content: jsonb("content").notNull(),
      // JSON structure for element content
      proposalId: integer2("proposal_id").references(() => proposals.id).notNull(),
      sortOrder: integer2("sort_order").default(0),
      createdBy: integer2("created_by").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      isGlobal: boolean2("is_global").default(false),
      // If true, available to all users
      isActive: boolean2("is_active").default(true),
      category: text2("category").default("General"),
      thumbnail: text2("thumbnail")
      // URL or path to element thumbnail
    });
    proposalCollaborators = pgTable2("proposal_collaborators", {
      id: serial2("id").primaryKey(),
      proposalId: integer2("proposal_id").references(() => proposals.id).notNull(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      role: text2("role").default("Editor"),
      // "Editor", "Viewer", "Approver"
      addedBy: integer2("added_by").references(() => users.id),
      addedAt: timestamp2("added_at").defaultNow(),
      lastAccessed: timestamp2("last_accessed"),
      notifications: boolean2("notifications").default(true)
    });
    proposalComments = pgTable2("proposal_comments", {
      id: serial2("id").primaryKey(),
      proposalId: integer2("proposal_id").references(() => proposals.id).notNull(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      content: text2("content").notNull(),
      elementPath: text2("element_path"),
      // JSON path to the commented element
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      resolved: boolean2("resolved").default(false),
      resolvedBy: integer2("resolved_by").references(() => users.id),
      resolvedAt: timestamp2("resolved_at"),
      parentId: integer2("parent_id").references(() => proposalComments.id)
      // For threaded comments
    });
    proposalActivities = pgTable2("proposal_activities", {
      id: serial2("id").primaryKey(),
      proposalId: integer2("proposal_id").references(() => proposals.id).notNull(),
      userId: integer2("user_id").references(() => users.id),
      activityType: text2("activity_type").notNull(),
      // "created", "edited", "commented", "sent", "viewed", "accepted", "rejected"
      description: text2("description"),
      createdAt: timestamp2("created_at").defaultNow(),
      metadata: jsonb("metadata")
      // Additional information like client IP, device, etc.
    });
    productCategoriesRef = pgTable2("product_categories", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      parentId: integer2("parent_id")
    });
    productCategoriesTable = pgTable2("product_categories", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      parentId: integer2("parent_id").references(() => productCategoriesRef.id),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      image: text2("image"),
      // URL or path to category image
      attributes: jsonb("attributes"),
      // Custom attributes for the category
      ownerId: integer2("owner_id").references(() => users.id)
    });
    products = pgTable2("products", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      sku: text2("sku").notNull().unique(),
      description: text2("description"),
      price: numeric2("price").notNull(),
      cost: numeric2("cost"),
      categoryId: integer2("category_id").references(() => productCategoriesTable.id),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      inStock: boolean2("in_stock").default(true),
      stockQuantity: integer2("stock_quantity").default(0),
      reorderLevel: integer2("reorder_level").default(5),
      attributes: jsonb("attributes"),
      // Additional product properties
      images: text2("images").array(),
      // Array of image URLs
      taxable: boolean2("taxable").default(true),
      taxRate: numeric2("tax_rate"),
      ownerId: integer2("owner_id").references(() => users.id),
      weight: numeric2("weight"),
      // In kg
      dimensions: jsonb("dimensions"),
      // {length, width, height} in cm
      barcode: text2("barcode"),
      tags: text2("tags").array()
    });
    modulePermissions = pgTable2("module_permissions", {
      id: serial2("id").primaryKey(),
      moduleName: text2("module_name").notNull(),
      // 'contacts', 'accounts', 'leads', 'opportunities', 'tasks', etc.
      displayName: text2("display_name").notNull(),
      description: text2("description"),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      order: integer2("order").default(0),
      icon: text2("icon")
    });
    rolePermissions = pgTable2("role_permissions", {
      id: serial2("id").primaryKey(),
      role: userRoleEnum("role").notNull(),
      moduleId: integer2("module_id").references(() => modulePermissions.id).notNull(),
      action: permissionActionEnum("action").notNull(),
      isAllowed: boolean2("is_allowed").default(false),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    userPermissions = pgTable2("user_permissions", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      moduleId: integer2("module_id").references(() => modulePermissions.id).notNull(),
      action: permissionActionEnum("action").notNull(),
      isAllowed: boolean2("is_allowed").default(false),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    teamsRef = pgTable2("teams", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description")
    });
    teams = pgTable2("teams", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      createdBy: integer2("created_by").references(() => users.id),
      parentTeamId: integer2("parent_team_id").references(() => teamsRef.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      isActive: boolean2("is_active").default(true)
    });
    teamMembers = pgTable2("team_members", {
      id: serial2("id").primaryKey(),
      teamId: integer2("team_id").references(() => teams.id).notNull(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      role: text2("role").default("Member"),
      // 'Leader', 'Member'
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    assignments = pgTable2("assignments", {
      id: serial2("id").primaryKey(),
      entityType: text2("entity_type").notNull(),
      // 'lead', 'contact', 'account', 'opportunity'
      entityId: integer2("entity_id").notNull(),
      assignedToType: text2("assigned_to_type").notNull(),
      // 'user' or 'team'
      assignedToId: integer2("assigned_to_id").notNull(),
      assignedById: integer2("assigned_by_id").references(() => users.id).notNull(),
      assignedAt: timestamp2("assigned_at").defaultNow(),
      notes: text2("notes")
    });
    inventoryTransactions = pgTable2("inventory_transactions", {
      id: serial2("id").primaryKey(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      quantity: integer2("quantity").notNull(),
      type: inventoryTransactionTypeEnum("type").notNull(),
      referenceType: text2("reference_type"),
      // 'sale', 'purchase', 'adjustment', 'production', etc.
      referenceId: integer2("reference_id"),
      // ID of the sale, purchase, production order etc.
      notes: text2("notes"),
      createdAt: timestamp2("created_at").defaultNow(),
      createdBy: integer2("created_by").references(() => users.id),
      unitCost: numeric2("unit_cost"),
      // Unit cost at time of transaction
      location: text2("location"),
      // Warehouse or location identifier
      batchId: text2("batch_id"),
      // For batch tracking
      expiryDate: date2("expiry_date"),
      // For perishable items
      serialNumber: text2("serial_number"),
      // For serialized inventory
      workCenterId: integer2("work_center_id"),
      // Reference to manufacturing work center
      qualityInspectionId: integer2("quality_inspection_id")
      // Reference to quality inspection
    });
    invoices = pgTable2("invoices", {
      id: serial2("id").primaryKey(),
      invoiceNumber: text2("invoice_number").notNull().unique(),
      accountId: integer2("account_id").references(() => accounts.id).notNull(),
      contactId: integer2("contact_id").references(() => contacts.id),
      issueDate: date2("issue_date").notNull(),
      dueDate: date2("due_date").notNull(),
      status: invoiceStatusEnum("status").default("Draft"),
      subtotal: numeric2("subtotal").notNull(),
      taxAmount: numeric2("tax_amount").notNull(),
      discountAmount: numeric2("discount_amount").default("0"),
      totalAmount: numeric2("total_amount").notNull(),
      notes: text2("notes"),
      terms: text2("terms"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      ownerId: integer2("owner_id").references(() => users.id),
      paymentMethod: paymentMethodEnum("payment_method"),
      paymentDate: date2("payment_date"),
      paymentReference: text2("payment_reference"),
      currency: text2("currency").default("USD")
    });
    invoiceItems = pgTable2("invoice_items", {
      id: serial2("id").primaryKey(),
      invoiceId: integer2("invoice_id").references(() => invoices.id).notNull(),
      productId: integer2("product_id").references(() => products.id),
      description: text2("description").notNull(),
      quantity: numeric2("quantity").notNull(),
      unitPrice: numeric2("unit_price").notNull(),
      taxRate: numeric2("tax_rate"),
      taxAmount: numeric2("tax_amount"),
      discountPercent: numeric2("discount_percent"),
      discountAmount: numeric2("discount_amount"),
      lineTotal: numeric2("line_total").notNull(),
      sortOrder: integer2("sort_order").default(0)
    });
    purchaseOrders = pgTable2("purchase_orders", {
      id: serial2("id").primaryKey(),
      poNumber: text2("po_number").notNull().unique(),
      supplierId: integer2("supplier_id").references(() => accounts.id).notNull(),
      status: purchaseOrderStatusEnum("status").default("Draft"),
      orderDate: date2("order_date").notNull(),
      expectedDeliveryDate: date2("expected_delivery_date"),
      deliveryDate: date2("delivery_date"),
      subtotal: numeric2("subtotal").notNull(),
      taxAmount: numeric2("tax_amount"),
      totalAmount: numeric2("total_amount").notNull(),
      notes: text2("notes"),
      shippingAddress: text2("shipping_address"),
      billingAddress: text2("billing_address"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      approvedBy: integer2("approved_by").references(() => users.id),
      approvalDate: date2("approval_date"),
      currency: text2("currency").default("USD")
    });
    purchaseOrderItems = pgTable2("purchase_order_items", {
      id: serial2("id").primaryKey(),
      purchaseOrderId: integer2("purchase_order_id").references(() => purchaseOrders.id).notNull(),
      productId: integer2("product_id").references(() => products.id),
      description: text2("description").notNull(),
      quantity: numeric2("quantity").notNull(),
      receivedQuantity: numeric2("received_quantity").default("0"),
      unitPrice: numeric2("unit_price").notNull(),
      taxAmount: numeric2("tax_amount"),
      lineTotal: numeric2("line_total").notNull(),
      expectedDeliveryDate: date2("expected_delivery_date"),
      notes: text2("notes"),
      sortOrder: integer2("sort_order").default(0)
    });
    insertUserSchema = createInsertSchema2(users).pick({
      username: true,
      password: true,
      firstName: true,
      lastName: true,
      email: true,
      role: true,
      avatar: true
    });
    insertContactSchema = createInsertSchema2(contacts).omit({
      id: true,
      createdAt: true
    });
    insertAccountSchema = createInsertSchema2(accounts).omit({
      id: true,
      createdAt: true
    });
    insertLeadSchema = createInsertSchema2(leads).omit({
      id: true,
      createdAt: true,
      isConverted: true,
      convertedToContactId: true,
      convertedToAccountId: true,
      convertedToOpportunityId: true
    });
    insertOpportunitySchema = createInsertSchema2(opportunities).omit({
      id: true,
      createdAt: true,
      isClosed: true,
      isWon: true
    });
    insertTaskSchema = createInsertSchema2(tasks).omit({
      id: true,
      createdAt: true
    }).extend({
      reminderDate: z.string().nullable().optional()
    });
    insertEventSchema = createInsertSchema2(events).omit({
      id: true,
      createdAt: true
    }).extend({
      startDate: z.string().or(z.date()),
      endDate: z.string().or(z.date())
    });
    insertActivitySchema = createInsertSchema2(activities).omit({
      id: true,
      createdAt: true
    });
    insertSubscriptionPackageSchema = createInsertSchema2(subscriptionPackages).omit({
      id: true,
      createdAt: true
    }).extend({
      // Ensure price is always a string
      price: z.string()
    });
    insertUserSubscriptionSchema = createInsertSchema2(userSubscriptions).omit({
      id: true,
      createdAt: true
    }).extend({
      startDate: z.string().or(z.date())
    });
    insertSocialIntegrationSchema = createInsertSchema2(socialIntegrations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSocialMessageSchema = createInsertSchema2(socialMessages).omit({
      id: true,
      createdAt: true
    });
    insertLeadSourceSchema = createInsertSchema2(leadSources).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSocialCampaignSchema = createInsertSchema2(socialCampaigns).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWorkflowSchema = createInsertSchema2(workflows).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertApiKeySchema = createInsertSchema2(apiKeys).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      usageCount: true,
      lastUsed: true
    });
    insertCommunicationSchema = createInsertSchema2(communications).omit({
      id: true,
      createdAt: true
    }).extend({
      sentAt: z.string().or(z.date()),
      receivedAt: z.string().or(z.date()).nullable().optional()
    });
    insertProposalTemplateSchema = createInsertSchema2(proposalTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertProposalSchema = createInsertSchema2(proposals).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      sentAt: true,
      acceptedAt: true,
      rejectedAt: true
    }).extend({
      expiresAt: z.string().or(z.date()).optional().nullable()
    });
    insertProposalElementSchema = createInsertSchema2(proposalElements).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertProposalCollaboratorSchema = createInsertSchema2(proposalCollaborators).omit({
      id: true,
      addedAt: true,
      lastAccessed: true
    });
    insertProposalCommentSchema = createInsertSchema2(proposalComments).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      resolvedAt: true
    });
    insertProposalActivitySchema = createInsertSchema2(proposalActivities).omit({
      id: true,
      createdAt: true
    });
    insertProductCategorySchema = createInsertSchema2(productCategoriesTable).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertProductSchema = createInsertSchema2(products).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInventoryTransactionSchema = createInsertSchema2(inventoryTransactions).omit({
      id: true,
      createdAt: true
    });
    insertInvoiceSchema = createInsertSchema2(invoices).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      issueDate: z.string().or(z.date()),
      dueDate: z.string().or(z.date()),
      paymentDate: z.string().or(z.date()).nullable().optional()
    });
    insertInvoiceItemSchema = createInsertSchema2(invoiceItems).omit({
      id: true
    });
    insertPurchaseOrderSchema = createInsertSchema2(purchaseOrders).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      orderDate: z.string().or(z.date()),
      expectedDeliveryDate: z.string().or(z.date()).nullable().optional(),
      deliveryDate: z.string().or(z.date()).nullable().optional(),
      approvalDate: z.string().or(z.date()).nullable().optional()
    });
    insertPurchaseOrderItemSchema = createInsertSchema2(purchaseOrderItems).omit({
      id: true
    }).extend({
      expectedDeliveryDate: z.string().or(z.date()).nullable().optional()
    });
    warehouses = pgTable2("warehouses", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      code: text2("code").notNull().unique(),
      description: text2("description"),
      address: text2("address"),
      city: text2("city"),
      state: text2("state"),
      zip: text2("zip"),
      country: text2("country"),
      contactPerson: text2("contact_person"),
      contactPhone: text2("contact_phone"),
      contactEmail: text2("contact_email"),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      ownerId: integer2("owner_id").references(() => users.id),
      parentWarehouseId: integer2("parent_warehouse_id").references(() => warehouses.id),
      capacity: numeric2("capacity"),
      // in cubic meters
      utilizationRate: numeric2("utilization_rate"),
      // percentage of capacity used
      isManufacturing: boolean2("is_manufacturing").default(false)
      // Whether manufacturing happens here
    });
    warehouseZones = pgTable2("warehouse_zones", {
      id: serial2("id").primaryKey(),
      warehouseId: integer2("warehouse_id").references(() => warehouses.id).notNull(),
      name: text2("name").notNull(),
      code: text2("code").notNull(),
      description: text2("description"),
      zoneType: text2("zone_type").notNull(),
      // 'storage', 'receiving', 'shipping', 'production', 'quality', etc.
      capacity: numeric2("capacity"),
      // in cubic meters
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    workCenters = pgTable2("work_centers", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      code: text2("code").notNull().unique(),
      description: text2("description"),
      warehouseId: integer2("warehouse_id").references(() => warehouses.id),
      status: workCenterStatusEnum("status").default("Active"),
      hourlyRate: numeric2("hourly_rate"),
      // Cost per hour for the work center
      capacity: numeric2("capacity"),
      // Units per hour or appropriate measure
      setupTime: numeric2("setup_time"),
      // Average setup time in minutes
      operatingHours: jsonb("operating_hours"),
      // JSON with operating schedule
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      maintenanceSchedule: jsonb("maintenance_schedule"),
      // Maintenance schedule info
      equipmentList: text2("equipment_list").array(),
      // List of equipment in this work center
      departmentId: integer2("department_id"),
      // Optional department reference
      industryType: text2("industry_type")
      // 'pharmaceutical', 'textile', 'cement', etc.
    });
    billOfMaterials = pgTable2("bill_of_materials", {
      id: serial2("id").primaryKey(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      // Finished good
      name: text2("name").notNull(),
      version: text2("version").notNull(),
      isActive: boolean2("is_active").default(true),
      description: text2("description"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      approvedBy: integer2("approved_by").references(() => users.id),
      approvalDate: date2("approval_date"),
      manufacturingType: manufacturingTypeEnum("manufacturing_type").default("Discrete"),
      isDefault: boolean2("is_default").default(false),
      // Whether this is the default BOM for the product
      totalCost: numeric2("total_cost"),
      // Calculated total cost of all components
      notes: text2("notes"),
      revisionNotes: text2("revision_notes"),
      // Notes about version changes
      yield: numeric2("yield").default("100")
      // Expected yield percentage
    });
    bomItems = pgTable2("bom_items", {
      id: serial2("id").primaryKey(),
      bomId: integer2("bom_id").references(() => billOfMaterials.id).notNull(),
      componentId: integer2("component_id").references(() => products.id).notNull(),
      // Component product
      quantity: numeric2("quantity").notNull(),
      unitOfMeasure: unitOfMeasureEnum("unit_of_measure").notNull(),
      position: integer2("position").default(0),
      // Position in the manufacturing process
      isSubAssembly: boolean2("is_sub_assembly").default(false),
      // Whether this component is itself a sub-assembly
      scrapRate: numeric2("scrap_rate").default("0"),
      // Expected percentage of scrap
      notes: text2("notes"),
      isOptional: boolean2("is_optional").default(false),
      // Whether component is optional
      substitutes: jsonb("substitutes"),
      // Potential substitute components
      operation: text2("operation"),
      // Manufacturing operation for this component
      workCenterId: integer2("work_center_id").references(() => workCenters.id)
      // Work center where component is used
    });
    routings = pgTable2("routings", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      productId: integer2("product_id").references(() => products.id),
      // Product this routing is for
      bomId: integer2("bom_id").references(() => billOfMaterials.id),
      // Associated BOM
      version: text2("version").notNull(),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      approvedBy: integer2("approved_by").references(() => users.id),
      approvalDate: date2("approval_date"),
      totalStandardHours: numeric2("total_standard_hours"),
      // Total standard time for all operations
      isDefault: boolean2("is_default").default(false)
      // Default routing for the product
    });
    routingOperations = pgTable2("routing_operations", {
      id: serial2("id").primaryKey(),
      routingId: integer2("routing_id").references(() => routings.id).notNull(),
      sequence: integer2("sequence").notNull(),
      // Order in the routing
      name: text2("name").notNull(),
      description: text2("description"),
      workCenterId: integer2("work_center_id").references(() => workCenters.id).notNull(),
      setupTime: numeric2("setup_time"),
      // Setup time in minutes
      runTime: numeric2("run_time"),
      // Run time per unit in minutes
      queueTime: numeric2("queue_time"),
      // Queue time in minutes
      waitTime: numeric2("wait_time"),
      // Wait time in minutes
      instructions: text2("instructions"),
      // Detailed work instructions
      qualityCheckRequired: boolean2("quality_check_required").default(false),
      inputMaterials: jsonb("input_materials"),
      // Materials needed at this operation
      outputProducts: jsonb("output_products")
      // Products/by-products produced at this operation
    });
    productionOrders = pgTable2("production_orders", {
      id: serial2("id").primaryKey(),
      orderNumber: text2("order_number").notNull().unique(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      bomId: integer2("bom_id").references(() => billOfMaterials.id),
      routingId: integer2("routing_id").references(() => routings.id),
      quantity: numeric2("quantity").notNull(),
      unitOfMeasure: unitOfMeasureEnum("unit_of_measure").notNull(),
      status: productionOrderStatusEnum("status").default("Draft"),
      priority: productionPriorityEnum("priority").default("Medium"),
      plannedStartDate: timestamp2("planned_start_date"),
      plannedEndDate: timestamp2("planned_end_date"),
      actualStartDate: timestamp2("actual_start_date"),
      actualEndDate: timestamp2("actual_end_date"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      warehouseId: integer2("warehouse_id").references(() => warehouses.id),
      notes: text2("notes"),
      completedQuantity: numeric2("completed_quantity").default("0"),
      rejectedQuantity: numeric2("rejected_quantity").default("0"),
      salesOrderId: integer2("sales_order_id"),
      // Optional reference to sales order
      batchNumber: text2("batch_number"),
      // Batch/lot number for traceability
      industryType: text2("industry_type")
      // 'pharmaceutical', 'textile', 'cement', etc.
    });
    productionOrderOperations = pgTable2("production_order_operations", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      routingOperationId: integer2("routing_operation_id").references(() => routingOperations.id),
      sequence: integer2("sequence").notNull(),
      workCenterId: integer2("work_center_id").references(() => workCenters.id).notNull(),
      status: text2("status").default("Not Started"),
      plannedStartDate: timestamp2("planned_start_date"),
      plannedEndDate: timestamp2("planned_end_date"),
      actualStartDate: timestamp2("actual_start_date"),
      actualEndDate: timestamp2("actual_end_date"),
      setupTime: numeric2("setup_time"),
      // Actual setup time
      runTime: numeric2("run_time"),
      // Actual run time
      completedQuantity: numeric2("completed_quantity").default("0"),
      rejectedQuantity: numeric2("rejected_quantity").default("0"),
      operatorNotes: text2("operator_notes"),
      assignedTo: integer2("assigned_to").references(() => users.id)
    });
    materialConsumptions = pgTable2("material_consumptions", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      operationId: integer2("operation_id").references(() => productionOrderOperations.id),
      quantity: numeric2("quantity").notNull(),
      unitOfMeasure: unitOfMeasureEnum("unit_of_measure").notNull(),
      transactionDate: timestamp2("transaction_date").defaultNow(),
      warehouseId: integer2("warehouse_id").references(() => warehouses.id),
      batchNumber: text2("batch_number"),
      createdBy: integer2("created_by").references(() => users.id),
      notes: text2("notes"),
      inventoryTransactionId: integer2("inventory_transaction_id").references(() => inventoryTransactions.id),
      isBackflushed: boolean2("is_backflushed").default(false)
      // Whether materials were automatically consumed
    });
    qualityInspections = pgTable2("quality_inspections", {
      id: serial2("id").primaryKey(),
      referenceType: text2("reference_type").notNull(),
      // 'production_order', 'purchase_order', 'inventory'
      referenceId: integer2("reference_id").notNull(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      inspectionDate: timestamp2("inspection_date").defaultNow(),
      inspectedBy: integer2("inspected_by").references(() => users.id),
      result: qualityInspectionResultEnum("result").notNull(),
      quantity: numeric2("quantity").notNull(),
      quantityPassed: numeric2("quantity_passed"),
      quantityFailed: numeric2("quantity_failed"),
      notes: text2("notes"),
      batchNumber: text2("batch_number"),
      checklistData: jsonb("checklist_data"),
      // Checklist data in JSON format
      attachments: text2("attachments").array(),
      // Attachments like images, documents
      warehouseId: integer2("warehouse_id").references(() => warehouses.id),
      operationId: integer2("operation_id").references(() => productionOrderOperations.id)
    });
    qualityParameters = pgTable2("quality_parameters", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      description: text2("description"),
      productId: integer2("product_id").references(() => products.id),
      // For product-specific parameters
      parameterType: text2("parameter_type").notNull(),
      // 'numeric', 'boolean', 'text', etc.
      uom: text2("uom"),
      // Unit of measure
      minimumValue: text2("minimum_value"),
      // Minimum acceptable value (for numeric)
      maximumValue: text2("maximum_value"),
      // Maximum acceptable value (for numeric)
      targetValue: text2("target_value"),
      // Target value
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      createdBy: integer2("created_by").references(() => users.id),
      industryType: text2("industry_type")
      // 'pharmaceutical', 'textile', 'cement', etc.
    });
    qualityInspectionResults = pgTable2("quality_inspection_results", {
      id: serial2("id").primaryKey(),
      inspectionId: integer2("inspection_id").references(() => qualityInspections.id).notNull(),
      parameterId: integer2("parameter_id").references(() => qualityParameters.id).notNull(),
      value: text2("value").notNull(),
      // Actual measured value
      isPassed: boolean2("is_passed").notNull(),
      // Whether this parameter passed
      notes: text2("notes"),
      createdAt: timestamp2("created_at").defaultNow(),
      createdBy: integer2("created_by").references(() => users.id)
    });
    equipment = pgTable2("equipment", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      code: text2("code").notNull().unique(),
      workCenterId: integer2("work_center_id").references(() => workCenters.id),
      status: equipmentStatusEnum("status").default("Operational"),
      manufacturer: text2("manufacturer"),
      model: text2("model"),
      serialNumber: text2("serial_number"),
      purchaseDate: date2("purchase_date"),
      warrantyExpiryDate: date2("warranty_expiry_date"),
      lastMaintenanceDate: date2("last_maintenance_date"),
      nextMaintenanceDate: date2("next_maintenance_date"),
      maintenanceFrequency: integer2("maintenance_frequency"),
      // In days
      specifications: jsonb("specifications"),
      // Technical specifications
      operatingProcedure: text2("operating_procedure"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      location: text2("location"),
      capacityPerHour: numeric2("capacity_per_hour"),
      // Production capacity
      powerConsumption: numeric2("power_consumption"),
      // Power usage
      industryType: text2("industry_type")
      // 'pharmaceutical', 'textile', 'cement', etc.
    });
    maintenanceRequests = pgTable2("maintenance_requests", {
      id: serial2("id").primaryKey(),
      equipmentId: integer2("equipment_id").references(() => equipment.id).notNull(),
      requestType: maintenanceTypeEnum("request_type").default("Corrective"),
      status: maintenanceStatusEnum("status").default("Scheduled"),
      priority: productionPriorityEnum("priority").default("Medium"),
      description: text2("description").notNull(),
      requestedBy: integer2("requested_by").references(() => users.id).notNull(),
      assignedTo: integer2("assigned_to").references(() => users.id),
      requestDate: timestamp2("request_date").defaultNow(),
      scheduledDate: timestamp2("scheduled_date"),
      completionDate: timestamp2("completion_date"),
      notes: text2("notes"),
      resolutionDetails: text2("resolution_details"),
      partsUsed: jsonb("parts_used"),
      // Parts used in the maintenance
      downtime: numeric2("downtime"),
      // Downtime in hours
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at")
    });
    manufacturingShifts = pgTable2("manufacturing_shifts", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      startTime: text2("start_time").notNull(),
      // Start time in 24-hour format (HH:MM)
      endTime: text2("end_time").notNull(),
      // End time in 24-hour format (HH:MM)
      workCenterId: integer2("work_center_id").references(() => workCenters.id),
      warehouseId: integer2("warehouse_id").references(() => warehouses.id),
      daysOfWeek: text2("days_of_week").array(),
      // Days when shift is active
      isActive: boolean2("is_active").default(true),
      supervisorId: integer2("supervisor_id").references(() => users.id),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      breakTimes: jsonb("break_times"),
      // Break schedule
      capacityFactor: numeric2("capacity_factor").default("1")
      // Capacity multiplier for this shift
    });
    shiftAssignments = pgTable2("shift_assignments", {
      id: serial2("id").primaryKey(),
      shiftId: integer2("shift_id").references(() => manufacturingShifts.id).notNull(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      workCenterId: integer2("work_center_id").references(() => workCenters.id),
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date"),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id)
    });
    pharmaManufacturing = pgTable2("pharma_manufacturing", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      regulatoryBatchNumber: text2("regulatory_batch_number").notNull(),
      expiryDate: date2("expiry_date").notNull(),
      manufacturingDate: date2("manufacturing_date").notNull(),
      sterility: boolean2("sterility").default(false),
      containsControlledSubstances: boolean2("contains_controlled_substances").default(false),
      storageConditions: text2("storage_conditions"),
      regulatoryApprovals: jsonb("regulatory_approvals"),
      // FDA, EMA, etc. approvals
      stabilityTestingRequired: boolean2("stability_testing_required").default(false),
      analyticalTesting: jsonb("analytical_testing"),
      // Testing data
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id)
    });
    textileManufacturing = pgTable2("textile_manufacturing", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      fiberType: text2("fiber_type").notNull(),
      // Cotton, polyester, etc.
      dyeingMethod: text2("dyeing_method"),
      colorCode: text2("color_code"),
      patternCode: text2("pattern_code"),
      gsm: numeric2("gsm"),
      // Grams per square meter
      finishingProcess: text2("finishing_process"),
      textureDetails: text2("texture_details"),
      yarnCount: text2("yarn_count"),
      fabricWidth: numeric2("fabric_width"),
      shrinkagePercentage: numeric2("shrinkage_percentage"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id)
    });
    cementManufacturing = pgTable2("cement_manufacturing", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      cementType: text2("cement_type").notNull(),
      // Portland, Masonry, etc.
      strengthClass: text2("strength_class"),
      // 32.5, 42.5, 52.5 MPa
      composition: jsonb("composition"),
      // Detailed composition percentages
      settingTime: numeric2("setting_time"),
      // In minutes
      clinkerFactor: numeric2("clinker_factor"),
      // Amount of clinker
      additives: jsonb("additives"),
      // Additives used
      packagingType: text2("packaging_type"),
      // Bulk, bag, etc.
      qualityStandard: text2("quality_standard"),
      // ASTM, EN, etc.
      moisture: numeric2("moisture"),
      // Moisture percentage
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id)
    });
    manufacturingCosts = pgTable2("manufacturing_costs", {
      id: serial2("id").primaryKey(),
      productionOrderId: integer2("production_order_id").references(() => productionOrders.id).notNull(),
      materialCost: numeric2("material_cost").default("0"),
      laborCost: numeric2("labor_cost").default("0"),
      overheadCost: numeric2("overhead_cost").default("0"),
      setupCost: numeric2("setup_cost").default("0"),
      energyCost: numeric2("energy_cost").default("0"),
      additionalCosts: jsonb("additional_costs"),
      // Other specific costs
      totalCost: numeric2("total_cost").default("0"),
      costPerUnit: numeric2("cost_per_unit").default("0"),
      currency: text2("currency").default("USD"),
      costingDate: timestamp2("costing_date").defaultNow(),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      isActual: boolean2("is_actual").default(false)
      // Whether costs are actual or estimated
    });
    manufacturingFormulas = pgTable2("manufacturing_formulas", {
      id: serial2("id").primaryKey(),
      name: text2("name").notNull(),
      productId: integer2("product_id").references(() => products.id).notNull(),
      version: text2("version").notNull(),
      isActive: boolean2("is_active").default(true),
      description: text2("description"),
      batchSize: numeric2("batch_size").notNull(),
      unitOfMeasure: unitOfMeasureEnum("unit_of_measure").notNull(),
      instructions: text2("instructions"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at"),
      createdBy: integer2("created_by").references(() => users.id),
      approvedBy: integer2("approved_by").references(() => users.id),
      approvalDate: date2("approval_date"),
      industryType: text2("industry_type"),
      // 'pharmaceutical', 'chemical', etc.
      yield: numeric2("yield").default("100"),
      // Expected yield percentage
      isDefault: boolean2("is_default").default(false)
      // Default formula for the product
    });
    formulaIngredients = pgTable2("formula_ingredients", {
      id: serial2("id").primaryKey(),
      formulaId: integer2("formula_id").references(() => manufacturingFormulas.id).notNull(),
      materialId: integer2("material_id").references(() => products.id).notNull(),
      quantity: numeric2("quantity").notNull(),
      unitOfMeasure: unitOfMeasureEnum("unit_of_measure").notNull(),
      sequence: integer2("sequence").default(0),
      notes: text2("notes"),
      isOptional: boolean2("is_optional").default(false),
      substitutes: jsonb("substitutes"),
      // Possible substitutes
      function: text2("function"),
      // Function of this ingredient
      criticalMaterial: boolean2("critical_material").default(false)
      // Whether material is critical
    });
    insertWarehouseSchema = createInsertSchema2(warehouses).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWarehouseZoneSchema = createInsertSchema2(warehouseZones).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWorkCenterSchema = createInsertSchema2(workCenters).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBillOfMaterialsSchema = createInsertSchema2(billOfMaterials).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      approvalDate: true
    }).extend({
      approvalDate: z.string().or(z.date()).nullable().optional()
    });
    insertBomItemSchema = createInsertSchema2(bomItems).omit({
      id: true
    });
    insertRoutingSchema = createInsertSchema2(routings).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      approvalDate: true
    }).extend({
      approvalDate: z.string().or(z.date()).nullable().optional()
    });
    insertRoutingOperationSchema = createInsertSchema2(routingOperations).omit({
      id: true
    });
    insertProductionOrderSchema = createInsertSchema2(productionOrders).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      actualStartDate: true,
      actualEndDate: true,
      plannedStartDate: true,
      plannedEndDate: true
    }).extend({
      plannedStartDate: z.string().or(z.date()).nullable().optional(),
      plannedEndDate: z.string().or(z.date()).nullable().optional(),
      actualStartDate: z.string().or(z.date()).nullable().optional(),
      actualEndDate: z.string().or(z.date()).nullable().optional()
    });
    insertProductionOrderOperationSchema = createInsertSchema2(productionOrderOperations).omit({
      id: true,
      actualStartDate: true,
      actualEndDate: true,
      plannedStartDate: true,
      plannedEndDate: true
    }).extend({
      plannedStartDate: z.string().or(z.date()).nullable().optional(),
      plannedEndDate: z.string().or(z.date()).nullable().optional(),
      actualStartDate: z.string().or(z.date()).nullable().optional(),
      actualEndDate: z.string().or(z.date()).nullable().optional()
    });
    insertMaterialConsumptionSchema = createInsertSchema2(materialConsumptions).omit({
      id: true,
      transactionDate: true
    }).extend({
      transactionDate: z.string().or(z.date()).nullable().optional()
    });
    insertQualityInspectionSchema = createInsertSchema2(qualityInspections).omit({
      id: true,
      inspectionDate: true
    }).extend({
      inspectionDate: z.string().or(z.date()).nullable().optional()
    });
    insertQualityParameterSchema = createInsertSchema2(qualityParameters).omit({
      id: true,
      createdAt: true
    });
    insertQualityInspectionResultSchema = createInsertSchema2(qualityInspectionResults).omit({
      id: true,
      createdAt: true
    });
    insertEquipmentSchema = createInsertSchema2(equipment).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      purchaseDate: true,
      warrantyExpiryDate: true,
      lastMaintenanceDate: true,
      nextMaintenanceDate: true
    }).extend({
      purchaseDate: z.string().or(z.date()).nullable().optional(),
      warrantyExpiryDate: z.string().or(z.date()).nullable().optional(),
      lastMaintenanceDate: z.string().or(z.date()).nullable().optional(),
      nextMaintenanceDate: z.string().or(z.date()).nullable().optional()
    });
    insertMaintenanceRequestSchema = createInsertSchema2(maintenanceRequests).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      requestDate: true,
      scheduledDate: true,
      completionDate: true
    }).extend({
      requestDate: z.string().or(z.date()).nullable().optional(),
      scheduledDate: z.string().or(z.date()).nullable().optional(),
      completionDate: z.string().or(z.date()).nullable().optional()
    });
    insertManufacturingShiftSchema = createInsertSchema2(manufacturingShifts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShiftAssignmentSchema = createInsertSchema2(shiftAssignments).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      startDate: z.string().or(z.date()),
      endDate: z.string().or(z.date()).nullable().optional()
    });
    insertModulePermissionSchema = createInsertSchema2(modulePermissions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRolePermissionSchema = createInsertSchema2(rolePermissions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUserPermissionSchema = createInsertSchema2(userPermissions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTeamSchema = createInsertSchema2(teams).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTeamMemberSchema = createInsertSchema2(teamMembers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAssignmentSchema = createInsertSchema2(assignments).omit({
      id: true,
      assignedAt: true
    });
    ticketPriorities = pgEnum2("ticket_priority", ["low", "medium", "high", "critical"]);
    ticketStatuses = pgEnum2("ticket_status", ["open", "in_progress", "waiting_on_customer", "waiting_on_third_party", "resolved", "closed"]);
    ticketTypes = pgEnum2("ticket_type", ["technical", "billing", "feature_request", "general_inquiry", "bug_report"]);
    supportTickets = pgTable2("support_tickets", {
      id: serial2("id").primaryKey(),
      subject: text2("subject").notNull(),
      description: text2("description").notNull(),
      customerId: integer2("customer_id").references(() => users.id),
      assignedTo: integer2("assigned_to").references(() => users.id),
      status: ticketStatuses("status").default("open").notNull(),
      priority: ticketPriorities("priority").default("medium").notNull(),
      type: ticketTypes("type").default("general_inquiry").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      resolvedAt: timestamp2("resolved_at"),
      dueDate: timestamp2("due_date"),
      isInternal: boolean2("is_internal").default(false)
    });
    ticketComments = pgTable2("ticket_comments", {
      id: serial2("id").primaryKey(),
      ticketId: integer2("ticket_id").references(() => supportTickets.id).notNull(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      comment: text2("comment").notNull(),
      isInternal: boolean2("is_internal").default(false),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    ticketAttachments = pgTable2("ticket_attachments", {
      id: serial2("id").primaryKey(),
      ticketId: integer2("ticket_id").references(() => supportTickets.id).notNull(),
      commentId: integer2("comment_id").references(() => ticketComments.id),
      fileName: text2("file_name").notNull(),
      fileUrl: text2("file_url").notNull(),
      fileSize: integer2("file_size").notNull(),
      contentType: text2("content_type").notNull(),
      uploadedBy: integer2("uploaded_by").references(() => users.id).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    shopifyStores = pgTable2("shopify_stores", {
      id: serial2("id").primaryKey(),
      userId: integer2("user_id").references(() => users.id).notNull(),
      storeName: text2("store_name").notNull(),
      domain: text2("domain").notNull(),
      accessToken: text2("access_token"),
      apiKey: text2("api_key"),
      apiSecret: text2("api_secret"),
      isActive: boolean2("is_active").default(true),
      lastSyncedAt: timestamp2("last_synced_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    shopifyProductCategoryEnum = pgEnum2("shopify_product_category", [
      "clothing",
      "electronics",
      "home_goods",
      "food",
      "beauty",
      "books",
      "sports",
      "other"
    ]);
    shopifyProducts = pgTable2("shopify_products", {
      id: serial2("id").primaryKey(),
      storeId: integer2("store_id").references(() => shopifyStores.id).notNull(),
      productId: text2("product_id").notNull(),
      title: text2("title").notNull(),
      description: text2("description"),
      price: numeric2("price", { precision: 10, scale: 2 }),
      compareAtPrice: numeric2("compare_at_price", { precision: 10, scale: 2 }),
      inventoryQuantity: integer2("inventory_quantity"),
      sku: text2("sku"),
      productType: text2("product_type"),
      category: shopifyProductCategoryEnum("category").default("other"),
      vendor: text2("vendor"),
      imageUrl: text2("image_url"),
      productUrl: text2("product_url"),
      tags: text2("tags"),
      isActive: boolean2("is_active").default(true),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    shopifyCustomers = pgTable2("shopify_customers", {
      id: serial2("id").primaryKey(),
      storeId: integer2("store_id").references(() => shopifyStores.id).notNull(),
      customerId: text2("customer_id").notNull(),
      email: text2("email"),
      firstName: text2("first_name"),
      lastName: text2("last_name"),
      phone: text2("phone"),
      ordersCount: integer2("orders_count").default(0),
      totalSpent: numeric2("total_spent", { precision: 10, scale: 2 }).default("0"),
      averoxContactId: integer2("averox_contact_id").references(() => contacts.id),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    orderStatuses = pgEnum2("order_status", [
      "pending",
      "processing",
      "fulfilled",
      "shipped",
      "delivered",
      "cancelled",
      "refunded"
    ]);
    shopifyOrders = pgTable2("shopify_orders", {
      id: serial2("id").primaryKey(),
      storeId: integer2("store_id").references(() => shopifyStores.id).notNull(),
      orderId: text2("order_id").notNull(),
      customerId: integer2("customer_id").references(() => shopifyCustomers.id),
      orderNumber: text2("order_number").notNull(),
      totalPrice: numeric2("total_price", { precision: 10, scale: 2 }).notNull(),
      subtotalPrice: numeric2("subtotal_price", { precision: 10, scale: 2 }),
      totalTax: numeric2("total_tax", { precision: 10, scale: 2 }),
      totalShipping: numeric2("total_shipping", { precision: 10, scale: 2 }),
      totalDiscounts: numeric2("total_discounts", { precision: 10, scale: 2 }),
      currency: text2("currency").default("USD"),
      status: orderStatuses("status").default("pending").notNull(),
      financialStatus: text2("financial_status"),
      fulfillmentStatus: text2("fulfillment_status"),
      paymentMethod: text2("payment_method"),
      shippingMethod: text2("shipping_method"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    insertSupportTicketSchema = createInsertSchema2(supportTickets).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTicketCommentSchema = createInsertSchema2(ticketComments).omit({
      id: true,
      createdAt: true
    });
    insertTicketAttachmentSchema = createInsertSchema2(ticketAttachments).omit({
      id: true,
      createdAt: true
    });
    insertShopifyStoreSchema = createInsertSchema2(shopifyStores).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyProductSchema = createInsertSchema2(shopifyProducts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyCustomerSchema = createInsertSchema2(shopifyCustomers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyOrderSchema = createInsertSchema2(shopifyOrders).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// server/utils/cryptosphere.ts
var cryptosphere_exports = {};
__export(cryptosphere_exports, {
  CryptoSphere: () => CryptoSphere,
  cryptoSphere: () => cryptoSphere
});
import { createRequire } from "module";
var require2, AveroxCryptoSphere, CryptoSphere, cryptoSphere;
var init_cryptosphere = __esm({
  "server/utils/cryptosphere.ts"() {
    "use strict";
    require2 = createRequire(import.meta.url);
    try {
      AveroxCryptoSphere = require2("./averox-cryptosphere.js").AveroxCryptoSphere;
      console.log("[CryptoSphere] Successfully imported Averox CryptoSphere SDK");
    } catch (error) {
      console.warn("[CryptoSphere] Could not load actual SDK, using fallback implementation");
      const crypto = require2("crypto");
      class FallbackCryptoSphere {
        config;
        algorithm;
        keyId;
        constructor(config2 = {}) {
          this.config = config2 || {};
          this.algorithm = "aes-256-gcm";
          this.keyId = config2.keyId || "AES-FALLBACK";
          console.log("[CryptoSphere] Fallback implementation initialized", {
            keyId: this.keyId,
            algorithm: this.algorithm
          });
        }
        async encrypt({ data, additionalData }) {
          const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || "averox-encryption-key", "salt", 32);
          const iv = crypto.randomBytes(16);
          const cipher = crypto.createCipheriv(this.algorithm, key, iv);
          if (additionalData) {
            cipher.setAAD(Buffer.from(JSON.stringify(additionalData)));
          }
          let strData = typeof data === "string" ? data : JSON.stringify(data);
          let encrypted = cipher.update(strData, "utf8", "hex");
          encrypted += cipher.final("hex");
          const authTag = cipher.getAuthTag().toString("hex");
          return {
            encrypted: encrypted + ":" + authTag,
            // Store auth tag with encrypted data
            iv: iv.toString("hex"),
            keyId: this.keyId,
            algorithm: this.algorithm,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            additionalData
          };
        }
        async decrypt({ encrypted, iv }) {
          try {
            const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || "averox-encryption-key", "salt", 32);
            const [encryptedData, authTag] = encrypted.split(":");
            const decipher = crypto.createDecipheriv(
              this.algorithm,
              key,
              Buffer.from(iv, "hex")
            );
            if (authTag) {
              decipher.setAuthTag(Buffer.from(authTag, "hex"));
            }
            let decrypted = decipher.update(encryptedData, "hex", "utf8");
            decrypted += decipher.final("utf8");
            try {
              return {
                decrypted: JSON.parse(decrypted),
                keyId: this.keyId,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              };
            } catch (e) {
              return {
                decrypted,
                keyId: this.keyId,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              };
            }
          } catch (error2) {
            console.error("[CryptoSphere] Fallback decryption error:", error2);
            throw new Error(`Failed to decrypt data: ${error2.message}`);
          }
        }
      }
      AveroxCryptoSphere = FallbackCryptoSphere;
    }
    CryptoSphere = class {
      sdk;
      constructor(config2 = {}) {
        this.sdk = new AveroxCryptoSphere(config2);
      }
      /**
       * Encrypt data using the SDK
       */
      async encrypt(params) {
        try {
          return await this.sdk.encrypt(params);
        } catch (error) {
          console.error("Encryption error:", error);
          throw new Error(`Failed to encrypt data: ${error.message}`);
        }
      }
      /**
       * Decrypt data using the SDK
       */
      async decrypt(params) {
        try {
          return await this.sdk.decrypt(params);
        } catch (error) {
          console.error("Decryption error:", error);
          throw new Error(`Failed to decrypt data: ${error.message}`);
        }
      }
    };
    cryptoSphere = new CryptoSphere({
      apiKey: process.env.CRYPTOSPHERE_API_KEY,
      keyId: process.env.CRYPTOSPHERE_KEY_ID || "AES-419ad38b",
      debug: process.env.NODE_ENV !== "production",
      telemetry: process.env.ENABLE_TELEMETRY === "true"
    });
  }
});

// server/utils/encryption.ts
async function encrypt(data, additionalData) {
  try {
    const startTime = Date.now();
    const metadata = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      application: "averox-business-ai",
      purpose: "data-protection",
      ...additionalData
    };
    const result = await cryptoSphere.encrypt({
      data,
      additionalData: metadata
    });
    const duration = Date.now() - startTime;
    if (duration > 100) {
      console.warn(`[Encryption] Slow encryption operation: ${duration}ms`);
    }
    return {
      encrypted: result.encrypted,
      iv: result.iv,
      keyId: result.keyId
    };
  } catch (error) {
    console.error("Encryption error:", error);
    throw new Error(`Failed to encrypt data: ${error.message}`);
  }
}
async function decrypt(encrypted, iv, keyId) {
  try {
    const startTime = Date.now();
    const result = await cryptoSphere.decrypt({
      encrypted,
      iv,
      keyId
    });
    const duration = Date.now() - startTime;
    if (duration > 100) {
      console.warn(`[Encryption] Slow decryption operation: ${duration}ms`);
    }
    return result.decrypted;
  } catch (error) {
    console.error("Decryption error:", error);
    throw new Error(`Failed to decrypt data: ${error.message}`);
  }
}
async function decryptConnectionString(encrypted, iv) {
  try {
    const keyId = process.env.DB_ENCRYPTION_KEY_ID || "DB-CONNECTION-KEY";
    const result = await cryptoSphere.decrypt({
      encrypted,
      iv,
      keyId
    });
    return result.decrypted;
  } catch (error) {
    console.error("Database connection decryption error:", error);
    throw new Error(`Failed to decrypt database connection: ${error.message}`);
  }
}
var init_encryption = __esm({
  "server/utils/encryption.ts"() {
    "use strict";
    init_cryptosphere();
  }
});

// server/db.ts
import { drizzle } from "drizzle-orm/neon-serverless";
import * as dotenv from "dotenv";
import * as path from "path";
import { Pool } from "pg";
async function getConnectionString() {
  const connectionString = process.env.DATABASE_URL || "";
  if (USE_ENCRYPTED_CONNECTION && DATABASE_URL_IV) {
    try {
      console.log("[Database] Using encrypted database connection");
      const startTime = Date.now();
      const decryptedString = await decryptConnectionString(connectionString, DATABASE_URL_IV);
      const duration = Date.now() - startTime;
      console.log(`[Database] Connection string decryption completed in ${duration}ms`);
      return decryptedString;
    } catch (error) {
      console.error("Failed to decrypt database connection string:", error);
      throw new Error("Database connection configuration is invalid");
    }
  }
  if (process.env.NODE_ENV === "production") {
    console.warn("[Database] Using unencrypted database connection in production environment");
  } else {
    console.log("[Database] Using unencrypted database connection in development environment");
  }
  return connectionString;
}
async function initDatabase() {
  try {
    console.log("[Database] Initializing secure database connection...");
    const startTime = Date.now();
    const connectionString = await getConnectionString();
    pool = new Pool({
      connectionString,
      ssl: process.env.NODE_ENV === "production"
      // Enable SSL in production
    });
    db = drizzle({ client: pool, schema: schema_exports });
    const duration = Date.now() - startTime;
    console.log(`[Database] Secure database connection initialized in ${duration}ms`);
    return { pool, db };
  } catch (error) {
    console.error("[Database] Failed to initialize secure database:", error);
    throw error;
  }
}
var USE_ENCRYPTED_CONNECTION, DATABASE_URL_IV, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    init_encryption();
    delete process.env.DATABASE_URL;
    dotenv.config({
      path: path.resolve(process.cwd(), ".env"),
      override: true
    });
    console.log("Forced reload DATABASE_URL:", process.env.DATABASE_URL);
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    USE_ENCRYPTED_CONNECTION = process.env.USE_ENCRYPTED_CONNECTION === "true";
    DATABASE_URL_IV = process.env.DATABASE_URL_IV || "";
    console.log("\u{1F50D} Environment Debug:");
    console.log("NODE_ENV:", process.env.NODE_ENV);
    console.log("DB_HOST:", process.env.DB_HOST);
    console.log("DB_NAME:", process.env.DB_NAME);
    console.log("DB_USER:", process.env.DB_USER);
    console.log("DATABASE_URL:", process.env.DATABASE_URL);
    console.log("All DB vars:", Object.keys(process.env).filter((key) => key.includes("DB")));
    console.log("[Database] Setting up initial database connection...");
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: process.env.NODE_ENV === "production",
      // Enable SSL in production
      max: 10,
      // Maximum pool connections
      idleTimeoutMillis: 3e4,
      // Close idle connections after 30 seconds
      connectionTimeoutMillis: 1e4,
      // Connection timeout
      maxUses: 7500
      // Reuse connections up to 7500 times
    });
    pool.on("error", (err) => {
      console.error("[Database] Pool error:", err);
    });
    pool.on("connect", () => {
      console.log("[Database] New client connected");
    });
    db = drizzle({ client: pool, schema: schema_exports });
    if (USE_ENCRYPTED_CONNECTION) {
      console.log("[Database] Encrypted connection enabled, initializing secure connection...");
      initDatabase().catch((err) => {
        console.error("[Database] Failed to initialize secure database connection:", err);
      });
    }
  }
});

// server/communication-integration.ts
import { eq, and, desc } from "drizzle-orm";
function addCommunicationsToMemStorage(storage2) {
  storage2.communications = /* @__PURE__ */ new Map();
  storage2.communicationIdCounter = 0;
  storage2.getAllCommunications = async function() {
    return Array.from(this.communications.values()).sort((a, b) => {
      const dateA = a.receivedAt || a.sentAt;
      const dateB = b.receivedAt || b.sentAt;
      return dateB.getTime() - dateA.getTime();
    });
  };
  storage2.getContactCommunications = async function(contactId, contactType) {
    return Array.from(this.communications.values()).filter((comm) => comm.contactId === contactId && comm.contactType === contactType).sort((a, b) => {
      const dateA = a.receivedAt || a.sentAt;
      const dateB = b.receivedAt || b.sentAt;
      return dateB.getTime() - dateA.getTime();
    });
  };
  storage2.getRelatedCommunications = async function(relatedToType, relatedToId) {
    return Array.from(this.communications.values()).filter((comm) => comm.relatedToType === relatedToType && comm.relatedToId === relatedToId).sort((a, b) => {
      const dateA = a.receivedAt || a.sentAt;
      const dateB = b.receivedAt || b.sentAt;
      return dateB.getTime() - dateA.getTime();
    });
  };
  storage2.updateCommunicationStatus = async function(id, status) {
    const communication = this.communications.get(id);
    if (!communication) return null;
    const normalizedStatus = status.toLowerCase();
    const updatedCommunication = {
      ...communication,
      status: normalizedStatus
    };
    this.communications.set(id, updatedCommunication);
    return updatedCommunication;
  };
  storage2.createCommunication = async function(data) {
    const id = ++this.communicationIdCounter;
    let contactDetails = null;
    if (data.contactType === "lead") {
      const lead = this.leads.get(data.contactId);
      if (lead) {
        contactDetails = {
          id: lead.id,
          firstName: lead.firstName || "",
          lastName: lead.lastName || "",
          email: lead.email || void 0,
          phone: lead.phone || void 0,
          company: lead.company || void 0,
          avatarUrl: void 0,
          // We could add avatar URL to leads schema in the future
          type: "lead",
          socialProfiles: {
            // These would be populated from social integrations if available
          }
        };
      }
    } else {
      const contact = this.contacts.get(data.contactId);
      if (contact) {
        contactDetails = {
          id: contact.id,
          firstName: contact.firstName || "",
          lastName: contact.lastName || "",
          email: contact.email || void 0,
          phone: contact.phone || void 0,
          company: void 0,
          // This would come from the related account
          avatarUrl: void 0,
          type: "customer",
          socialProfiles: {
            // These would be populated from social integrations if available
          }
        };
      }
    }
    if (!contactDetails) {
      throw new Error(`Contact not found with ID ${data.contactId} and type ${data.contactType}`);
    }
    const communication = {
      id,
      contactId: data.contactId,
      contactType: data.contactType,
      channel: data.channel.toLowerCase(),
      // Ensure consistent lowercase storage for channel
      direction: data.direction.toLowerCase(),
      // Ensure consistent lowercase storage
      content: data.content,
      status: (data.status || "unread").toLowerCase(),
      // Ensure consistent lowercase storage
      sentAt: data.sentAt || /* @__PURE__ */ new Date(),
      receivedAt: data.receivedAt,
      attachments: data.attachments,
      contactDetails,
      // Add the relationship fields if provided
      relatedToType: data.relatedToType,
      relatedToId: data.relatedToId
    };
    this.communications.set(id, communication);
    return communication;
  };
  storage2.initializeCommunicationMockData = function() {
    if (this.communications.size === 0 && this.leads.size > 0 && this.contacts.size > 0) {
      const leadIds = Array.from(this.leads.keys());
      const contactIds = Array.from(this.contacts.keys());
      const channels = ["email", "whatsapp", "sms", "phone", "messenger", "twitter", "linkedin", "instagram"];
      const directions = ["inbound", "outbound"];
      const statuses = ["unread", "read", "replied", "archived"];
      if (leadIds.length > 0) {
        const leadId = leadIds[0];
        const lead = this.leads.get(leadId);
        if (lead) {
          this.createCommunication({
            contactId: leadId,
            contactType: "lead",
            channel: "email",
            direction: "inbound",
            content: "I'm interested in your services. Can you tell me more?",
            status: "unread",
            sentAt: new Date(Date.now() - 2 * 3600 * 1e3),
            // 2 hours ago
            receivedAt: new Date(Date.now() - 2 * 3600 * 1e3)
          });
          this.createCommunication({
            contactId: leadId,
            contactType: "lead",
            channel: "whatsapp",
            direction: "inbound",
            content: "Hello, following up on our conversation. When can we schedule a demo?",
            status: "read",
            sentAt: new Date(Date.now() - 24 * 3600 * 1e3),
            // 1 day ago
            receivedAt: new Date(Date.now() - 24 * 3600 * 1e3)
          });
          this.createCommunication({
            contactId: leadId,
            contactType: "lead",
            channel: "email",
            direction: "outbound",
            content: "Thank you for your interest. I've attached our product brochure for more information.",
            status: "replied",
            sentAt: new Date(Date.now() - 23 * 3600 * 1e3)
            // 23 hours ago
          });
        }
      }
      if (contactIds.length > 0) {
        const contactId = contactIds[0];
        const contact = this.contacts.get(contactId);
        if (contact) {
          this.createCommunication({
            contactId,
            contactType: "customer",
            channel: "phone",
            direction: "outbound",
            content: "Called to follow up on recent purchase and discuss satisfaction levels. Left voicemail.",
            status: "read",
            sentAt: new Date(Date.now() - 6 * 3600 * 1e3)
            // 6 hours ago
          });
          this.createCommunication({
            contactId,
            contactType: "customer",
            channel: "messenger",
            direction: "inbound",
            content: "I'm having trouble with the latest update. Can you help me troubleshoot?",
            status: "replied",
            sentAt: new Date(Date.now() - 8 * 3600 * 1e3),
            // 8 hours ago
            receivedAt: new Date(Date.now() - 8 * 3600 * 1e3)
          });
          this.createCommunication({
            contactId,
            contactType: "customer",
            channel: "messenger",
            direction: "outbound",
            content: "I'll be happy to help. Can you please describe the specific issue you're experiencing?",
            status: "read",
            sentAt: new Date(Date.now() - 7 * 3600 * 1e3)
            // 7 hours ago
          });
        }
      }
    }
  };
}
function addCommunicationsToDatabase(dbStorage) {
  dbStorage.getAllCommunications = async function() {
    try {
      const messages2 = await db.select({
        social_messages: socialMessages,
        social_integrations: socialIntegrations
      }).from(socialMessages).leftJoin(socialIntegrations, eq(socialMessages.integrationId, socialIntegrations.id)).where(eq(socialMessages.isDeleted, false)).orderBy(desc(socialMessages.createdAt));
      const result = [];
      for (const msg of messages2) {
        if (msg.social_messages.isDeleted) continue;
        let contactDetails = null;
        let contactType = "lead";
        if (msg.social_messages.leadId) {
          const [lead] = await db.select().from(leads).where(eq(leads.id, msg.social_messages.leadId));
          if (lead) {
            contactDetails = {
              id: lead.id,
              firstName: lead.firstName || "",
              lastName: lead.lastName || "",
              email: lead.email || void 0,
              phone: lead.phone || void 0,
              company: lead.company || void 0,
              type: "lead",
              socialProfiles: {}
            };
            contactType = "lead";
          }
        } else if (msg.social_messages.contactId) {
          const [contactRecord] = await db.select().from(contacts).where(eq(contacts.id, msg.social_messages.contactId));
          if (contactRecord) {
            contactDetails = {
              id: contactRecord.id,
              firstName: contactRecord.firstName || "",
              lastName: contactRecord.lastName || "",
              email: contactRecord.email || void 0,
              phone: contactRecord.phone || void 0,
              type: "customer",
              socialProfiles: {}
            };
            contactType = "customer";
          }
        }
        if (!contactDetails) continue;
        const channel = msg.social_integrations?.platform?.toLowerCase() || "unknown";
        result.push({
          id: msg.social_messages.id,
          contactId: contactDetails.id,
          contactType,
          channel,
          // Determine direction based on sender field
          direction: msg.social_messages.sender === "system" ? "outbound" : "inbound",
          // In the database the message field is used instead of content
          content: msg.social_messages.message || "",
          status: msg.social_messages.status?.toLowerCase() || "unread",
          // We use createdAt for the sentAt field since our database schema doesn't have sent_at
          sentAt: msg.social_messages.createdAt,
          receivedAt: msg.social_messages.receivedAt || void 0,
          attachments: msg.social_messages.attachments || [],
          contactDetails
        });
      }
      return result;
    } catch (error) {
      console.error("Database error in getAllCommunications:", error);
      return [];
    }
  };
  dbStorage.getRelatedCommunications = async function(relatedToType, relatedToId) {
    try {
      const messages2 = await db.select({
        social_messages: socialMessages,
        social_integrations: socialIntegrations
      }).from(socialMessages).leftJoin(socialIntegrations, eq(socialMessages.integrationId, socialIntegrations.id)).where(
        and(
          eq(socialMessages.relatedToType, relatedToType),
          eq(socialMessages.relatedToId, relatedToId),
          eq(socialMessages.isDeleted, false)
        )
      ).orderBy(desc(socialMessages.createdAt));
      const result = [];
      for (const msg of messages2) {
        if (msg.social_messages.isDeleted) continue;
        let contactDetails = null;
        let contactType = "lead";
        let contactId = 0;
        if (msg.social_messages.leadId) {
          const [lead] = await db.select().from(leads).where(eq(leads.id, msg.social_messages.leadId));
          if (lead) {
            contactDetails = {
              id: lead.id,
              firstName: lead.firstName || "",
              lastName: lead.lastName || "",
              email: lead.email || void 0,
              phone: lead.phone || void 0,
              company: lead.company || void 0,
              type: "lead",
              socialProfiles: {}
            };
            contactType = "lead";
            contactId = lead.id;
          }
        } else if (msg.social_messages.contactId) {
          const [contactRecord] = await db.select().from(contacts).where(eq(contacts.id, msg.social_messages.contactId));
          if (contactRecord) {
            contactDetails = {
              id: contactRecord.id,
              firstName: contactRecord.firstName || "",
              lastName: contactRecord.lastName || "",
              email: contactRecord.email || void 0,
              phone: contactRecord.phone || void 0,
              type: "customer",
              socialProfiles: {}
            };
            contactType = "customer";
            contactId = contactRecord.id;
          }
        }
        if (!contactDetails) continue;
        const channel = msg.social_integrations?.platform?.toLowerCase() || "unknown";
        result.push({
          id: msg.social_messages.id,
          contactId,
          contactType,
          channel,
          // Determine direction based on sender field
          direction: msg.social_messages.sender === "system" ? "outbound" : "inbound",
          // In the database the message field is used instead of content
          content: msg.social_messages.message || "",
          status: msg.social_messages.status?.toLowerCase() || "unread",
          // We use createdAt for the sentAt field since our database schema doesn't have sent_at
          sentAt: msg.social_messages.createdAt,
          receivedAt: msg.social_messages.receivedAt || void 0,
          attachments: msg.social_messages.attachments || [],
          contactDetails,
          relatedToType: msg.social_messages.relatedToType || void 0,
          relatedToId: msg.social_messages.relatedToId || void 0
        });
      }
      return result;
    } catch (error) {
      console.error("Database error in getRelatedCommunications:", error);
      return [];
    }
  };
  dbStorage.getContactCommunications = async function(contactId, contactType) {
    try {
      const messages2 = await db.select({
        social_messages: socialMessages,
        social_integrations: socialIntegrations
      }).from(socialMessages).leftJoin(socialIntegrations, eq(socialMessages.integrationId, socialIntegrations.id)).where(
        and(
          contactType === "lead" ? eq(socialMessages.leadId, contactId) : eq(socialMessages.contactId, contactId),
          eq(socialMessages.isDeleted, false)
        )
      ).orderBy(desc(socialMessages.createdAt));
      const result = [];
      for (const msg of messages2) {
        if (msg.social_messages.isDeleted) continue;
        let contactDetails = null;
        if (contactType === "lead") {
          const [lead] = await db.select().from(leads).where(eq(leads.id, contactId));
          if (lead) {
            contactDetails = {
              id: lead.id,
              firstName: lead.firstName || "",
              lastName: lead.lastName || "",
              email: lead.email || void 0,
              phone: lead.phone || void 0,
              company: lead.company || void 0,
              type: "lead",
              socialProfiles: {}
            };
          }
        } else {
          const [contactRecord] = await db.select().from(contacts).where(eq(contacts.id, contactId));
          if (contactRecord) {
            contactDetails = {
              id: contactRecord.id,
              firstName: contactRecord.firstName || "",
              lastName: contactRecord.lastName || "",
              email: contactRecord.email || void 0,
              phone: contactRecord.phone || void 0,
              type: "customer",
              socialProfiles: {}
            };
          }
        }
        if (!contactDetails) continue;
        const channel = msg.social_integrations?.platform?.toLowerCase() || "unknown";
        result.push({
          id: msg.social_messages.id,
          contactId: contactDetails.id,
          contactType,
          channel,
          // Determine direction based on sender field
          direction: msg.social_messages.sender === "system" ? "outbound" : "inbound",
          // In the database the message field is used instead of content
          content: msg.social_messages.message || "",
          status: msg.social_messages.status?.toLowerCase() || "unread",
          // We use createdAt for the sentAt field since our database schema doesn't have sent_at
          sentAt: msg.social_messages.createdAt,
          receivedAt: msg.social_messages.receivedAt || void 0,
          attachments: msg.social_messages.attachments || [],
          contactDetails
        });
      }
      return result;
    } catch (error) {
      console.error("Database error in getContactCommunications:", error);
      return [];
    }
  };
  dbStorage.updateCommunicationStatus = async function(id, status) {
    try {
      const normalizedStatus = status.toLowerCase();
      let dbStatus;
      switch (normalizedStatus) {
        case "unread":
          dbStatus = "Unread";
          break;
        case "read":
          dbStatus = "Read";
          break;
        case "replied":
          dbStatus = "Replied";
          break;
        case "archived":
          dbStatus = "Archived";
          break;
        default:
          dbStatus = "Unread";
      }
      const result = await db.update(socialMessages).set({ status: dbStatus }).where(eq(socialMessages.id, id)).returning();
      if (result.length === 0) {
        return null;
      }
      const [msg] = await db.select({
        social_messages: socialMessages,
        social_integrations: socialIntegrations
      }).from(socialMessages).leftJoin(socialIntegrations, eq(socialMessages.integrationId, socialIntegrations.id)).where(eq(socialMessages.id, id));
      if (!msg) return null;
      let contactDetails = null;
      let contactType = "lead";
      let contactId = 0;
      if (msg.social_messages.leadId) {
        const [lead] = await db.select().from(leads).where(eq(leads.id, msg.social_messages.leadId));
        if (lead) {
          contactDetails = {
            id: lead.id,
            firstName: lead.firstName || "",
            lastName: lead.lastName || "",
            email: lead.email || void 0,
            phone: lead.phone || void 0,
            company: lead.company || void 0,
            type: "lead",
            socialProfiles: {}
          };
          contactType = "lead";
          contactId = lead.id;
        }
      } else if (msg.social_messages.contactId) {
        const [contactRecord] = await db.select().from(contacts).where(eq(contacts.id, msg.social_messages.contactId));
        if (contactRecord) {
          contactDetails = {
            id: contactRecord.id,
            firstName: contactRecord.firstName || "",
            lastName: contactRecord.lastName || "",
            email: contactRecord.email || void 0,
            phone: contactRecord.phone || void 0,
            type: "customer",
            socialProfiles: {}
          };
          contactType = "customer";
          contactId = contactRecord.id;
        }
      }
      if (!contactDetails) return null;
      const channel = msg.social_integrations?.platform?.toLowerCase() || "unknown";
      return {
        id: msg.social_messages.id,
        contactId,
        contactType,
        channel,
        direction: msg.social_messages.sender === "system" ? "outbound" : "inbound",
        content: msg.social_messages.message || "",
        status: normalizedStatus,
        sentAt: msg.social_messages.createdAt,
        receivedAt: msg.social_messages.receivedAt || void 0,
        attachments: msg.social_messages.attachments || [],
        contactDetails
      };
    } catch (error) {
      console.error("Database error in updateCommunicationStatus:", error);
      return null;
    }
  };
  dbStorage.createCommunication = async function(data) {
    try {
      const [integration] = await db.select().from(socialIntegrations).where(eq(socialIntegrations.platform, data.channel)).limit(1);
      let dbStatus;
      const statusLower = (data.status || "").toLowerCase();
      switch (statusLower) {
        case "read":
          dbStatus = "Read";
          break;
        case "replied":
          dbStatus = "Replied";
          break;
        case "archived":
          dbStatus = "Archived";
          break;
        default:
          dbStatus = "Unread";
      }
      const messageData = {
        integrationId: integration?.id || null,
        externalId: `internal-${Date.now()}`,
        // Generate a fake external ID for internal messages
        // Use message field instead of content since that's what exists in the database
        message: data.content,
        // For direction, use sender/recipient fields
        // Normalize direction to lowercase for consistent handling
        sender: data.direction.toLowerCase() === "outbound" ? "system" : "user",
        recipient: data.direction.toLowerCase() === "outbound" ? "user" : "system",
        status: dbStatus,
        // Don't use sentAt as it doesn't exist in the database schema
        // createdAt will be set automatically by Drizzle's defaultNow()
        receivedAt: data.receivedAt,
        attachments: data.attachments || null,
        // Add the relationship fields if provided
        relatedToType: data.relatedToType || null,
        relatedToId: data.relatedToId || null
      };
      if (data.contactType === "lead") {
        messageData.leadId = data.contactId;
      } else {
        messageData.contactId = data.contactId;
      }
      const [newMessage] = await db.insert(socialMessages).values(messageData).returning();
      if (!newMessage) {
        return null;
      }
      let contactDetails = null;
      if (data.contactType === "lead") {
        const [lead] = await db.select().from(leads).where(eq(leads.id, data.contactId));
        if (lead) {
          contactDetails = {
            id: lead.id,
            firstName: lead.firstName || "",
            lastName: lead.lastName || "",
            email: lead.email || void 0,
            phone: lead.phone || void 0,
            company: lead.company || void 0,
            type: "lead",
            socialProfiles: {}
          };
        }
      } else {
        const [contactRecord] = await db.select().from(contacts).where(eq(contacts.id, data.contactId));
        if (contactRecord) {
          contactDetails = {
            id: contactRecord.id,
            firstName: contactRecord.firstName || "",
            lastName: contactRecord.lastName || "",
            email: contactRecord.email || void 0,
            phone: contactRecord.phone || void 0,
            type: "customer",
            socialProfiles: {}
          };
        }
      }
      if (!contactDetails) return null;
      let normalizedStatus = "unread";
      if (data.status) {
        normalizedStatus = data.status.toLowerCase();
      }
      return {
        id: newMessage.id,
        contactId: data.contactId,
        contactType: data.contactType,
        channel: data.channel,
        // Return direction in lowercase to match the interface type
        direction: data.direction.toLowerCase(),
        content: data.content,
        status: normalizedStatus,
        sentAt: newMessage.createdAt,
        receivedAt: data.receivedAt,
        attachments: data.attachments,
        contactDetails,
        relatedToType: data.relatedToType,
        relatedToId: data.relatedToId
      };
    } catch (error) {
      console.error("Database error in createCommunication:", error);
      return null;
    }
  };
}
var init_communication_integration = __esm({
  "server/communication-integration.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/social-integrations.ts
import { eq as eq2 } from "drizzle-orm";
function addSocialIntegrationsToMemStorage(storage2) {
  storage2.getSocialIntegration = async function(id) {
    return this.socialIntegrations.get(id);
  };
  storage2.listSocialIntegrations = async function(filter) {
    let integrations = Array.from(this.socialIntegrations.values());
    if (filter) {
      integrations = integrations.filter((integration) => {
        for (const [key, value] of Object.entries(filter)) {
          if (integration[key] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    return integrations;
  };
  storage2.getUserSocialIntegrations = async function(userId) {
    return this.listSocialIntegrations({ userId });
  };
  storage2.createSocialIntegration = async function(integration) {
    const id = this.socialIntegrationIdCounter++;
    const createdAt = /* @__PURE__ */ new Date();
    const socialIntegration = {
      ...integration,
      id,
      createdAt,
      updatedAt: null,
      accessToken: integration.accessToken || null,
      refreshToken: integration.refreshToken || null,
      tokenExpiry: integration.tokenExpiry || null,
      webhookUrl: integration.webhookUrl || null,
      webhookSecret: integration.webhookSecret || null,
      config: integration.config || null,
      isActive: integration.isActive === void 0 ? true : integration.isActive
    };
    this.socialIntegrations.set(id, socialIntegration);
    return socialIntegration;
  };
  storage2.updateSocialIntegration = async function(id, integrationData) {
    const existingIntegration = this.socialIntegrations.get(id);
    if (!existingIntegration) {
      return void 0;
    }
    const updatedIntegration = {
      ...existingIntegration,
      ...integrationData,
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.socialIntegrations.set(id, updatedIntegration);
    return updatedIntegration;
  };
  storage2.deleteSocialIntegration = async function(id) {
    return this.socialIntegrations.delete(id);
  };
  storage2.getSocialMessage = async function(id) {
    return this.socialMessages.get(id);
  };
  storage2.listSocialMessages = async function(filter) {
    let messages2 = Array.from(this.socialMessages.values());
    if (filter) {
      messages2 = messages2.filter((message) => {
        for (const [key, value] of Object.entries(filter)) {
          if (message[key] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    return messages2;
  };
  storage2.getLeadSocialMessages = async function(leadId) {
    return this.listSocialMessages({ leadId });
  };
  storage2.getContactSocialMessages = async function(contactId) {
    return this.listSocialMessages({ contactId });
  };
  storage2.createSocialMessage = async function(message) {
    const id = this.socialMessageIdCounter++;
    const createdAt = /* @__PURE__ */ new Date();
    const socialMessage = {
      ...message,
      id,
      createdAt,
      attachments: message.attachments || null,
      metadata: message.metadata || null,
      receivedAt: message.receivedAt || null,
      isDeleted: message.isDeleted === void 0 ? false : message.isDeleted
    };
    this.socialMessages.set(id, socialMessage);
    return socialMessage;
  };
  storage2.updateSocialMessage = async function(id, messageData) {
    const existingMessage = this.socialMessages.get(id);
    if (!existingMessage) {
      return void 0;
    }
    const updatedMessage = {
      ...existingMessage,
      ...messageData
    };
    this.socialMessages.set(id, updatedMessage);
    return updatedMessage;
  };
  storage2.deleteSocialMessage = async function(id) {
    const existingMessage = this.socialMessages.get(id);
    if (!existingMessage) {
      return false;
    }
    const deletedMessage = {
      ...existingMessage,
      isDeleted: true
    };
    this.socialMessages.set(id, deletedMessage);
    return true;
  };
  storage2.getLeadSource = async function(id) {
    return this.leadSources.get(id);
  };
  storage2.listLeadSources = async function(filter) {
    let sources = Array.from(this.leadSources.values());
    if (filter) {
      sources = sources.filter((source) => {
        for (const [key, value] of Object.entries(filter)) {
          if (source[key] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    return sources;
  };
  storage2.createLeadSource = async function(source) {
    const id = this.leadSourceIdCounter++;
    const createdAt = /* @__PURE__ */ new Date();
    const leadSource = {
      ...source,
      id,
      createdAt,
      updatedAt: null,
      description: source.description || null,
      platform: source.platform || null,
      isActive: source.isActive === void 0 ? true : source.isActive
    };
    this.leadSources.set(id, leadSource);
    return leadSource;
  };
  storage2.updateLeadSource = async function(id, sourceData) {
    const existingSource = this.leadSources.get(id);
    if (!existingSource) {
      return void 0;
    }
    const updatedSource = {
      ...existingSource,
      ...sourceData,
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.leadSources.set(id, updatedSource);
    return updatedSource;
  };
  storage2.deleteLeadSource = async function(id) {
    return this.leadSources.delete(id);
  };
  storage2.getSocialCampaign = async function(id) {
    return this.socialCampaigns.get(id);
  };
  storage2.listSocialCampaigns = async function(filter) {
    let campaigns = Array.from(this.socialCampaigns.values());
    if (filter) {
      campaigns = campaigns.filter((campaign) => {
        for (const [key, value] of Object.entries(filter)) {
          if (campaign[key] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    return campaigns;
  };
  storage2.createSocialCampaign = async function(campaign) {
    const id = this.socialCampaignIdCounter++;
    const createdAt = /* @__PURE__ */ new Date();
    const socialCampaign = {
      ...campaign,
      id,
      createdAt,
      updatedAt: null,
      description: campaign.description || null,
      startDate: campaign.startDate || null,
      endDate: campaign.endDate || null,
      ownerId: campaign.ownerId || null,
      content: campaign.content || null,
      metrics: campaign.metrics || null,
      isActive: campaign.isActive === void 0 ? true : campaign.isActive
    };
    this.socialCampaigns.set(id, socialCampaign);
    return socialCampaign;
  };
  storage2.updateSocialCampaign = async function(id, campaignData) {
    const existingCampaign = this.socialCampaigns.get(id);
    if (!existingCampaign) {
      return void 0;
    }
    const updatedCampaign = {
      ...existingCampaign,
      ...campaignData,
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.socialCampaigns.set(id, updatedCampaign);
    return updatedCampaign;
  };
  storage2.deleteSocialCampaign = async function(id) {
    return this.socialCampaigns.delete(id);
  };
}
function addSocialIntegrationsToDatabaseStorage(storage2) {
  storage2.getSocialIntegration = async function(id) {
    try {
      const [integration] = await db.select().from(socialIntegrations).where(eq2(socialIntegrations.id, id));
      return integration;
    } catch (error) {
      console.error("Database error in getSocialIntegration:", error);
      return void 0;
    }
  };
  storage2.listSocialIntegrations = async function(filter) {
    try {
      let query = db.select().from(socialIntegrations);
      if (filter) {
        if (filter.userId !== void 0) {
          query = query.where(eq2(socialIntegrations.userId, filter.userId));
        }
        if (filter.platform !== void 0) {
          query = query.where(eq2(socialIntegrations.platform, filter.platform));
        }
        if (filter.isActive !== void 0) {
          query = query.where(eq2(socialIntegrations.isActive, filter.isActive));
        }
      }
      return await query;
    } catch (error) {
      console.error("Database error in listSocialIntegrations:", error);
      return [];
    }
  };
  storage2.getUserSocialIntegrations = async function(userId) {
    try {
      return await db.select().from(socialIntegrations).where(eq2(socialIntegrations.userId, userId));
    } catch (error) {
      console.error("Database error in getUserSocialIntegrations:", error);
      return [];
    }
  };
  storage2.createSocialIntegration = async function(integration) {
    try {
      const [newIntegration] = await db.insert(socialIntegrations).values(integration).returning();
      return newIntegration;
    } catch (error) {
      console.error("Database error in createSocialIntegration:", error);
      throw new Error(`Failed to create social integration: ${error}`);
    }
  };
  storage2.updateSocialIntegration = async function(id, integration) {
    try {
      const [updatedIntegration] = await db.update(socialIntegrations).set({ ...integration, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(socialIntegrations.id, id)).returning();
      return updatedIntegration;
    } catch (error) {
      console.error("Database error in updateSocialIntegration:", error);
      return void 0;
    }
  };
  storage2.deleteSocialIntegration = async function(id) {
    try {
      const result = await db.delete(socialIntegrations).where(eq2(socialIntegrations.id, id));
      return result.rowCount ? result.rowCount > 0 : false;
    } catch (error) {
      console.error("Database error in deleteSocialIntegration:", error);
      return false;
    }
  };
  storage2.getSocialMessage = async function(id) {
    try {
      const [message] = await db.select().from(socialMessages).where(eq2(socialMessages.id, id));
      return message;
    } catch (error) {
      console.error("Database error in getSocialMessage:", error);
      return void 0;
    }
  };
  storage2.listSocialMessages = async function(filter) {
    try {
      let query = db.select().from(socialMessages);
      if (filter) {
        if (filter.integrationId !== void 0) {
          query = query.where(eq2(socialMessages.integrationId, filter.integrationId));
        }
        if (filter.leadId !== void 0) {
          query = query.where(eq2(socialMessages.leadId, filter.leadId));
        }
        if (filter.contactId !== void 0) {
          query = query.where(eq2(socialMessages.contactId, filter.contactId));
        }
        if (filter.direction !== void 0) {
          query = query.where(eq2(socialMessages.direction, filter.direction));
        }
        if (filter.status !== void 0) {
          query = query.where(eq2(socialMessages.status, filter.status));
        }
        if (filter.isDeleted !== void 0) {
          query = query.where(eq2(socialMessages.isDeleted, filter.isDeleted));
        }
      }
      return await query;
    } catch (error) {
      console.error("Database error in listSocialMessages:", error);
      return [];
    }
  };
  storage2.getLeadSocialMessages = async function(leadId) {
    try {
      return await db.select().from(socialMessages).where(eq2(socialMessages.leadId, leadId));
    } catch (error) {
      console.error("Database error in getLeadSocialMessages:", error);
      return [];
    }
  };
  storage2.getContactSocialMessages = async function(contactId) {
    try {
      return await db.select().from(socialMessages).where(eq2(socialMessages.contactId, contactId));
    } catch (error) {
      console.error("Database error in getContactSocialMessages:", error);
      return [];
    }
  };
  storage2.createSocialMessage = async function(message) {
    try {
      const [newMessage] = await db.insert(socialMessages).values(message).returning();
      return newMessage;
    } catch (error) {
      console.error("Database error in createSocialMessage:", error);
      throw new Error(`Failed to create social message: ${error}`);
    }
  };
  storage2.updateSocialMessage = async function(id, message) {
    try {
      const [updatedMessage] = await db.update(socialMessages).set(message).where(eq2(socialMessages.id, id)).returning();
      return updatedMessage;
    } catch (error) {
      console.error("Database error in updateSocialMessage:", error);
      return void 0;
    }
  };
  storage2.deleteSocialMessage = async function(id) {
    try {
      const [updatedMessage] = await db.update(socialMessages).set({ isDeleted: true }).where(eq2(socialMessages.id, id)).returning();
      return !!updatedMessage;
    } catch (error) {
      console.error("Database error in deleteSocialMessage:", error);
      return false;
    }
  };
  storage2.getLeadSource = async function(id) {
    try {
      const [source] = await db.select().from(leadSources).where(eq2(leadSources.id, id));
      return source;
    } catch (error) {
      console.error("Database error in getLeadSource:", error);
      return void 0;
    }
  };
  storage2.listLeadSources = async function(filter) {
    try {
      let query = db.select().from(leadSources);
      if (filter) {
        if (filter.platform !== void 0) {
          query = query.where(eq2(leadSources.platform, filter.platform));
        }
        if (filter.isActive !== void 0) {
          query = query.where(eq2(leadSources.isActive, filter.isActive));
        }
      }
      return await query;
    } catch (error) {
      console.error("Database error in listLeadSources:", error);
      return [];
    }
  };
  storage2.createLeadSource = async function(source) {
    try {
      const [newSource] = await db.insert(leadSources).values(source).returning();
      return newSource;
    } catch (error) {
      console.error("Database error in createLeadSource:", error);
      throw new Error(`Failed to create lead source: ${error}`);
    }
  };
  storage2.updateLeadSource = async function(id, source) {
    try {
      const [updatedSource] = await db.update(leadSources).set({ ...source, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(leadSources.id, id)).returning();
      return updatedSource;
    } catch (error) {
      console.error("Database error in updateLeadSource:", error);
      return void 0;
    }
  };
  storage2.deleteLeadSource = async function(id) {
    try {
      const result = await db.delete(leadSources).where(eq2(leadSources.id, id));
      return result.rowCount ? result.rowCount > 0 : false;
    } catch (error) {
      console.error("Database error in deleteLeadSource:", error);
      return false;
    }
  };
  storage2.getSocialCampaign = async function(id) {
    try {
      const [campaign] = await db.select().from(socialCampaigns).where(eq2(socialCampaigns.id, id));
      return campaign;
    } catch (error) {
      console.error("Database error in getSocialCampaign:", error);
      return void 0;
    }
  };
  storage2.listSocialCampaigns = async function(filter) {
    try {
      let query = db.select().from(socialCampaigns);
      if (filter) {
        if (filter.platform !== void 0) {
          query = query.where(eq2(socialCampaigns.platform, filter.platform));
        }
        if (filter.ownerId !== void 0) {
          query = query.where(eq2(socialCampaigns.ownerId, filter.ownerId));
        }
        if (filter.status !== void 0) {
          query = query.where(eq2(socialCampaigns.status, filter.status));
        }
        if (filter.isActive !== void 0) {
          query = query.where(eq2(socialCampaigns.isActive, filter.isActive));
        }
      }
      return await query;
    } catch (error) {
      console.error("Database error in listSocialCampaigns:", error);
      return [];
    }
  };
  storage2.createSocialCampaign = async function(campaign) {
    try {
      const [newCampaign] = await db.insert(socialCampaigns).values(campaign).returning();
      return newCampaign;
    } catch (error) {
      console.error("Database error in createSocialCampaign:", error);
      throw new Error(`Failed to create social campaign: ${error}`);
    }
  };
  storage2.updateSocialCampaign = async function(id, campaign) {
    try {
      const [updatedCampaign] = await db.update(socialCampaigns).set({ ...campaign, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(socialCampaigns.id, id)).returning();
      return updatedCampaign;
    } catch (error) {
      console.error("Database error in updateSocialCampaign:", error);
      return void 0;
    }
  };
  storage2.deleteSocialCampaign = async function(id) {
    try {
      const result = await db.delete(socialCampaigns).where(eq2(socialCampaigns.id, id));
      return result.rowCount ? result.rowCount > 0 : false;
    } catch (error) {
      console.error("Database error in deleteSocialCampaign:", error);
      return false;
    }
  };
}
var init_social_integrations = __esm({
  "server/social-integrations.ts"() {
    "use strict";
    init_schema();
    init_db();
  }
});

// server/api-keys-integration.ts
import { eq as eq3 } from "drizzle-orm";
function addApiKeysToMemStorage(storage2) {
  storage2.getApiKey = async function(id) {
    return this.apiKeys.get(id);
  };
  storage2.listApiKeys = async function(filter) {
    let keys = Array.from(this.apiKeys.values());
    if (filter) {
      keys = keys.filter((key) => {
        for (const [k, value] of Object.entries(filter)) {
          if (key[k] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    return keys;
  };
  storage2.createApiKey = async function(apiKey) {
    const id = this.apiKeyIdCounter++;
    const createdAt = /* @__PURE__ */ new Date();
    const newApiKey = {
      ...apiKey,
      id,
      createdAt,
      updatedAt: null,
      usageCount: 0,
      lastUsed: null
    };
    this.apiKeys.set(id, newApiKey);
    return newApiKey;
  };
  storage2.updateApiKey = async function(id, apiKeyData) {
    const existingApiKey = this.apiKeys.get(id);
    if (!existingApiKey) {
      return void 0;
    }
    const updatedApiKey = {
      ...existingApiKey,
      ...apiKeyData,
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.apiKeys.set(id, updatedApiKey);
    return updatedApiKey;
  };
  storage2.deleteApiKey = async function(id) {
    return this.apiKeys.delete(id);
  };
}
function addApiKeysToDatabaseStorage(storage2) {
  storage2.getApiKey = async function(id) {
    try {
      const [key] = await db.select().from(apiKeys).where(eq3(apiKeys.id, id));
      return key;
    } catch (error) {
      console.error("Database error in getApiKey:", error);
      return void 0;
    }
  };
  storage2.listApiKeys = async function(filter) {
    try {
      let query = db.select().from(apiKeys);
      if (filter) {
        if (filter.provider !== void 0) {
          query = query.where(eq3(apiKeys.provider, filter.provider));
        }
        if (filter.ownerId !== void 0) {
          query = query.where(eq3(apiKeys.ownerId, filter.ownerId));
        }
        if (filter.isActive !== void 0) {
          query = query.where(eq3(apiKeys.isActive, filter.isActive));
        }
      }
      return await query;
    } catch (error) {
      console.error("Database error in listApiKeys:", error);
      return [];
    }
  };
  storage2.createApiKey = async function(apiKey) {
    try {
      const [newApiKey] = await db.insert(apiKeys).values(apiKey).returning();
      return newApiKey;
    } catch (error) {
      console.error("Database error in createApiKey:", error);
      throw new Error(`Failed to create API key: ${error}`);
    }
  };
  storage2.updateApiKey = async function(id, apiKeyData) {
    try {
      const [updatedApiKey] = await db.update(apiKeys).set(apiKeyData).where(eq3(apiKeys.id, id)).returning();
      return updatedApiKey;
    } catch (error) {
      console.error("Database error in updateApiKey:", error);
      return void 0;
    }
  };
  storage2.deleteApiKey = async function(id) {
    try {
      const result = await db.delete(apiKeys).where(eq3(apiKeys.id, id));
      return result.rowCount ? result.rowCount > 0 : false;
    } catch (error) {
      console.error("Database error in deleteApiKey:", error);
      return false;
    }
  };
}
var init_api_keys_integration = __esm({
  "server/api-keys-integration.ts"() {
    "use strict";
    init_schema();
    init_db();
  }
});

// server/permissions-manager.ts
import { eq as eq4, and as and2 } from "drizzle-orm";
function requirePermission(module, action) {
  return async (req, res, next) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const permReq = req;
    const hasPermission = await permReq.hasPermission(module, action);
    if (!hasPermission) {
      return res.status(403).json({
        error: "Permission denied",
        message: `You don't have permission to ${action} in the ${module} module`
      });
    }
    next();
  };
}
function setupPermissionMiddleware(req, _res, next) {
  const permReq = req;
  permReq.hasPermission = async (module, action) => {
    if (!req.isAuthenticated() || !req.user) {
      return false;
    }
    if (req.user.role === "Admin") {
      return true;
    }
    try {
      const moduleEntity = await storage.getModuleByName(module);
      if (!moduleEntity) {
        return false;
      }
      const userPermission = await storage.getUserPermission(req.user.id, moduleEntity.id, action);
      if (userPermission) {
        return userPermission.isAllowed;
      }
      const rolePermission = await storage.getRolePermission(req.user.role, moduleEntity.id, action);
      if (rolePermission) {
        return rolePermission.isAllowed;
      }
      return false;
    } catch (error) {
      console.error("Error checking permissions:", error);
      return false;
    }
  };
  permReq.hasEntityAccess = async (entityType, entityId) => {
    if (!req.isAuthenticated() || !req.user) {
      return false;
    }
    if (req.user.role === "Admin") {
      return true;
    }
    try {
      const directAccess = await storage.checkUserEntityAccess(req.user.id, entityType, entityId);
      if (directAccess) {
        return true;
      }
      const teamAccess = await storage.checkTeamEntityAccess(req.user.id, entityType, entityId);
      if (teamAccess) {
        return true;
      }
      if (req.user.role === "Manager") {
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error checking entity access:", error);
      return false;
    }
  };
  next();
}
function addPermissionsToMemStorage(storage2) {
  const modulePermissionsList = [];
  const rolePermissionsList = [];
  const userPermissionsList = [];
  const teamsList = [];
  const teamMembersList = [];
  const assignmentsList = [];
  storage2.getModuleByName = async function(moduleName) {
    return modulePermissionsList.find((m) => m.moduleName === moduleName);
  };
  storage2.getUserPermission = async function(userId, moduleId, action) {
    return userPermissionsList.find(
      (p) => p.userId === userId && p.moduleId === moduleId && p.action === action
    );
  };
  storage2.getRolePermission = async function(role, moduleId, action) {
    return rolePermissionsList.find(
      (p) => p.role === role && p.moduleId === moduleId && p.action === action
    );
  };
  storage2.checkUserEntityAccess = async function(userId, entityType, entityId) {
    const entity = await storage2.getEntityById(entityType, entityId);
    if (entity && entity.ownerId === userId) {
      return true;
    }
    return assignmentsList.some(
      (a) => a.entityType === entityType && a.entityId === entityId && a.assignedToType === "user" && a.assignedToId === userId
    );
  };
  storage2.checkTeamEntityAccess = async function(userId, entityType, entityId) {
    const userTeams = teamMembersList.filter((tm) => tm.userId === userId).map((tm) => tm.teamId);
    return userTeams.length > 0 && assignmentsList.some(
      (a) => a.entityType === entityType && a.entityId === entityId && a.assignedToType === "team" && userTeams.includes(a.assignedToId)
    );
  };
  storage2.getEntityById = async function(entityType, entityId) {
    switch (entityType) {
      case "lead":
        return storage2.getLead(entityId);
      case "contact":
        return storage2.getContact(entityId);
      case "account":
        return storage2.getAccount(entityId);
      case "opportunity":
        return storage2.getOpportunity(entityId);
      default:
        return null;
    }
  };
  storage2.initializePermissions = async function() {
    const modules = [
      { id: 1, moduleName: "contacts", displayName: "Contacts", description: "Manage contacts", isActive: true, order: 1, icon: "users" },
      { id: 2, moduleName: "accounts", displayName: "Accounts", description: "Manage accounts/companies", isActive: true, order: 2, icon: "building" },
      { id: 3, moduleName: "leads", displayName: "Leads", description: "Manage leads", isActive: true, order: 3, icon: "user-plus" },
      { id: 4, moduleName: "opportunities", displayName: "Opportunities", description: "Manage sales opportunities", isActive: true, order: 4, icon: "trending-up" },
      { id: 5, moduleName: "tasks", displayName: "Tasks", description: "Manage tasks", isActive: true, order: 5, icon: "check-square" },
      { id: 6, moduleName: "events", displayName: "Events", description: "Manage calendar events", isActive: true, order: 6, icon: "calendar" },
      { id: 7, moduleName: "communications", displayName: "Communications", description: "Manage customer communications", isActive: true, order: 7, icon: "message-square" },
      { id: 8, moduleName: "products", displayName: "Products", description: "Manage products", isActive: true, order: 8, icon: "package" },
      { id: 9, moduleName: "inventory", displayName: "Inventory", description: "Manage inventory", isActive: true, order: 9, icon: "box" },
      { id: 10, moduleName: "invoices", displayName: "Invoices", description: "Manage invoices", isActive: true, order: 10, icon: "file-text" },
      { id: 11, moduleName: "purchase-orders", displayName: "Purchase Orders", description: "Manage purchase orders", isActive: true, order: 11, icon: "shopping-cart" },
      { id: 12, moduleName: "reports", displayName: "Reports", description: "View and export reports", isActive: true, order: 12, icon: "bar-chart-2" },
      { id: 13, moduleName: "workflows", displayName: "Workflows", description: "Manage automation workflows", isActive: true, order: 13, icon: "git-branch" },
      { id: 14, moduleName: "settings", displayName: "Settings", description: "System settings and configuration", isActive: true, order: 14, icon: "settings" },
      { id: 15, moduleName: "users", displayName: "Users", description: "Manage system users", isActive: true, order: 15, icon: "users" },
      { id: 16, moduleName: "api-keys", displayName: "API Keys", description: "Manage API integrations", isActive: true, order: 16, icon: "key" },
      { id: 17, moduleName: "subscriptions", displayName: "Subscriptions", description: "Manage subscription packages", isActive: true, order: 17, icon: "credit-card" },
      { id: 18, moduleName: "proposals", displayName: "Proposals", description: "Create and manage proposals/contracts", isActive: true, order: 18, icon: "file" }
    ];
    modulePermissionsList.push(...modules);
    const actions = ["view", "create", "update", "delete", "export", "import", "assign"];
    const roles = ["Admin", "Manager", "User", "ReadOnly"];
    let permId = 1;
    roles.forEach((role) => {
      modules.forEach((module) => {
        actions.forEach((action) => {
          let isAllowed = false;
          if (role === "Admin") {
            isAllowed = true;
          } else if (role === "Manager") {
            isAllowed = action !== "delete" || module.moduleName !== "users" && module.moduleName !== "settings" && module.moduleName !== "subscriptions";
          } else if (role === "User") {
            isAllowed = // Can view most things
            action === "view" || // Can create and update basic entities
            (action === "create" || action === "update") && ["contacts", "leads", "opportunities", "tasks", "events", "communications"].includes(module.moduleName);
          } else if (role === "ReadOnly") {
            isAllowed = action === "view" && module.moduleName !== "settings" && module.moduleName !== "users";
          }
          rolePermissionsList.push({
            id: permId++,
            role,
            moduleId: module.id,
            action,
            isAllowed,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          });
        });
      });
    });
  };
}
function addPermissionsToDatabaseStorage(storage2) {
  storage2.getModuleByName = async function(moduleName) {
    const [module] = await db.select().from(modulePermissions).where(eq4(modulePermissions.moduleName, moduleName));
    return module;
  };
  storage2.getUserPermission = async function(userId, moduleId, action) {
    const [userPermission] = await db.select().from(userPermissions).where(
      and2(
        eq4(userPermissions.userId, userId),
        eq4(userPermissions.moduleId, moduleId),
        eq4(userPermissions.action, action)
      )
    );
    return userPermission;
  };
  storage2.getRolePermission = async function(role, moduleId, action) {
    const [rolePermission] = await db.select().from(rolePermissions).where(
      and2(
        eq4(rolePermissions.role, role),
        eq4(rolePermissions.moduleId, moduleId),
        eq4(rolePermissions.action, action)
      )
    );
    return rolePermission;
  };
  storage2.checkUserEntityAccess = async function(userId, entityType, entityId) {
    const entity = await storage2.getEntityById(entityType, entityId);
    if (entity && entity.ownerId === userId) {
      return true;
    }
    const [assignment] = await db.select().from(assignments).where(
      and2(
        eq4(assignments.entityType, entityType),
        eq4(assignments.entityId, entityId),
        eq4(assignments.assignedToType, "user"),
        eq4(assignments.assignedToId, userId)
      )
    );
    return !!assignment;
  };
  storage2.checkTeamEntityAccess = async function(userId, entityType, entityId) {
    const userTeamMembers = await db.select().from(teamMembers).where(eq4(teamMembers.userId, userId));
    if (userTeamMembers.length === 0) {
      return false;
    }
    const userTeamIds = userTeamMembers.map((tm) => tm.teamId);
    const [teamAssignment] = await db.select().from(assignments).where(
      and2(
        eq4(assignments.entityType, entityType),
        eq4(assignments.entityId, entityId),
        eq4(assignments.assignedToType, "team"),
        // TODO: Fix this. Need to check if assignedToId is in userTeamIds array
        // This is a simplification and might not work with actual Drizzle syntax
        eq4(assignments.assignedToId, userTeamIds[0])
      )
    );
    return !!teamAssignment;
  };
  storage2.getEntityById = async function(entityType, entityId) {
    switch (entityType) {
      case "lead":
        return storage2.getLead(entityId);
      case "contact":
        return storage2.getContact(entityId);
      case "account":
        return storage2.getAccount(entityId);
      case "opportunity":
        return storage2.getOpportunity(entityId);
      default:
        return null;
    }
  };
  storage2.initializePermissions = async function() {
    const [existingModule] = await db.select().from(modulePermissions).limit(1);
    if (existingModule) {
      console.log("Permissions already initialized, skipping...");
      return;
    }
    const modules = [
      { moduleName: "contacts", displayName: "Contacts", description: "Manage contacts", isActive: true, order: 1, icon: "users" },
      { moduleName: "accounts", displayName: "Accounts", description: "Manage accounts/companies", isActive: true, order: 2, icon: "building" },
      { moduleName: "leads", displayName: "Leads", description: "Manage leads", isActive: true, order: 3, icon: "user-plus" },
      { moduleName: "opportunities", displayName: "Opportunities", description: "Manage sales opportunities", isActive: true, order: 4, icon: "trending-up" },
      { moduleName: "tasks", displayName: "Tasks", description: "Manage tasks", isActive: true, order: 5, icon: "check-square" },
      { moduleName: "events", displayName: "Events", description: "Manage calendar events", isActive: true, order: 6, icon: "calendar" },
      { moduleName: "communications", displayName: "Communications", description: "Manage customer communications", isActive: true, order: 7, icon: "message-square" },
      { moduleName: "products", displayName: "Products", description: "Manage products", isActive: true, order: 8, icon: "package" },
      { moduleName: "inventory", displayName: "Inventory", description: "Manage inventory", isActive: true, order: 9, icon: "box" },
      { moduleName: "invoices", displayName: "Invoices", description: "Manage invoices", isActive: true, order: 10, icon: "file-text" },
      { moduleName: "purchase-orders", displayName: "Purchase Orders", description: "Manage purchase orders", isActive: true, order: 11, icon: "shopping-cart" },
      { moduleName: "reports", displayName: "Reports", description: "View and export reports", isActive: true, order: 12, icon: "bar-chart-2" },
      { moduleName: "workflows", displayName: "Workflows", description: "Manage automation workflows", isActive: true, order: 13, icon: "git-branch" },
      { moduleName: "settings", displayName: "Settings", description: "System settings and configuration", isActive: true, order: 14, icon: "settings" },
      { moduleName: "users", displayName: "Users", description: "Manage system users", isActive: true, order: 15, icon: "users" },
      { moduleName: "api-keys", displayName: "API Keys", description: "Manage API integrations", isActive: true, order: 16, icon: "key" },
      { moduleName: "subscriptions", displayName: "Subscriptions", description: "Manage subscription packages", isActive: true, order: 17, icon: "credit-card" },
      { moduleName: "proposals", displayName: "Proposals", description: "Create and manage proposals/contracts", isActive: true, order: 18, icon: "file" }
    ];
    console.log("Initializing module permissions...");
    const moduleIds = {};
    for (const module of modules) {
      const [insertedModule] = await db.insert(modulePermissions).values(module).returning();
      moduleIds[module.moduleName] = insertedModule.id;
    }
    console.log("Initializing role permissions...");
    const actions = ["view", "create", "update", "delete", "export", "import", "assign"];
    const roles = ["Admin", "Manager", "User", "ReadOnly"];
    for (const role of roles) {
      for (const [moduleName, moduleId] of Object.entries(moduleIds)) {
        for (const action of actions) {
          let isAllowed = false;
          if (role === "Admin") {
            isAllowed = true;
          } else if (role === "Manager") {
            isAllowed = action !== "delete" || moduleName !== "users" && moduleName !== "settings" && moduleName !== "subscriptions";
          } else if (role === "User") {
            isAllowed = // Can view most things
            action === "view" || // Can create and update basic entities
            (action === "create" || action === "update") && ["contacts", "leads", "opportunities", "tasks", "events", "communications"].includes(moduleName);
          } else if (role === "ReadOnly") {
            isAllowed = action === "view" && moduleName !== "settings" && moduleName !== "users";
          }
          await db.insert(rolePermissions).values({
            role,
            moduleId,
            action,
            isAllowed
          });
        }
      }
    }
    console.log("Permission initialization complete.");
  };
}
var init_permissions_manager = __esm({
  "server/permissions-manager.ts"() {
    "use strict";
    init_storage();
    init_schema();
    init_db();
  }
});

// server/storage.ts
import { eq as eq5, and as and3, desc as desc2, asc as asc2, sql, gte } from "drizzle-orm";
import session from "express-session";
import createMemoryStore from "memorystore";
import connectPg from "connect-pg-simple";
function initializeSubscriptionPackages(storage2) {
  storage2.createSubscriptionPackage({
    name: "Starter",
    description: "Basic CRM features for small businesses",
    price: 19.99,
    interval: "monthly",
    features: ["Contact Management", "Basic Lead Tracking", "Task Management"],
    maxUsers: 3,
    maxContacts: 500,
    maxStorage: 5,
    displayOrder: 1,
    stripePriceId: "price_starter_monthly"
  });
  storage2.createSubscriptionPackage({
    name: "Professional",
    description: "Advanced features for growing businesses",
    price: 49.99,
    interval: "monthly",
    features: ["All Starter Features", "Sales Pipeline", "Opportunity Management", "Basic AI Insights", "Email Templates"],
    maxUsers: 10,
    maxContacts: 2500,
    maxStorage: 20,
    displayOrder: 2,
    stripePriceId: "price_professional_monthly"
  });
  storage2.createSubscriptionPackage({
    name: "Enterprise",
    description: "Complete solution for established businesses",
    price: 99.99,
    interval: "monthly",
    features: ["All Professional Features", "Advanced AI Insights", "Custom Reporting", "Workflow Automation", "Dedicated Support"],
    maxUsers: 25,
    maxContacts: 1e4,
    maxStorage: 100,
    displayOrder: 3,
    stripePriceId: "price_enterprise_monthly"
  });
  storage2.createSubscriptionPackage({
    name: "Starter (Annual)",
    description: "Basic CRM features for small businesses - 20% discount",
    price: 191.88,
    // 19.99 * 12 * 0.8 (20% off)
    interval: "yearly",
    features: ["Contact Management", "Basic Lead Tracking", "Task Management"],
    maxUsers: 3,
    maxContacts: 500,
    maxStorage: 5,
    displayOrder: 4,
    stripePriceId: "price_starter_yearly"
  });
  storage2.createSubscriptionPackage({
    name: "Professional (Annual)",
    description: "Advanced features for growing businesses - 20% discount",
    price: 479.88,
    // 49.99 * 12 * 0.8 (20% off)
    interval: "yearly",
    features: ["All Starter Features", "Sales Pipeline", "Opportunity Management", "Basic AI Insights", "Email Templates"],
    maxUsers: 10,
    maxContacts: 2500,
    maxStorage: 20,
    displayOrder: 5,
    stripePriceId: "price_professional_yearly"
  });
  storage2.createSubscriptionPackage({
    name: "Enterprise (Annual)",
    description: "Complete solution for established businesses - 20% discount",
    price: 959.88,
    // 99.99 * 12 * 0.8 (20% off)
    interval: "yearly",
    features: ["All Professional Features", "Advanced AI Insights", "Custom Reporting", "Workflow Automation", "Dedicated Support"],
    maxUsers: 25,
    maxContacts: 1e4,
    maxStorage: 100,
    displayOrder: 6,
    stripePriceId: "price_enterprise_yearly"
  });
}
var MemoryStore, PostgresSessionStore, MemStorage, DatabaseStorage, useDatabase, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_communication_integration();
    init_db();
    init_db();
    init_social_integrations();
    init_api_keys_integration();
    init_permissions_manager();
    MemoryStore = createMemoryStore(session);
    PostgresSessionStore = connectPg(session);
    MemStorage = class {
      // Session store for authentication
      sessionStore;
      // Maps to store entity data
      users;
      // Make users map public for auth module direct access
      systemSettingsMap;
      contacts;
      accounts;
      leads;
      // Communication center properties will be added through the mixin pattern
      opportunities;
      tasks;
      events;
      activities;
      subscriptionPackages;
      userSubscriptions;
      socialIntegrations;
      socialMessages;
      leadSources;
      socialCampaigns;
      apiKeys;
      workflows;
      // Communications map already initialized
      // Proposal system maps
      proposalTemplates;
      proposals;
      proposalElements;
      proposalCollaborators;
      proposalComments;
      proposalActivities;
      // Business accounting maps
      productCategoriesMap;
      products;
      inventoryTransactions;
      invoices;
      invoiceItems;
      purchaseOrders;
      purchaseOrderItems;
      // Permission management maps
      modulePermissions;
      rolePermissions;
      userPermissions;
      teams;
      teamMembers;
      assignments;
      // Counter for IDs
      userIdCounter;
      contactIdCounter;
      accountIdCounter;
      leadIdCounter;
      opportunityIdCounter;
      taskIdCounter;
      eventIdCounter;
      activityIdCounter;
      subscriptionPackageIdCounter;
      userSubscriptionIdCounter;
      socialIntegrationIdCounter;
      socialMessageIdCounter;
      leadSourceIdCounter;
      socialCampaignIdCounter;
      apiKeyIdCounter;
      workflowIdCounter;
      // Communication ID counter already initialized
      // Business accounting ID counters
      productCategoryIdCounter;
      productIdCounter;
      inventoryTransactionIdCounter;
      invoiceIdCounter;
      invoiceItemIdCounter;
      purchaseOrderIdCounter;
      purchaseOrderItemIdCounter;
      // Proposal system ID counters
      proposalTemplateIdCounter;
      proposalIdCounter;
      proposalElementIdCounter;
      proposalCollaboratorIdCounter;
      proposalCommentIdCounter;
      proposalActivityIdCounter;
      // Permission management ID counters
      modulePermissionIdCounter;
      rolePermissionIdCounter;
      userPermissionIdCounter;
      teamIdCounter;
      teamMemberIdCounter;
      assignmentIdCounter;
      constructor() {
        this.sessionStore = new MemoryStore({
          checkPeriod: 864e5
          // prune expired entries every 24h
        });
        this.users = /* @__PURE__ */ new Map();
        this.contacts = /* @__PURE__ */ new Map();
        this.accounts = /* @__PURE__ */ new Map();
        this.leads = /* @__PURE__ */ new Map();
        this.opportunities = /* @__PURE__ */ new Map();
        this.tasks = /* @__PURE__ */ new Map();
        this.events = /* @__PURE__ */ new Map();
        this.activities = /* @__PURE__ */ new Map();
        this.subscriptionPackages = /* @__PURE__ */ new Map();
        this.userSubscriptions = /* @__PURE__ */ new Map();
        this.socialIntegrations = /* @__PURE__ */ new Map();
        this.socialMessages = /* @__PURE__ */ new Map();
        this.leadSources = /* @__PURE__ */ new Map();
        this.socialCampaigns = /* @__PURE__ */ new Map();
        this.apiKeys = /* @__PURE__ */ new Map();
        this.workflows = /* @__PURE__ */ new Map();
        this.systemSettingsMap = /* @__PURE__ */ new Map();
        this.proposalTemplates = /* @__PURE__ */ new Map();
        this.proposals = /* @__PURE__ */ new Map();
        this.proposalElements = /* @__PURE__ */ new Map();
        this.proposalCollaborators = /* @__PURE__ */ new Map();
        this.proposalComments = /* @__PURE__ */ new Map();
        this.proposalActivities = /* @__PURE__ */ new Map();
        this.productCategoriesMap = /* @__PURE__ */ new Map();
        this.products = /* @__PURE__ */ new Map();
        this.inventoryTransactions = /* @__PURE__ */ new Map();
        this.invoices = /* @__PURE__ */ new Map();
        this.invoiceItems = /* @__PURE__ */ new Map();
        this.purchaseOrders = /* @__PURE__ */ new Map();
        this.purchaseOrderItems = /* @__PURE__ */ new Map();
        this.modulePermissions = /* @__PURE__ */ new Map();
        this.rolePermissions = /* @__PURE__ */ new Map();
        this.userPermissions = /* @__PURE__ */ new Map();
        this.teams = /* @__PURE__ */ new Map();
        this.teamMembers = /* @__PURE__ */ new Map();
        this.assignments = /* @__PURE__ */ new Map();
        this.userIdCounter = 1;
        this.contactIdCounter = 1;
        this.accountIdCounter = 1;
        this.leadIdCounter = 1;
        this.opportunityIdCounter = 1;
        this.taskIdCounter = 1;
        this.eventIdCounter = 1;
        this.activityIdCounter = 1;
        this.subscriptionPackageIdCounter = 1;
        this.userSubscriptionIdCounter = 1;
        this.socialIntegrationIdCounter = 1;
        this.socialMessageIdCounter = 1;
        this.leadSourceIdCounter = 1;
        this.socialCampaignIdCounter = 1;
        this.apiKeyIdCounter = 1;
        this.workflowIdCounter = 1;
        this.proposalTemplateIdCounter = 1;
        this.proposalIdCounter = 1;
        this.proposalElementIdCounter = 1;
        this.proposalCollaboratorIdCounter = 1;
        this.proposalCommentIdCounter = 1;
        this.proposalActivityIdCounter = 1;
        this.productCategoryIdCounter = 1;
        this.productIdCounter = 1;
        this.inventoryTransactionIdCounter = 1;
        this.invoiceIdCounter = 1;
        this.invoiceItemIdCounter = 1;
        this.purchaseOrderIdCounter = 1;
        this.purchaseOrderItemIdCounter = 1;
        this.modulePermissionIdCounter = 1;
        this.rolePermissionIdCounter = 1;
        this.userPermissionIdCounter = 1;
        this.teamIdCounter = 1;
        this.teamMemberIdCounter = 1;
        this.assignmentIdCounter = 1;
        this.initializeData();
      }
      initializeData() {
        this.createUser({
          username: "admin",
          password: "password",
          firstName: "Admin",
          lastName: "User",
          email: "admin@averox.com",
          role: "Administrator",
          avatar: ""
        });
        this.createUser({
          username: "sales.manager",
          password: "password",
          firstName: "Sales",
          lastName: "Manager",
          email: "sales@averox.com",
          role: "Sales Manager",
          avatar: ""
        });
        const account1 = this.createAccount({
          name: "Acme Corporation",
          industry: "Technology",
          website: "https://acme.example.com",
          phone: "555-123-4567",
          billingAddress: "123 Main St",
          billingCity: "San Francisco",
          billingState: "CA",
          billingZip: "94105",
          billingCountry: "USA",
          ownerId: 1,
          annualRevenue: 5e6,
          employeeCount: 250,
          notes: "Major technology provider",
          isActive: true
        });
        const account2 = this.createAccount({
          name: "GlobalTech Inc.",
          industry: "Software",
          website: "https://globaltech.example.com",
          phone: "555-987-6543",
          billingAddress: "456 Market St",
          billingCity: "New York",
          billingState: "NY",
          billingZip: "10001",
          billingCountry: "USA",
          ownerId: 2,
          annualRevenue: 12e6,
          employeeCount: 500,
          notes: "Enterprise software solutions",
          isActive: true
        });
        this.createContact({
          firstName: "John",
          lastName: "Smith",
          email: "john.smith@acme.example.com",
          phone: "555-111-2222",
          title: "CTO",
          accountId: account1.id,
          ownerId: 1,
          address: "123 Main St",
          city: "San Francisco",
          state: "CA",
          zip: "94105",
          country: "USA",
          notes: "Key decision maker",
          isActive: true
        });
        this.createContact({
          firstName: "Jane",
          lastName: "Doe",
          email: "jane.doe@globaltech.example.com",
          phone: "555-333-4444",
          title: "Director of Sales",
          accountId: account2.id,
          ownerId: 2,
          address: "456 Market St",
          city: "New York",
          state: "NY",
          zip: "10001",
          country: "USA",
          notes: "Interested in our premium plan",
          isActive: true
        });
        this.initializePermissions().catch((error) => {
          console.error("Failed to initialize permissions:", error);
        });
      }
      // User Methods
      async getUser(id) {
        return this.users.get(id);
      }
      async getUserByUsername(username) {
        for (const user of this.users.values()) {
          if (user.username === username) {
            return user;
          }
        }
        return void 0;
      }
      async getUserByEmail(email) {
        for (const user of this.users.values()) {
          if (user.email === email) {
            return user;
          }
        }
        return void 0;
      }
      async createUser(insertUser) {
        const id = this.userIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const user = {
          ...insertUser,
          id,
          createdAt,
          isActive: true,
          isVerified: false,
          firstName: insertUser.firstName || null,
          lastName: insertUser.lastName || null,
          role: insertUser.role || "User",
          avatar: insertUser.avatar || null,
          lastLogin: null,
          company: null,
          packageId: null,
          stripeCustomerId: null,
          stripeSubscriptionId: null
        };
        this.users.set(id, user);
        return user;
      }
      async listUsers() {
        return Array.from(this.users.values());
      }
      async updateUser(id, userData) {
        const existingUser = this.users.get(id);
        if (!existingUser) {
          return void 0;
        }
        const updatedUser = {
          ...existingUser,
          ...userData
        };
        this.users.set(id, updatedUser);
        return updatedUser;
      }
      // Contact Methods
      async getContact(id) {
        return this.contacts.get(id);
      }
      async listContacts(filter) {
        let contacts2 = Array.from(this.contacts.values());
        if (filter) {
          contacts2 = contacts2.filter((contact) => {
            for (const [key, value] of Object.entries(filter)) {
              if (contact[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return contacts2;
      }
      async createContact(insertContact) {
        const id = this.contactIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const contact = {
          ...insertContact,
          id,
          createdAt,
          email: insertContact.email || null,
          phone: insertContact.phone || null,
          title: insertContact.title || null,
          accountId: insertContact.accountId || null,
          ownerId: insertContact.ownerId || null,
          address: insertContact.address || null,
          city: insertContact.city || null,
          state: insertContact.state || null,
          zip: insertContact.zip || null,
          country: insertContact.country || null,
          notes: insertContact.notes || null,
          isActive: insertContact.isActive === void 0 ? true : insertContact.isActive
        };
        this.contacts.set(id, contact);
        return contact;
      }
      async updateContact(id, contactData) {
        const existingContact = this.contacts.get(id);
        if (!existingContact) {
          return void 0;
        }
        const updatedContact = {
          ...existingContact,
          ...contactData
        };
        this.contacts.set(id, updatedContact);
        return updatedContact;
      }
      async deleteContact(id) {
        return this.contacts.delete(id);
      }
      // Account Methods
      async getAccount(id) {
        return this.accounts.get(id);
      }
      async listAccounts(filter) {
        let accounts2 = Array.from(this.accounts.values());
        if (filter) {
          accounts2 = accounts2.filter((account) => {
            for (const [key, value] of Object.entries(filter)) {
              if (account[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return accounts2;
      }
      async createAccount(insertAccount) {
        const id = this.accountIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const account = {
          ...insertAccount,
          id,
          createdAt,
          industry: insertAccount.industry || null,
          website: insertAccount.website || null,
          phone: insertAccount.phone || null,
          billingAddress: insertAccount.billingAddress || null,
          billingCity: insertAccount.billingCity || null,
          billingState: insertAccount.billingState || null,
          billingZip: insertAccount.billingZip || null,
          billingCountry: insertAccount.billingCountry || null,
          ownerId: insertAccount.ownerId || null,
          annualRevenue: insertAccount.annualRevenue || null,
          employeeCount: insertAccount.employeeCount || null,
          notes: insertAccount.notes || null,
          isActive: insertAccount.isActive === void 0 ? true : insertAccount.isActive
        };
        this.accounts.set(id, account);
        return account;
      }
      async updateAccount(id, accountData) {
        const existingAccount = this.accounts.get(id);
        if (!existingAccount) {
          return void 0;
        }
        const updatedAccount = {
          ...existingAccount,
          ...accountData
        };
        this.accounts.set(id, updatedAccount);
        return updatedAccount;
      }
      async deleteAccount(id) {
        return this.accounts.delete(id);
      }
      // Lead Methods
      async getLead(id) {
        return this.leads.get(id);
      }
      async listLeads(filter) {
        let leads2 = Array.from(this.leads.values());
        if (filter) {
          leads2 = leads2.filter((lead) => {
            for (const [key, value] of Object.entries(filter)) {
              if (lead[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return leads2;
      }
      async createLead(insertLead) {
        const id = this.leadIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const lead = {
          ...insertLead,
          id,
          createdAt,
          email: insertLead.email || null,
          phone: insertLead.phone || null,
          company: insertLead.company || null,
          title: insertLead.title || null,
          status: insertLead.status || "New",
          source: insertLead.source || null,
          ownerId: insertLead.ownerId || null,
          notes: insertLead.notes || null,
          isConverted: false,
          convertedToContactId: null,
          convertedToAccountId: null,
          convertedToOpportunityId: null
        };
        this.leads.set(id, lead);
        return lead;
      }
      async updateLead(id, leadData) {
        const existingLead = this.leads.get(id);
        if (!existingLead) {
          return void 0;
        }
        const updatedLead = {
          ...existingLead,
          ...leadData
        };
        this.leads.set(id, updatedLead);
        return updatedLead;
      }
      async deleteLead(id) {
        return this.leads.delete(id);
      }
      async convertLead(id, convertTo) {
        const lead = this.leads.get(id);
        if (!lead) {
          throw new Error(`Lead with ID ${id} not found`);
        }
        const result = {
          lead: { ...lead }
        };
        if (convertTo.contact) {
          const contactData = {
            ...convertTo.contact
          };
          if (!contactData.firstName) contactData.firstName = lead.firstName;
          if (!contactData.lastName) contactData.lastName = lead.lastName;
          if (!contactData.email) contactData.email = lead.email;
          if (!contactData.phone) contactData.phone = lead.phone;
          const contact = await this.createContact(contactData);
          result.contact = contact;
          lead.convertedToContactId = contact.id;
        }
        if (convertTo.account) {
          const accountData = {
            ...convertTo.account
          };
          if (!accountData.name && lead.company) accountData.name = lead.company;
          const account = await this.createAccount(accountData);
          result.account = account;
          lead.convertedToAccountId = account.id;
          if (result.contact && !result.contact.accountId) {
            const updatedContact = {
              ...result.contact,
              accountId: account.id
            };
            this.contacts.set(result.contact.id, updatedContact);
            result.contact = updatedContact;
          }
        }
        if (convertTo.opportunity) {
          const opportunityData = {
            ...convertTo.opportunity
          };
          if (!opportunityData.name && lead.company) {
            opportunityData.name = `${lead.company} Opportunity`;
          } else if (!opportunityData.name) {
            opportunityData.name = `${lead.firstName} ${lead.lastName} Opportunity`;
          }
          if (result.account && !opportunityData.accountId) {
            opportunityData.accountId = result.account.id;
          }
          const opportunity = await this.createOpportunity(opportunityData);
          result.opportunity = opportunity;
          lead.convertedToOpportunityId = opportunity.id;
        }
        lead.isConverted = true;
        this.leads.set(id, lead);
        result.lead = lead;
        return result;
      }
      // Opportunity Methods
      async getOpportunity(id) {
        return this.opportunities.get(id);
      }
      async listOpportunities(filter) {
        let opportunities2 = Array.from(this.opportunities.values());
        if (filter) {
          opportunities2 = opportunities2.filter((opportunity) => {
            for (const [key, value] of Object.entries(filter)) {
              if (opportunity[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return opportunities2;
      }
      async createOpportunity(insertOpportunity) {
        const id = this.opportunityIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const opportunity = {
          ...insertOpportunity,
          id,
          createdAt,
          accountId: insertOpportunity.accountId || null,
          stage: insertOpportunity.stage || "Lead Generation",
          amount: insertOpportunity.amount || null,
          expectedCloseDate: insertOpportunity.expectedCloseDate || null,
          probability: insertOpportunity.probability || null,
          ownerId: insertOpportunity.ownerId || null,
          notes: insertOpportunity.notes || null,
          isClosed: false,
          isWon: false
        };
        this.opportunities.set(id, opportunity);
        return opportunity;
      }
      async updateOpportunity(id, opportunityData) {
        const existingOpportunity = this.opportunities.get(id);
        if (!existingOpportunity) {
          return void 0;
        }
        const updatedOpportunity = {
          ...existingOpportunity,
          ...opportunityData
        };
        this.opportunities.set(id, updatedOpportunity);
        return updatedOpportunity;
      }
      async deleteOpportunity(id) {
        return this.opportunities.delete(id);
      }
      // Task Methods
      async getTask(id) {
        return this.tasks.get(id);
      }
      async listTasks(filter) {
        let tasks2 = Array.from(this.tasks.values());
        if (filter) {
          tasks2 = tasks2.filter((task) => {
            for (const [key, value] of Object.entries(filter)) {
              if (task[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return tasks2;
      }
      async createTask(insertTask) {
        const id = this.taskIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        let processedTask = { ...insertTask };
        if (typeof processedTask.reminderDate === "string") {
          processedTask.reminderDate = new Date(processedTask.reminderDate);
        }
        const task = {
          ...processedTask,
          id,
          createdAt,
          description: processedTask.description || null,
          dueDate: processedTask.dueDate || null,
          priority: processedTask.priority || "Normal",
          status: processedTask.status || "Not Started",
          ownerId: processedTask.ownerId || null,
          relatedToType: processedTask.relatedToType || null,
          relatedToId: processedTask.relatedToId || null,
          isReminder: processedTask.isReminder || false,
          reminderDate: processedTask.reminderDate || null
        };
        this.tasks.set(id, task);
        return task;
      }
      async updateTask(id, taskData) {
        const existingTask = this.tasks.get(id);
        if (!existingTask) {
          return void 0;
        }
        let processedData = { ...taskData };
        if (typeof processedData.reminderDate === "string") {
          processedData.reminderDate = new Date(processedData.reminderDate);
        }
        const updatedTask = {
          ...existingTask,
          ...processedData
        };
        this.tasks.set(id, updatedTask);
        return updatedTask;
      }
      async deleteTask(id) {
        return this.tasks.delete(id);
      }
      // Event Methods
      async getEvent(id) {
        return this.events.get(id);
      }
      async listEvents(filter) {
        let events2 = Array.from(this.events.values());
        if (filter) {
          events2 = events2.filter((event) => {
            for (const [key, value] of Object.entries(filter)) {
              if (event[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        events2.sort((a, b) => {
          if (!a.startDate) return 1;
          if (!b.startDate) return -1;
          const dateA = new Date(a.startDate).getTime();
          const dateB = new Date(b.startDate).getTime();
          return dateA - dateB;
        });
        return events2;
      }
      async createEvent(insertEvent) {
        const id = this.eventIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const startDate = typeof insertEvent.startDate === "string" ? new Date(insertEvent.startDate) : insertEvent.startDate;
        const endDate = typeof insertEvent.endDate === "string" ? new Date(insertEvent.endDate) : insertEvent.endDate;
        const event = {
          ...insertEvent,
          id,
          createdAt,
          startDate,
          endDate,
          description: insertEvent.description || null,
          location: insertEvent.location || null,
          locationType: insertEvent.locationType || "physical",
          eventType: insertEvent.eventType || "Meeting",
          status: insertEvent.status || "Confirmed",
          ownerId: insertEvent.ownerId || null,
          isAllDay: insertEvent.isAllDay || false,
          isRecurring: insertEvent.isRecurring || false,
          recurringRule: insertEvent.recurringRule || null
        };
        this.events.set(id, event);
        return event;
      }
      async updateEvent(id, eventData) {
        const existingEvent = this.events.get(id);
        if (!existingEvent) {
          return void 0;
        }
        let processedData = { ...eventData };
        if (typeof processedData.startDate === "string") {
          processedData.startDate = new Date(processedData.startDate);
        }
        if (typeof processedData.endDate === "string") {
          processedData.endDate = new Date(processedData.endDate);
        }
        const updatedEvent = {
          ...existingEvent,
          ...processedData
        };
        this.events.set(id, updatedEvent);
        return updatedEvent;
      }
      async deleteEvent(id) {
        return this.events.delete(id);
      }
      // Activity Methods
      async getActivity(id) {
        return this.activities.get(id);
      }
      async listActivities(filter) {
        let activities2 = Array.from(this.activities.values());
        if (filter) {
          activities2 = activities2.filter((activity) => {
            for (const [key, value] of Object.entries(filter)) {
              if (activity[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        activities2.sort((a, b) => {
          const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0;
          const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0;
          return bTime - aTime;
        });
        return activities2;
      }
      async createActivity(insertActivity) {
        const id = this.activityIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const activity = {
          ...insertActivity,
          id,
          createdAt,
          userId: insertActivity.userId || null,
          detail: insertActivity.detail || null,
          relatedToType: insertActivity.relatedToType || null,
          relatedToId: insertActivity.relatedToId || null,
          icon: insertActivity.icon || "added"
        };
        this.activities.set(id, activity);
        return activity;
      }
      // Dashboard Methods
      async getDashboardStats() {
        const leads2 = Array.from(this.leads.values());
        const opportunities2 = Array.from(this.opportunities.values());
        const newLeads = leads2.filter(
          (lead) => lead.status === "New" && lead.createdAt && new Date(lead.createdAt) >= new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
        ).length;
        const totalLeads = leads2.length;
        const convertedLeads = leads2.filter((lead) => lead.isConverted).length;
        const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads * 100).toFixed(1) : "0.0";
        const totalRevenue = opportunities2.filter((opp) => opp.isWon).reduce((sum, opp) => sum + parseFloat(opp.amount || "0"), 0);
        const revenue = totalRevenue.toLocaleString("en-US", {
          style: "currency",
          currency: "USD",
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
        const openDeals = opportunities2.filter((opp) => !opp.isClosed).length;
        return {
          newLeads,
          conversionRate: conversionRate + "%",
          revenue,
          openDeals
        };
      }
      async getSalesPipeline() {
        const opportunities2 = Array.from(this.opportunities.values());
        const stages = [
          "Lead Generation",
          "Qualification",
          "Proposal",
          "Negotiation",
          "Closing"
        ];
        const totalValue = opportunities2.reduce((sum, opp) => sum + parseFloat(opp.amount || "0"), 0);
        const pipelineData = stages.map((stageName) => {
          const stageOpps = opportunities2.filter((opp) => opp.stage === stageName);
          const stageValue = stageOpps.reduce((sum, opp) => sum + parseFloat(opp.amount || "0"), 0);
          const percentage = totalValue > 0 ? Math.round(stageValue / totalValue * 100) : 0;
          return {
            name: stageName,
            value: stageValue.toLocaleString("en-US", {
              style: "currency",
              currency: "USD",
              minimumFractionDigits: 0,
              maximumFractionDigits: 0
            }),
            percentage
          };
        });
        return { stages: pipelineData };
      }
      // Report Methods
      async getSalesReport(timeRange) {
        const opportunities2 = Array.from(this.opportunities.values());
        let startDate = /* @__PURE__ */ new Date();
        switch (timeRange) {
          case "week":
            startDate.setDate(startDate.getDate() - 7);
            break;
          case "month":
            startDate.setMonth(startDate.getMonth() - 1);
            break;
          case "quarter":
            startDate.setMonth(startDate.getMonth() - 3);
            break;
          case "year":
            startDate.setFullYear(startDate.getFullYear() - 1);
            break;
          default:
            startDate.setMonth(startDate.getMonth() - 1);
        }
        const filteredOpps = opportunities2.filter((opp) => {
          if (!opp.createdAt) return false;
          return new Date(opp.createdAt) >= startDate;
        });
        const months = timeRange === "year" ? 12 : timeRange === "quarter" ? 3 : 1;
        const monthlyData = [];
        for (let i = 0; i < months; i++) {
          const monthDate = /* @__PURE__ */ new Date();
          monthDate.setMonth(monthDate.getMonth() - i);
          const monthName = monthDate.toLocaleString("en-US", { month: "short" });
          const monthYear = monthDate.getFullYear();
          const monthOpps = filteredOpps.filter((opp) => {
            if (!opp.createdAt) return false;
            const oppDate = new Date(opp.createdAt);
            return oppDate.getMonth() === monthDate.getMonth() && oppDate.getFullYear() === monthDate.getFullYear();
          });
          const deals = monthOpps.length;
          const value = monthOpps.reduce((sum, opp) => sum + parseFloat(opp.amount || "0"), 0);
          monthlyData.unshift({
            name: `${monthName} ${monthYear}`,
            deals,
            value
          });
        }
        const stageNames = [
          "Lead Generation",
          "Qualification",
          "Proposal",
          "Negotiation",
          "Closing"
        ];
        const pipelineStages = stageNames.map((stage) => {
          const stageOpps = filteredOpps.filter((opp) => opp.stage === stage);
          const value = stageOpps.reduce((sum, opp) => sum + parseFloat(opp.amount || "0"), 0);
          return {
            name: stage,
            value
          };
        });
        return {
          monthlyData,
          pipelineStages
        };
      }
      async getLeadsReport(timeRange) {
        const leads2 = Array.from(this.leads.values());
        let startDate = /* @__PURE__ */ new Date();
        switch (timeRange) {
          case "week":
            startDate.setDate(startDate.getDate() - 7);
            break;
          case "month":
            startDate.setMonth(startDate.getMonth() - 1);
            break;
          case "quarter":
            startDate.setMonth(startDate.getMonth() - 3);
            break;
          case "year":
            startDate.setFullYear(startDate.getFullYear() - 1);
            break;
          default:
            startDate.setMonth(startDate.getMonth() - 1);
        }
        const filteredLeads = leads2.filter((lead) => {
          if (!lead.createdAt) return false;
          return new Date(lead.createdAt) >= startDate;
        });
        const sourceCounts = /* @__PURE__ */ new Map();
        filteredLeads.forEach((lead) => {
          const source = lead.source || "Unknown";
          sourceCounts.set(source, (sourceCounts.get(source) || 0) + 1);
        });
        const sourceData = Array.from(sourceCounts.entries()).map(([name, value]) => ({
          name,
          value
        }));
        sourceData.sort((a, b) => b.value - a.value);
        const periods = timeRange === "week" ? 6 : timeRange === "month" || timeRange === "quarter" ? 3 : 12;
        const periodType = timeRange === "week" ? "week" : "month";
        const trendData = [];
        for (let i = 0; i < periods; i++) {
          const periodDate = /* @__PURE__ */ new Date();
          if (periodType === "week") {
            periodDate.setDate(periodDate.getDate() - 7 * i);
            const startOfWeek = new Date(periodDate);
            startOfWeek.setDate(periodDate.getDate() - periodDate.getDay());
            startOfWeek.setHours(0, 0, 0, 0);
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);
            endOfWeek.setHours(23, 59, 59, 999);
            const weekLeads = leads2.filter((lead) => {
              if (!lead.createdAt) return false;
              const leadDate = new Date(lead.createdAt);
              return leadDate >= startOfWeek && leadDate <= endOfWeek;
            });
            const newLeads = weekLeads.length;
            const converted = weekLeads.filter((lead) => lead.isConverted).length;
            const startMonth = startOfWeek.toLocaleString("en-US", { month: "short" });
            const endMonth = endOfWeek.toLocaleString("en-US", { month: "short" });
            const weekName = startMonth === endMonth ? `${startMonth} ${startOfWeek.getDate()}-${endOfWeek.getDate()}` : `${startMonth} ${startOfWeek.getDate()}-${endMonth} ${endOfWeek.getDate()}`;
            trendData.unshift({
              name: weekName,
              newLeads,
              converted
            });
          } else {
            periodDate.setMonth(periodDate.getMonth() - i);
            const monthName = periodDate.toLocaleString("en-US", { month: "short" });
            const monthYear = periodDate.getFullYear();
            const monthLeads = leads2.filter((lead) => {
              if (!lead.createdAt) return false;
              const leadDate = new Date(lead.createdAt);
              return leadDate.getMonth() === periodDate.getMonth() && leadDate.getFullYear() === periodDate.getFullYear();
            });
            const newLeads = monthLeads.length;
            const converted = monthLeads.filter((lead) => lead.isConverted).length;
            trendData.unshift({
              name: `${monthName} ${monthYear}`,
              newLeads,
              converted
            });
          }
        }
        return {
          sourceData,
          trendData
        };
      }
      async getConversionReport(timeRange) {
        const leads2 = Array.from(this.leads.values());
        const opportunities2 = Array.from(this.opportunities.values());
        let currentStartDate = /* @__PURE__ */ new Date();
        let previousStartDate = /* @__PURE__ */ new Date();
        switch (timeRange) {
          case "week":
            currentStartDate.setDate(currentStartDate.getDate() - 7);
            previousStartDate.setDate(previousStartDate.getDate() - 14);
            break;
          case "month":
            currentStartDate.setMonth(currentStartDate.getMonth() - 1);
            previousStartDate.setMonth(previousStartDate.getMonth() - 2);
            break;
          case "quarter":
            currentStartDate.setMonth(currentStartDate.getMonth() - 3);
            previousStartDate.setMonth(previousStartDate.getMonth() - 6);
            break;
          case "year":
            currentStartDate.setFullYear(currentStartDate.getFullYear() - 1);
            previousStartDate.setFullYear(previousStartDate.getFullYear() - 2);
            break;
          default:
            currentStartDate.setMonth(currentStartDate.getMonth() - 1);
            previousStartDate.setMonth(previousStartDate.getMonth() - 2);
        }
        const currentPeriodLeads = leads2.filter((lead) => {
          if (!lead.createdAt) return false;
          const leadDate = new Date(lead.createdAt);
          return leadDate >= currentStartDate;
        });
        const previousPeriodLeads = leads2.filter((lead) => {
          if (!lead.createdAt) return false;
          const leadDate = new Date(lead.createdAt);
          return leadDate >= previousStartDate && leadDate < currentStartDate;
        });
        const currentConvertedCount = currentPeriodLeads.filter((lead) => lead.isConverted).length;
        const previousConvertedCount = previousPeriodLeads.filter((lead) => lead.isConverted).length;
        const conversionRate = currentPeriodLeads.length > 0 ? Math.round(currentConvertedCount / currentPeriodLeads.length * 100) : 0;
        const previousRate = previousPeriodLeads.length > 0 ? Math.round(previousConvertedCount / previousPeriodLeads.length * 100) : 0;
        const convertedLeads = currentPeriodLeads.filter(
          (lead) => lead.isConverted && lead.convertedToOpportunityId !== null
        );
        let totalDaysToConvert = 0;
        let convertedCount = 0;
        for (const lead of convertedLeads) {
          if (!lead.createdAt) continue;
          const opportunity = lead.convertedToOpportunityId ? opportunities2.find((opp) => opp.id === lead.convertedToOpportunityId) : null;
          if (opportunity && opportunity.createdAt) {
            const leadDate = new Date(lead.createdAt);
            const oppDate = new Date(opportunity.createdAt);
            const daysDiff = Math.floor((oppDate.getTime() - leadDate.getTime()) / (1e3 * 60 * 60 * 24));
            totalDaysToConvert += daysDiff;
            convertedCount++;
          }
        }
        const avgTimeToConvert = convertedCount > 0 ? Math.round(totalDaysToConvert / convertedCount) : 0;
        const prevConvertedLeads = previousPeriodLeads.filter(
          (lead) => lead.isConverted && lead.convertedToOpportunityId !== null
        );
        let prevTotalDaysToConvert = 0;
        let prevConvertedCount = 0;
        for (const lead of prevConvertedLeads) {
          if (!lead.createdAt) continue;
          const opportunity = lead.convertedToOpportunityId ? opportunities2.find((opp) => opp.id === lead.convertedToOpportunityId) : null;
          if (opportunity && opportunity.createdAt) {
            const leadDate = new Date(lead.createdAt);
            const oppDate = new Date(opportunity.createdAt);
            const daysDiff = Math.floor((oppDate.getTime() - leadDate.getTime()) / (1e3 * 60 * 60 * 24));
            prevTotalDaysToConvert += daysDiff;
            prevConvertedCount++;
          }
        }
        const previousTime = prevConvertedCount > 0 ? Math.round(prevTotalDaysToConvert / prevConvertedCount) : 0;
        const channelStats = /* @__PURE__ */ new Map();
        currentPeriodLeads.forEach((lead) => {
          const source = lead.source || "Unknown";
          if (!channelStats.has(source)) {
            channelStats.set(source, { total: 0, converted: 0 });
          }
          const stats = channelStats.get(source);
          stats.total++;
          if (lead.isConverted) {
            stats.converted++;
          }
        });
        let bestChannel = { name: "Unknown", rate: 0 };
        channelStats.forEach((stats, channel) => {
          if (stats.total >= 5) {
            const rate = Math.round(stats.converted / stats.total * 100);
            if (rate > bestChannel.rate) {
              bestChannel = {
                name: channel,
                rate
              };
            }
          }
        });
        const weeklyData = [];
        const weeksToShow = 6;
        for (let i = 0; i < weeksToShow; i++) {
          const weekEndDate = /* @__PURE__ */ new Date();
          weekEndDate.setDate(weekEndDate.getDate() - 7 * i);
          const weekStartDate = new Date(weekEndDate);
          weekStartDate.setDate(weekEndDate.getDate() - 6);
          const weekLeads = leads2.filter((lead) => {
            if (!lead.createdAt) return false;
            const leadDate = new Date(lead.createdAt);
            return leadDate >= weekStartDate && leadDate <= weekEndDate;
          });
          const newLeads = weekLeads.length;
          const converted = weekLeads.filter((lead) => lead.isConverted).length;
          const startMonth = weekStartDate.toLocaleString("en-US", { month: "short" });
          const endMonth = weekEndDate.toLocaleString("en-US", { month: "short" });
          const weekName = startMonth === endMonth ? `${startMonth} ${weekStartDate.getDate()}-${weekEndDate.getDate()}` : `${startMonth} ${weekStartDate.getDate()}-${endMonth} ${weekEndDate.getDate()}`;
          weeklyData.unshift({
            name: weekName,
            newLeads,
            converted
          });
        }
        return {
          conversionRate,
          previousRate,
          avgTimeToConvert,
          previousTime,
          bestChannel,
          weeklyData
        };
      }
      async getTeamPerformanceReport(timeRange) {
        const opportunities2 = Array.from(this.opportunities.values());
        const leads2 = Array.from(this.leads.values());
        const users2 = Array.from(this.users.values());
        const performanceByUser = /* @__PURE__ */ new Map();
        users2.forEach((user) => {
          if (user.id) {
            performanceByUser.set(user.id, {
              name: `${user.firstName || ""} ${user.lastName || ""}`.trim() || `User ${user.id}`,
              deals: 0,
              revenue: 0,
              leadsAssigned: 0,
              leadsConverted: 0
            });
          }
        });
        let startDate = /* @__PURE__ */ new Date();
        switch (timeRange) {
          case "week":
            startDate.setDate(startDate.getDate() - 7);
            break;
          case "month":
            startDate.setMonth(startDate.getMonth() - 1);
            break;
          case "quarter":
            startDate.setMonth(startDate.getMonth() - 3);
            break;
          case "year":
            startDate.setFullYear(startDate.getFullYear() - 1);
            break;
          default:
            startDate.setMonth(startDate.getMonth() - 1);
        }
        opportunities2.forEach((opp) => {
          if (!opp.ownerId || opp.createdAt && new Date(opp.createdAt) < startDate) {
            return;
          }
          const userPerf = performanceByUser.get(opp.ownerId);
          if (userPerf) {
            userPerf.deals += 1;
            userPerf.revenue += parseFloat(opp.amount || "0");
          }
        });
        leads2.forEach((lead) => {
          if (!lead.ownerId || lead.createdAt && new Date(lead.createdAt) < startDate) {
            return;
          }
          const userPerf = performanceByUser.get(lead.ownerId);
          if (userPerf) {
            userPerf.leadsAssigned += 1;
            if (lead.isConverted) {
              userPerf.leadsConverted += 1;
            }
          }
        });
        const teamMembers2 = Array.from(performanceByUser.values()).map((user) => {
          const conversion = user.leadsAssigned > 0 ? Math.round(user.leadsConverted / user.leadsAssigned * 100) : 0;
          return {
            name: user.name,
            deals: user.deals,
            revenue: user.revenue,
            conversion
          };
        });
        teamMembers2.sort((a, b) => b.revenue - a.revenue);
        return { teamMembers: teamMembers2 };
      }
      // Subscription Package Methods
      async getSubscriptionPackage(id) {
        return this.subscriptionPackages.get(id);
      }
      async listSubscriptionPackages(filter) {
        let packages = Array.from(this.subscriptionPackages.values());
        if (filter) {
          packages = packages.filter((pkg) => {
            for (const [key, value] of Object.entries(filter)) {
              if (pkg[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return packages.sort((a, b) => {
          if (a.displayOrder === null) return 1;
          if (b.displayOrder === null) return -1;
          return a.displayOrder - b.displayOrder;
        });
      }
      async createSubscriptionPackage(packageData) {
        const id = this.subscriptionPackageIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const subscriptionPackage = {
          ...packageData,
          id,
          createdAt,
          isActive: packageData.isActive ?? true,
          displayOrder: packageData.displayOrder ?? 0
        };
        this.subscriptionPackages.set(id, subscriptionPackage);
        return subscriptionPackage;
      }
      async updateSubscriptionPackage(id, packageData) {
        const existingPackage = this.subscriptionPackages.get(id);
        if (!existingPackage) {
          return void 0;
        }
        const updatedPackage = {
          ...existingPackage,
          ...packageData
        };
        this.subscriptionPackages.set(id, updatedPackage);
        return updatedPackage;
      }
      async deleteSubscriptionPackage(id) {
        return this.subscriptionPackages.delete(id);
      }
      // User Subscription Methods
      async getUserSubscription(id) {
        return this.userSubscriptions.get(id);
      }
      async getUserActiveSubscription(userId) {
        const userSubscriptions3 = Array.from(this.userSubscriptions.values());
        return userSubscriptions3.find(
          (sub) => sub.userId === userId && sub.status === "Active" && (!sub.endDate || new Date(sub.endDate) > /* @__PURE__ */ new Date())
        );
      }
      async listUserSubscriptions(filter) {
        let subscriptions = Array.from(this.userSubscriptions.values());
        if (filter) {
          subscriptions = subscriptions.filter((sub) => {
            for (const [key, value] of Object.entries(filter)) {
              if (sub[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return subscriptions.sort((a, b) => {
          const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
          const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
          return dateB - dateA;
        });
      }
      async createUserSubscription(subscriptionData) {
        const id = this.userSubscriptionIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const startDate = new Date(subscriptionData.startDate);
        const endDate = subscriptionData.endDate ? new Date(subscriptionData.endDate) : void 0;
        const userSubscription = {
          ...subscriptionData,
          id,
          createdAt,
          startDate,
          endDate,
          status: subscriptionData.status || "Pending"
        };
        this.userSubscriptions.set(id, userSubscription);
        return userSubscription;
      }
      async updateUserSubscription(id, subscriptionData) {
        const existingSubscription = this.userSubscriptions.get(id);
        if (!existingSubscription) {
          return void 0;
        }
        let updatedSubscription = {
          ...existingSubscription
        };
        if (subscriptionData.startDate) {
          updatedSubscription.startDate = new Date(subscriptionData.startDate);
        }
        if (subscriptionData.endDate) {
          updatedSubscription.endDate = new Date(subscriptionData.endDate);
        }
        updatedSubscription = {
          ...updatedSubscription,
          ...subscriptionData
        };
        this.userSubscriptions.set(id, updatedSubscription);
        return updatedSubscription;
      }
      async cancelUserSubscription(id) {
        const subscription = this.userSubscriptions.get(id);
        if (!subscription) {
          return void 0;
        }
        const updatedSubscription = {
          ...subscription,
          status: "Canceled",
          canceledAt: /* @__PURE__ */ new Date()
        };
        this.userSubscriptions.set(id, updatedSubscription);
        return updatedSubscription;
      }
      async deleteUserSubscription(id) {
        if (!this.userSubscriptions.has(id)) {
          return false;
        }
        return this.userSubscriptions.delete(id);
      }
      // User Account Management Methods
      async updateUserStripeInfo(userId, stripeInfo) {
        const user = this.users.get(userId);
        if (!user) {
          return void 0;
        }
        const updatedUser = {
          ...user,
          stripeCustomerId: stripeInfo.stripeCustomerId,
          stripeSubscriptionId: stripeInfo.stripeSubscriptionId
        };
        this.users.set(userId, updatedUser);
        return updatedUser;
      }
      async updateStripeCustomerId(userId, stripeCustomerId) {
        const user = this.users.get(userId);
        if (!user) {
          return void 0;
        }
        const updatedUser = {
          ...user,
          stripeCustomerId
        };
        this.users.set(userId, updatedUser);
        return updatedUser;
      }
      // Workflow Methods
      async getWorkflow(id) {
        return this.workflows.get(id);
      }
      // Product Category Methods
      async getProductCategory(id) {
        return this.productCategoriesMap.get(id);
      }
      async listProductCategories(filter) {
        let categories = Array.from(this.productCategoriesMap.values());
        if (filter) {
          categories = categories.filter((category) => {
            for (const [key, value] of Object.entries(filter)) {
              if (category[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return categories;
      }
      async createProductCategory(insertProductCategory) {
        const id = this.productCategoryIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const productCategory = {
          ...insertProductCategory,
          id,
          createdAt,
          parentCategoryId: insertProductCategory.parentCategoryId || null,
          description: insertProductCategory.description || null,
          isActive: insertProductCategory.isActive === void 0 ? true : insertProductCategory.isActive
        };
        this.productCategoriesMap.set(id, productCategory);
        return productCategory;
      }
      async updateProductCategory(id, categoryData) {
        const existingCategory = this.productCategoriesMap.get(id);
        if (!existingCategory) {
          return void 0;
        }
        const updatedCategory = {
          ...existingCategory,
          ...categoryData
        };
        this.productCategoriesMap.set(id, updatedCategory);
        return updatedCategory;
      }
      async deleteProductCategory(id) {
        return this.productCategoriesMap.delete(id);
      }
      // Product Methods
      async getProduct(id) {
        return this.products.get(id);
      }
      async listProducts(filter) {
        let products2 = Array.from(this.products.values());
        if (filter) {
          products2 = products2.filter((product) => {
            for (const [key, value] of Object.entries(filter)) {
              if (product[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return products2;
      }
      async createProduct(insertProduct) {
        const id = this.productIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const product = {
          ...insertProduct,
          id,
          createdAt,
          categoryId: insertProduct.categoryId || null,
          description: insertProduct.description || null,
          sku: insertProduct.sku || null,
          price: insertProduct.price || null,
          cost: insertProduct.cost || null,
          quantity: insertProduct.quantity || 0,
          imageUrl: insertProduct.imageUrl || null,
          isActive: insertProduct.isActive === void 0 ? true : insertProduct.isActive,
          createdBy: insertProduct.createdBy || null,
          updatedBy: insertProduct.updatedBy || null,
          updatedAt: null
        };
        this.products.set(id, product);
        return product;
      }
      async updateProduct(id, productData) {
        const existingProduct = this.products.get(id);
        if (!existingProduct) {
          return void 0;
        }
        const updatedProduct = {
          ...existingProduct,
          ...productData,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.products.set(id, updatedProduct);
        return updatedProduct;
      }
      async deleteProduct(id) {
        return this.products.delete(id);
      }
      async getProductInventory(productId) {
        let totalQuantity = 0;
        for (const transaction of this.inventoryTransactions.values()) {
          if (transaction.productId === productId) {
            if (["Purchase", "Return", "Adjustment"].includes(transaction.type)) {
              totalQuantity += parseInt(transaction.quantity);
            } else {
              totalQuantity -= parseInt(transaction.quantity);
            }
          }
        }
        return totalQuantity;
      }
      async getProductInventoryHistory(productId) {
        const transactions = Array.from(this.inventoryTransactions.values()).filter((transaction) => transaction.productId === productId).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        return transactions;
      }
      async getInventorySummary() {
        const allProducts = Array.from(this.products.values());
        const productsWithStock = await Promise.all(
          allProducts.map(async (product) => {
            const stock = await this.getProductInventory(product.id);
            const price = typeof product.price === "string" ? parseFloat(product.price) : product.price || 0;
            return {
              id: product.id,
              name: product.name,
              sku: product.sku || "",
              stock,
              value: stock * price
            };
          })
        );
        return { products: productsWithStock };
      }
      // Inventory Transaction Methods
      async getInventoryTransaction(id) {
        return this.inventoryTransactions.get(id);
      }
      async listInventoryTransactions(filter) {
        let transactions = Array.from(this.inventoryTransactions.values());
        if (filter) {
          transactions = transactions.filter((transaction) => {
            for (const [key, value] of Object.entries(filter)) {
              if (transaction[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return transactions;
      }
      async createInventoryTransaction(insertTransaction) {
        const id = this.inventoryTransactionIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const transaction = {
          ...insertTransaction,
          id,
          createdAt,
          notes: insertTransaction.notes || null,
          referenceId: insertTransaction.referenceId || null,
          createdBy: insertTransaction.createdBy || null
        };
        if (transaction.productId) {
          const product = this.products.get(transaction.productId);
          if (product) {
            let newQuantity = product.quantity || 0;
            switch (transaction.type) {
              case "Purchase":
              case "Return":
                newQuantity += transaction.quantity;
                break;
              case "Sale":
              case "Adjustment":
                newQuantity -= transaction.quantity;
                break;
              case "Transfer":
                break;
            }
            this.updateProduct(product.id, { quantity: newQuantity });
          }
        }
        this.inventoryTransactions.set(id, transaction);
        return transaction;
      }
      async updateInventoryTransaction(id, transactionData) {
        const existingTransaction = this.inventoryTransactions.get(id);
        if (!existingTransaction) {
          return void 0;
        }
        const { productId, quantity, type, ...allowedChanges } = transactionData;
        const updatedTransaction = {
          ...existingTransaction,
          ...allowedChanges
        };
        this.inventoryTransactions.set(id, updatedTransaction);
        return updatedTransaction;
      }
      async deleteInventoryTransaction(id) {
        return false;
      }
      // Invoice Methods
      async getInvoice(id) {
        return this.invoices.get(id);
      }
      async listInvoices(filter) {
        let invoices2 = Array.from(this.invoices.values());
        if (filter) {
          invoices2 = invoices2.filter((invoice) => {
            for (const [key, value] of Object.entries(filter)) {
              if (invoice[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return invoices2;
      }
      async createInvoice(insertInvoice) {
        const id = this.invoiceIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const invoice = {
          ...insertInvoice,
          id,
          createdAt,
          accountId: insertInvoice.accountId || null,
          contactId: insertInvoice.contactId || null,
          billingAddress: insertInvoice.billingAddress || null,
          shippingAddress: insertInvoice.shippingAddress || null,
          notes: insertInvoice.notes || null,
          dueDate: insertInvoice.dueDate || null,
          subtotal: insertInvoice.subtotal || 0,
          taxAmount: insertInvoice.taxAmount || 0,
          discountAmount: insertInvoice.discountAmount || 0,
          totalAmount: insertInvoice.totalAmount || 0,
          paidAmount: insertInvoice.paidAmount || 0,
          paymentDate: insertInvoice.paymentDate || null,
          paymentMethod: insertInvoice.paymentMethod || null,
          createdBy: insertInvoice.createdBy || null,
          updatedBy: insertInvoice.updatedBy || null,
          updatedAt: null
        };
        this.invoices.set(id, invoice);
        return invoice;
      }
      async updateInvoice(id, invoiceData) {
        const existingInvoice = this.invoices.get(id);
        if (!existingInvoice) {
          return void 0;
        }
        const updatedInvoice = {
          ...existingInvoice,
          ...invoiceData,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.invoices.set(id, updatedInvoice);
        return updatedInvoice;
      }
      async deleteInvoice(id) {
        return this.invoices.delete(id);
      }
      // Invoice Item Methods
      async getInvoiceItem(id) {
        return this.invoiceItems.get(id);
      }
      async listInvoiceItems(invoiceId) {
        const allItems = Array.from(this.invoiceItems.values());
        return allItems.filter((item) => item.invoiceId === invoiceId);
      }
      async createInvoiceItem(insertInvoiceItem) {
        const id = this.invoiceItemIdCounter++;
        const invoiceItem = {
          ...insertInvoiceItem,
          id,
          discount: insertInvoiceItem.discount || 0,
          taxRate: insertInvoiceItem.taxRate || 0,
          taxAmount: insertInvoiceItem.taxAmount || 0,
          createdAt: /* @__PURE__ */ new Date()
        };
        this.invoiceItems.set(id, invoiceItem);
        const invoice = this.invoices.get(invoiceItem.invoiceId);
        if (invoice) {
          const items = await this.listInvoiceItems(invoice.id);
          const subtotal = items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
          const taxAmount = items.reduce((sum, item) => sum + (item.taxAmount || 0), 0);
          const discountAmount = items.reduce((sum, item) => {
            const itemDiscount = item.discount || 0;
            return sum + item.quantity * item.unitPrice * itemDiscount / 100;
          }, 0);
          const totalAmount = subtotal + taxAmount - discountAmount;
          await this.updateInvoice(invoice.id, {
            subtotal,
            taxAmount,
            discountAmount,
            totalAmount
          });
        }
        return invoiceItem;
      }
      async updateInvoiceItem(id, itemData) {
        const existingItem = this.invoiceItems.get(id);
        if (!existingItem) {
          return void 0;
        }
        const updatedItem = {
          ...existingItem,
          ...itemData
        };
        this.invoiceItems.set(id, updatedItem);
        const invoice = this.invoices.get(updatedItem.invoiceId);
        if (invoice) {
          const items = await this.listInvoiceItems(invoice.id);
          const subtotal = items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
          const taxAmount = items.reduce((sum, item) => sum + (item.taxAmount || 0), 0);
          const discountAmount = items.reduce((sum, item) => {
            const itemDiscount = item.discount || 0;
            return sum + item.quantity * item.unitPrice * itemDiscount / 100;
          }, 0);
          const totalAmount = subtotal + taxAmount - discountAmount;
          await this.updateInvoice(invoice.id, {
            subtotal,
            taxAmount,
            discountAmount,
            totalAmount
          });
        }
        return updatedItem;
      }
      async deleteInvoiceItem(id) {
        const item = this.invoiceItems.get(id);
        if (!item) {
          return false;
        }
        const invoiceId = item.invoiceId;
        const deleted = this.invoiceItems.delete(id);
        if (deleted) {
          const invoice = this.invoices.get(invoiceId);
          if (invoice) {
            const items = await this.listInvoiceItems(invoice.id);
            const subtotal = items.reduce((sum, item2) => sum + item2.quantity * item2.unitPrice, 0);
            const taxAmount = items.reduce((sum, item2) => sum + (item2.taxAmount || 0), 0);
            const discountAmount = items.reduce((sum, item2) => {
              const itemDiscount = item2.discount || 0;
              return sum + item2.quantity * item2.unitPrice * itemDiscount / 100;
            }, 0);
            const totalAmount = subtotal + taxAmount - discountAmount;
            await this.updateInvoice(invoice.id, {
              subtotal,
              taxAmount,
              discountAmount,
              totalAmount
            });
          }
        }
        return deleted;
      }
      // Purchase Order Methods
      async getPurchaseOrder(id) {
        return this.purchaseOrders.get(id);
      }
      async listPurchaseOrders(filter) {
        let orders = Array.from(this.purchaseOrders.values());
        if (filter) {
          orders = orders.filter((order) => {
            for (const [key, value] of Object.entries(filter)) {
              if (order[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return orders;
      }
      async createPurchaseOrder(insertPurchaseOrder) {
        const id = this.purchaseOrderIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const purchaseOrder = {
          ...insertPurchaseOrder,
          id,
          createdAt,
          vendorId: insertPurchaseOrder.vendorId || null,
          expectedDeliveryDate: insertPurchaseOrder.expectedDeliveryDate || null,
          deliveryAddress: insertPurchaseOrder.deliveryAddress || null,
          notes: insertPurchaseOrder.notes || null,
          subtotal: insertPurchaseOrder.subtotal || 0,
          taxAmount: insertPurchaseOrder.taxAmount || 0,
          discountAmount: insertPurchaseOrder.discountAmount || 0,
          totalAmount: insertPurchaseOrder.totalAmount || 0,
          createdBy: insertPurchaseOrder.createdBy || null,
          updatedBy: insertPurchaseOrder.updatedBy || null,
          updatedAt: null
        };
        this.purchaseOrders.set(id, purchaseOrder);
        return purchaseOrder;
      }
      async updatePurchaseOrder(id, orderData) {
        const existingOrder = this.purchaseOrders.get(id);
        if (!existingOrder) {
          return void 0;
        }
        const updatedOrder = {
          ...existingOrder,
          ...orderData,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.purchaseOrders.set(id, updatedOrder);
        return updatedOrder;
      }
      async deletePurchaseOrder(id) {
        return this.purchaseOrders.delete(id);
      }
      // Purchase Order Item Methods
      async getPurchaseOrderItem(id) {
        return this.purchaseOrderItems.get(id);
      }
      async listPurchaseOrderItems(orderId) {
        const allItems = Array.from(this.purchaseOrderItems.values());
        return allItems.filter((item) => item.purchaseOrderId === orderId);
      }
      async createPurchaseOrderItem(insertItem) {
        const id = this.purchaseOrderItemIdCounter++;
        const orderItem = {
          ...insertItem,
          id,
          receivedQuantity: insertItem.receivedQuantity || 0,
          notes: insertItem.notes || null,
          createdAt: /* @__PURE__ */ new Date()
        };
        this.purchaseOrderItems.set(id, orderItem);
        const order = this.purchaseOrders.get(orderItem.purchaseOrderId);
        if (order) {
          const items = await this.listPurchaseOrderItems(order.id);
          const subtotal = items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
          const totalAmount = subtotal;
          await this.updatePurchaseOrder(order.id, {
            subtotal,
            totalAmount
          });
        }
        return orderItem;
      }
      async updatePurchaseOrderItem(id, itemData) {
        const existingItem = this.purchaseOrderItems.get(id);
        if (!existingItem) {
          return void 0;
        }
        const updatedItem = {
          ...existingItem,
          ...itemData
        };
        this.purchaseOrderItems.set(id, updatedItem);
        const order = this.purchaseOrders.get(updatedItem.purchaseOrderId);
        if (order) {
          const items = await this.listPurchaseOrderItems(order.id);
          const subtotal = items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
          const totalAmount = subtotal;
          await this.updatePurchaseOrder(order.id, {
            subtotal,
            totalAmount
          });
        }
        return updatedItem;
      }
      async deletePurchaseOrderItem(id) {
        const item = this.purchaseOrderItems.get(id);
        if (!item) {
          return false;
        }
        const orderId = item.purchaseOrderId;
        const deleted = this.purchaseOrderItems.delete(id);
        if (deleted) {
          const order = this.purchaseOrders.get(orderId);
          if (order) {
            const items = await this.listPurchaseOrderItems(order.id);
            const subtotal = items.reduce((sum, item2) => sum + item2.quantity * item2.unitPrice, 0);
            const totalAmount = subtotal;
            await this.updatePurchaseOrder(order.id, {
              subtotal,
              totalAmount
            });
          }
        }
        return deleted;
      }
      // Receive Purchase Order Items
      async receivePurchaseOrderItems(orderId, receivedItems) {
        const order = this.purchaseOrders.get(orderId);
        if (!order) {
          return false;
        }
        for (const received of receivedItems) {
          const item = this.purchaseOrderItems.get(received.itemId);
          if (item && item.purchaseOrderId === orderId) {
            const newReceivedQuantity = (item.receivedQuantity || 0) + received.quantity;
            await this.updatePurchaseOrderItem(item.itemId, { receivedQuantity: newReceivedQuantity });
            if (item.productId) {
              await this.createInventoryTransaction({
                productId: item.productId,
                quantity: typeof received.quantity === "number" ? received.quantity.toString() : received.quantity,
                type: "Purchase",
                date: /* @__PURE__ */ new Date(),
                referenceId: orderId,
                // Use numeric ID
                referenceType: "purchase-order",
                // Specify the type in referenceType
                notes: `Received from purchase order #${orderId}`
              });
            }
          }
        }
        const allItems = await this.listPurchaseOrderItems(orderId);
        const allReceived = allItems.every((item) => (item.receivedQuantity || 0) >= item.quantity);
        const partiallyReceived = allItems.some((item) => (item.receivedQuantity || 0) > 0);
        let newStatus;
        if (allReceived) {
          newStatus = "Received";
        } else if (partiallyReceived) {
          newStatus = "Partially Received";
        }
        if (newStatus) {
          await this.updatePurchaseOrder(orderId, { status: newStatus });
        }
        return true;
      }
      // Proposal Template Methods
      async getProposalTemplate(id) {
        return this.proposalTemplates.get(id);
      }
      async listProposalTemplates() {
        return Array.from(this.proposalTemplates.values());
      }
      async createProposalTemplate(template) {
        const id = this.proposalTemplateIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const proposalTemplate = {
          ...template,
          id,
          createdAt,
          updatedAt: createdAt,
          isActive: template.isActive === void 0 ? true : template.isActive
        };
        this.proposalTemplates.set(id, proposalTemplate);
        return proposalTemplate;
      }
      async updateProposalTemplate(id, template) {
        const existingTemplate = this.proposalTemplates.get(id);
        if (!existingTemplate) {
          return void 0;
        }
        const updatedTemplate = {
          ...existingTemplate,
          ...template,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.proposalTemplates.set(id, updatedTemplate);
        return updatedTemplate;
      }
      async deleteProposalTemplate(id) {
        return this.proposalTemplates.delete(id);
      }
      // Proposal Methods
      async getProposal(id) {
        return this.proposals.get(id);
      }
      async listProposals(filter) {
        let proposals2 = Array.from(this.proposals.values());
        if (filter) {
          proposals2 = proposals2.filter((proposal) => {
            for (const [key, value] of Object.entries(filter)) {
              if (proposal[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return proposals2;
      }
      async createProposal(proposal) {
        const id = this.proposalIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const newProposal = {
          ...proposal,
          id,
          createdAt,
          updatedAt: createdAt,
          status: proposal.status || "Draft"
        };
        this.proposals.set(id, newProposal);
        return newProposal;
      }
      async updateProposal(id, proposal) {
        const existingProposal = this.proposals.get(id);
        if (!existingProposal) {
          return void 0;
        }
        const updatedProposal = {
          ...existingProposal,
          ...proposal,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.proposals.set(id, updatedProposal);
        return updatedProposal;
      }
      async deleteProposal(id) {
        return this.proposals.delete(id);
      }
      // Proposal Element Methods
      async getProposalElement(id) {
        return this.proposalElements.get(id);
      }
      async listProposalElements(proposalId) {
        const elements = Array.from(this.proposalElements.values()).filter((element) => element.proposalId === proposalId).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        return elements;
      }
      async createProposalElement(element) {
        const id = this.proposalElementIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        let sortOrder = element.sortOrder;
        if (sortOrder === void 0) {
          const existingElements = await this.listProposalElements(element.proposalId);
          sortOrder = existingElements.length > 0 ? Math.max(...existingElements.map((e) => e.sortOrder || 0)) + 10 : 10;
        }
        const proposalElement = {
          ...element,
          id,
          createdAt,
          updatedAt: createdAt,
          sortOrder
        };
        this.proposalElements.set(id, proposalElement);
        return proposalElement;
      }
      async updateProposalElement(id, element) {
        const existingElement = this.proposalElements.get(id);
        if (!existingElement) {
          return void 0;
        }
        const updatedElement = {
          ...existingElement,
          ...element,
          updatedAt: /* @__PURE__ */ new Date()
        };
        this.proposalElements.set(id, updatedElement);
        return updatedElement;
      }
      async deleteProposalElement(id) {
        return this.proposalElements.delete(id);
      }
      // Proposal Collaborator Methods
      async getProposalCollaborator(id) {
        return this.proposalCollaborators.get(id);
      }
      async getProposalCollaborators(proposalId) {
        const collaborators = Array.from(this.proposalCollaborators.values()).filter((collab) => collab.proposalId === proposalId);
        return Promise.all(collaborators.map(async (collab) => {
          const user = await this.getUser(collab.userId);
          return { ...collab, user };
        }));
      }
      async addProposalCollaborator(collaborator) {
        const id = this.proposalCollaboratorIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const proposalCollaborator = {
          ...collaborator,
          id,
          createdAt
        };
        this.proposalCollaborators.set(id, proposalCollaborator);
        return proposalCollaborator;
      }
      async updateProposalCollaborator(id, collaborator) {
        const existingCollaborator = this.proposalCollaborators.get(id);
        if (!existingCollaborator) {
          return void 0;
        }
        const updatedCollaborator = {
          ...existingCollaborator,
          ...collaborator
        };
        this.proposalCollaborators.set(id, updatedCollaborator);
        return updatedCollaborator;
      }
      async deleteProposalCollaborator(id) {
        return this.proposalCollaborators.delete(id);
      }
      // Proposal Comment Methods
      async getProposalComment(id) {
        return this.proposalComments.get(id);
      }
      async getProposalComments(proposalId) {
        const comments = Array.from(this.proposalComments.values()).filter((comment) => comment.proposalId === proposalId).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        return Promise.all(comments.map(async (comment) => {
          const user = await this.getUser(comment.userId);
          return { ...comment, user };
        }));
      }
      async createProposalComment(comment) {
        const id = this.proposalCommentIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const proposalComment = {
          ...comment,
          id,
          createdAt
        };
        this.proposalComments.set(id, proposalComment);
        return proposalComment;
      }
      async updateProposalComment(id, comment) {
        const existingComment = this.proposalComments.get(id);
        if (!existingComment) {
          return void 0;
        }
        const updatedComment = {
          ...existingComment,
          ...comment
        };
        this.proposalComments.set(id, updatedComment);
        return updatedComment;
      }
      async deleteProposalComment(id) {
        return this.proposalComments.delete(id);
      }
      // Proposal Activity Methods
      async createProposalActivity(activity) {
        const id = this.proposalActivityIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const normalizedActivity = {
          ...activity,
          // If old field names are used, map them to new field names
          activityType: activity.activityType || activity["action"],
          description: activity.description || activity["detail"]
        };
        if ("action" in normalizedActivity) delete normalizedActivity["action"];
        if ("detail" in normalizedActivity) delete normalizedActivity["detail"];
        const proposalActivity = {
          ...normalizedActivity,
          id,
          createdAt
        };
        this.proposalActivities.set(id, proposalActivity);
        return proposalActivity;
      }
      async getProposalActivities(proposalId) {
        const activities2 = Array.from(this.proposalActivities.values()).filter((activity) => activity.proposalId === proposalId).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        return Promise.all(activities2.map(async (activity) => {
          const user = activity.userId ? await this.getUser(activity.userId) : void 0;
          return { ...activity, user };
        }));
      }
      async listWorkflows(filter) {
        let workflows2 = Array.from(this.workflows.values());
        if (filter) {
          workflows2 = workflows2.filter((workflow) => {
            for (const [key, value] of Object.entries(filter)) {
              if (workflow[key] !== value) {
                return false;
              }
            }
            return true;
          });
        }
        return workflows2;
      }
      async createWorkflow(insertWorkflow) {
        const id = this.workflowIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const workflow = {
          ...insertWorkflow,
          id,
          createdAt,
          name: insertWorkflow.name,
          description: insertWorkflow.description || null,
          status: insertWorkflow.status || "Draft",
          steps: insertWorkflow.steps || [],
          triggerType: insertWorkflow.triggerType || null,
          triggerConfig: insertWorkflow.triggerConfig || null,
          ownerId: insertWorkflow.ownerId || null,
          lastExecuted: null,
          isActive: insertWorkflow.isActive === void 0 ? true : insertWorkflow.isActive,
          isTemplate: insertWorkflow.isTemplate === void 0 ? false : insertWorkflow.isTemplate
        };
        this.workflows.set(id, workflow);
        return workflow;
      }
      async updateWorkflow(id, workflowData) {
        const existingWorkflow = this.workflows.get(id);
        if (!existingWorkflow) {
          return void 0;
        }
        const updatedWorkflow = {
          ...existingWorkflow,
          ...workflowData
        };
        this.workflows.set(id, updatedWorkflow);
        return updatedWorkflow;
      }
      async deleteWorkflow(id) {
        return this.workflows.delete(id);
      }
    };
    DatabaseStorage = class {
      // Session store for authentication
      sessionStore;
      systemSettingsMap;
      constructor() {
        this.sessionStore = new PostgresSessionStore({
          pool,
          tableName: "session",
          // Name of the table to store sessions
          createTableIfMissing: true
          // Automatically create the session table if it doesn't exist
        });
        this.systemSettingsMap = /* @__PURE__ */ new Map();
      }
      // Implement all methods from IStorage interface with database queries
      // User Methods
      async getUser(id) {
        try {
          const [user] = await db.select().from(users).where(eq5(users.id, id));
          return user;
        } catch (error) {
          console.error("Database error in getUser:", error);
          return void 0;
        }
      }
      async getUserByUsername(username) {
        try {
          console.log("Searching for user with username:", username);
          const result = await db.select().from(users).where(eq5(users.username, username));
          console.log("Database result:", JSON.stringify(result));
          if (result.length === 0) {
            console.log("No user found with username:", username);
            return void 0;
          }
          const [user] = result;
          console.log("Found user:", user.id, user.username);
          return user;
        } catch (error) {
          console.error("Database error in getUserByUsername:", error);
          return void 0;
        }
      }
      async getUserByEmail(email) {
        try {
          const [user] = await db.select().from(users).where(eq5(users.email, email));
          return user;
        } catch (error) {
          console.error("Database error in getUserByEmail:", error);
          return void 0;
        }
      }
      async createUser(insertUser) {
        try {
          const [user] = await db.insert(users).values({
            ...insertUser,
            createdAt: /* @__PURE__ */ new Date(),
            isActive: true,
            isVerified: false
          }).returning();
          return user;
        } catch (error) {
          console.error("Database error in createUser:", error);
          throw error;
        }
      }
      async listUsers() {
        try {
          return await db.select().from(users);
        } catch (error) {
          console.error("Database error in listUsers:", error);
          return [];
        }
      }
      async updateUser(id, userData) {
        try {
          const [updatedUser] = await db.update(users).set(userData).where(eq5(users.id, id)).returning();
          return updatedUser;
        } catch (error) {
          console.error("Database error in updateUser:", error);
          return void 0;
        }
      }
      // User-Stripe methods
      async updateUserStripeInfo(userId, stripeInfo) {
        try {
          const [updatedUser] = await db.update(users).set({
            stripeCustomerId: stripeInfo.stripeCustomerId,
            stripeSubscriptionId: stripeInfo.stripeSubscriptionId
          }).where(eq5(users.id, userId)).returning();
          return updatedUser;
        } catch (error) {
          console.error("Database error in updateUserStripeInfo:", error);
          return void 0;
        }
      }
      async updateStripeCustomerId(userId, stripeCustomerId) {
        try {
          const [updatedUser] = await db.update(users).set({ stripeCustomerId }).where(eq5(users.id, userId)).returning();
          return updatedUser;
        } catch (error) {
          console.error("Database error in updateStripeCustomerId:", error);
          return void 0;
        }
      }
      // Placeholder methods to satisfy IStorage - implement as needed
      // These would be implemented with proper database queries like the ones above
      // For each entity (contacts, accounts, leads, etc.)
      // Contact Methods
      async getContact(id) {
        try {
          const [contact] = await db.select().from(contacts).where(eq5(contacts.id, id));
          if (!contact) return void 0;
          const decryptField = async (fieldValue) => {
            if (!fieldValue || typeof fieldValue !== "string" || !fieldValue.includes('"encrypted"')) {
              return fieldValue || null;
            }
            try {
              const encryptedData = JSON.parse(fieldValue);
              if (encryptedData.encrypted && encryptedData.iv && encryptedData.keyId) {
                const { decrypt: decrypt2 } = await import("../utils/encryption");
                return await decrypt2(encryptedData.encrypted, encryptedData.iv, encryptedData.keyId);
              }
            } catch (e) {
              console.warn("Failed to decrypt field:", e);
            }
            return fieldValue || null;
          };
          const decryptedContact = { ...contact };
          decryptedContact.email = await decryptField(contact.email);
          decryptedContact.phone = await decryptField(contact.phone);
          decryptedContact.address = await decryptField(contact.address);
          decryptedContact.notes = await decryptField(contact.notes);
          return decryptedContact;
        } catch (error) {
          console.error("Database error in getContact:", error);
          return void 0;
        }
      }
      async listContacts(filter) {
        try {
          const allContacts = await db.select().from(contacts);
          const { cryptoSphere: cryptoSphere2 } = await Promise.resolve().then(() => (init_cryptosphere(), cryptosphere_exports));
          const decryptedContacts = await Promise.all(allContacts.map(async (contact) => {
            const decryptedContact = { ...contact };
            const decryptField = async (fieldValue, fieldName) => {
              if (!fieldValue || typeof fieldValue !== "string" || !fieldValue.includes('"encrypted"')) {
                return fieldValue || null;
              }
              try {
                const encryptedData = JSON.parse(fieldValue);
                if (encryptedData.encrypted && encryptedData.iv && encryptedData.keyId) {
                  const decryptResult = await cryptoSphere2.decrypt({
                    encrypted: encryptedData.encrypted,
                    iv: encryptedData.iv,
                    keyId: encryptedData.keyId
                  });
                  console.log(`[Decryption] Successfully decrypted ${fieldName} for contact ${contact.id}: ${decryptResult.decrypted}`);
                  return decryptResult.decrypted;
                }
              } catch (e) {
                console.warn(`Failed to decrypt ${fieldName} field for contact ${contact.id}:`, e);
              }
              return fieldValue || null;
            };
            decryptedContact.email = await decryptField(contact.email, "email");
            decryptedContact.phone = await decryptField(contact.phone, "phone");
            decryptedContact.address = await decryptField(contact.address, "address");
            decryptedContact.notes = await decryptField(contact.notes, "notes");
            return decryptedContact;
          }));
          console.log("[Contacts] Successfully processed", decryptedContacts.length, "contacts with decryption");
          return decryptedContacts;
        } catch (error) {
          console.error("Error retrieving contacts:", error);
          return [];
        }
      }
      async createContact(contact) {
        try {
          const [newContact] = await db.insert(contacts).values({
            firstName: contact.firstName,
            lastName: contact.lastName,
            email: contact.email,
            phone: contact.phone,
            address: contact.address,
            city: contact.city,
            state: contact.state,
            zip: contact.zip,
            country: contact.country,
            accountId: contact.accountId,
            title: contact.title,
            department: contact.department,
            leadSource: contact.leadSource,
            assignedTo: contact.assignedTo,
            status: contact.status,
            tags: contact.tags,
            notes: contact.notes,
            socialProfiles: contact.socialProfiles,
            createdAt: /* @__PURE__ */ new Date()
          }).returning();
          return newContact;
        } catch (error) {
          console.error("Database error in createContact:", error);
          throw new Error("Failed to create contact");
        }
      }
      async updateContact(id, contact) {
        try {
          const [updatedContact] = await db.update(contacts).set({
            ...contact,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(contacts.id, id)).returning();
          return updatedContact;
        } catch (error) {
          console.error("Database error in updateContact:", error);
          return void 0;
        }
      }
      async deleteContact(id) {
        try {
          const result = await db.delete(contacts).where(eq5(contacts.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteContact:", error);
          return false;
        }
      }
      // Account Methods
      async getAccount(id) {
        try {
          const [account] = await db.select().from(accounts).where(eq5(accounts.id, id));
          return account || void 0;
        } catch (error) {
          console.error("Error fetching account:", error);
          return void 0;
        }
      }
      async listAccounts(filter) {
        try {
          const allAccounts = await db.select().from(accounts);
          return allAccounts;
        } catch (error) {
          console.error("Error retrieving accounts:", error);
          return [];
        }
      }
      async createAccount(account) {
        try {
          const [newAccount] = await db.insert(accounts).values({
            ...account,
            createdAt: /* @__PURE__ */ new Date(),
            isActive: account.isActive !== false
          }).returning();
          return newAccount;
        } catch (error) {
          console.error("Database error in createAccount:", error);
          throw error;
        }
      }
      async updateAccount(id, account) {
        try {
          const [updatedAccount] = await db.update(accounts).set({
            ...account,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(accounts.id, id)).returning();
          return updatedAccount;
        } catch (error) {
          console.error("Database error in updateAccount:", error);
          return void 0;
        }
      }
      async deleteAccount(id) {
        try {
          const result = await db.delete(accounts).where(eq5(accounts.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteAccount:", error);
          return false;
        }
      }
      // Lead Methods
      async getLead(id) {
        try {
          const [lead] = await db.select().from(leads).where(eq5(leads.id, id));
          return lead;
        } catch (error) {
          console.error("Error retrieving lead:", error);
          return void 0;
        }
      }
      async listLeads(filter) {
        try {
          const allLeads = await db.select().from(leads);
          return allLeads;
        } catch (error) {
          console.error("Error retrieving leads:", error);
          return [];
        }
      }
      async createLead(lead) {
        try {
          console.log("Creating lead with data:", lead);
          const [newLead] = await db.insert(leads).values({
            firstName: lead.firstName,
            lastName: lead.lastName,
            email: lead.email,
            phone: lead.phone,
            company: lead.company,
            title: lead.title,
            status: lead.status,
            source: lead.source,
            ownerId: lead.ownerId,
            notes: lead.notes
            // These fields are handled by the database with default values:
            // isConverted, convertedToContactId, convertedToAccountId, convertedToOpportunityId
          }).returning();
          console.log("Lead created successfully:", newLead);
          return newLead;
        } catch (error) {
          console.error("Database error in createLead:", error);
          throw new Error(`Failed to create lead: ${error.message}`);
        }
      }
      async updateLead(id, lead) {
        try {
          const [updatedLead] = await db.update(leads).set({
            ...lead,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(leads.id, id)).returning();
          return updatedLead;
        } catch (error) {
          console.error("Database error in updateLead:", error);
          return void 0;
        }
      }
      async deleteLead(id) {
        try {
          const result = await db.delete(leads).where(eq5(leads.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteLead:", error);
          return false;
        }
      }
      async convertLead(id, convertTo) {
        try {
          const [lead] = await db.select().from(leads).where(eq5(leads.id, id));
          if (!lead) {
            throw new Error(`Lead with ID ${id} not found`);
          }
          const result = {
            lead
          };
          await db.transaction(async (tx) => {
            console.log(`[Lead Conversion] Starting transaction for lead ${id}`);
            if (convertTo.contact) {
              const contactData = {
                ...convertTo.contact,
                firstName: convertTo.contact.firstName || lead.firstName,
                lastName: convertTo.contact.lastName || lead.lastName,
                email: convertTo.contact.email || lead.email,
                phone: convertTo.contact.phone || lead.phone,
                company: convertTo.contact.company || lead.company,
                title: convertTo.contact.title || lead.title,
                ownerId: convertTo.contact.ownerId || lead.ownerId,
                notes: convertTo.contact.notes || lead.notes
              };
              console.log(`[Lead Conversion] Creating contact from lead ${id}`);
              const [contact] = await tx.insert(contacts).values(contactData).returning();
              result.contact = contact;
            }
            if (convertTo.account) {
              const accountData = {
                ...convertTo.account,
                name: convertTo.account.name || lead.company || `${lead.firstName} ${lead.lastName}'s Account`,
                ownerId: convertTo.account.ownerId || lead.ownerId,
                notes: convertTo.account.notes || lead.notes
              };
              console.log(`[Lead Conversion] Creating account from lead ${id}`);
              const [account] = await tx.insert(accounts).values(accountData).returning();
              result.account = account;
            }
            if (convertTo.opportunity) {
              const opportunityData = {
                ...convertTo.opportunity,
                name: convertTo.opportunity.name || `${lead.firstName} ${lead.lastName} Opportunity`,
                accountId: convertTo.opportunity.accountId || (result.account ? result.account.id : null),
                ownerId: convertTo.opportunity.ownerId || lead.ownerId,
                notes: convertTo.opportunity.notes || lead.notes
              };
              console.log(`[Lead Conversion] Creating opportunity from lead ${id}`);
              const [opportunity] = await tx.insert(opportunities).values(opportunityData).returning();
              result.opportunity = opportunity;
            }
            const updateData = {
              isConverted: true,
              convertedToContactId: result.contact?.id || null,
              convertedToAccountId: result.account?.id || null,
              convertedToOpportunityId: result.opportunity?.id || null
            };
            console.log(`[Lead Conversion] Updating lead ${id} as converted`);
            const [updatedLead] = await tx.update(leads).set(updateData).where(eq5(leads.id, id)).returning();
            result.lead = updatedLead;
          });
          console.log(`[Lead Conversion] Successfully converted lead ${id}`);
          return result;
        } catch (error) {
          console.error("Error converting lead:", error);
          throw error;
        }
      }
      // Opportunity Methods
      async getOpportunity(id) {
        try {
          const [opportunity] = await db.select().from(opportunities).where(eq5(opportunities.id, id));
          return opportunity;
        } catch (error) {
          console.error("Error retrieving opportunity:", error);
          return void 0;
        }
      }
      async listOpportunities(filter) {
        try {
          const allOpportunities = await db.select().from(opportunities);
          return allOpportunities;
        } catch (error) {
          console.error("Error retrieving opportunities:", error);
          return [];
        }
      }
      async createOpportunity(opportunity) {
        try {
          const [newOpportunity] = await db.insert(opportunities).values({
            ...opportunity,
            createdAt: /* @__PURE__ */ new Date()
          }).returning();
          return newOpportunity;
        } catch (error) {
          console.error("Database error in createOpportunity:", error);
          throw new Error("Failed to create opportunity");
        }
      }
      async updateOpportunity(id, opportunity) {
        try {
          const [updatedOpportunity] = await db.update(opportunities).set({
            ...opportunity,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(opportunities.id, id)).returning();
          return updatedOpportunity;
        } catch (error) {
          console.error("Database error in updateOpportunity:", error);
          return void 0;
        }
      }
      async deleteOpportunity(id) {
        try {
          const result = await db.delete(opportunities).where(eq5(opportunities.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteOpportunity:", error);
          return false;
        }
      }
      // Task Methods
      async getTask(id) {
        try {
          const [task] = await db.select().from(tasks).where(eq5(tasks.id, id));
          return task;
        } catch (error) {
          console.error("Error retrieving task:", error);
          return void 0;
        }
      }
      async listTasks(filter) {
        try {
          let query = db.select().from(tasks);
          if (filter) {
            if (filter.assignedTo !== void 0) {
              query = query.where(eq5(tasks.assignedTo, filter.assignedTo));
            }
            if (filter.relatedToId !== void 0 && filter.relatedToType !== void 0) {
              query = query.where(
                and3(
                  eq5(tasks.relatedToId, filter.relatedToId),
                  eq5(tasks.relatedToType, filter.relatedToType)
                )
              );
            }
            if (filter.status !== void 0) {
              query = query.where(eq5(tasks.status, filter.status));
            }
            if (filter.priority !== void 0) {
              query = query.where(eq5(tasks.priority, filter.priority));
            }
          }
          const allTasks = await query;
          return allTasks;
        } catch (error) {
          console.error("Error retrieving tasks:", error);
          return [];
        }
      }
      async createTask(task) {
        try {
          const [newTask] = await db.insert(tasks).values({
            ...task,
            createdAt: /* @__PURE__ */ new Date(),
            isCompleted: task.isCompleted || false
          }).returning();
          return newTask;
        } catch (error) {
          console.error("Database error in createTask:", error);
          throw new Error("Failed to create task");
        }
      }
      async updateTask(id, task) {
        try {
          const [updatedTask] = await db.update(tasks).set({
            ...task,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(tasks.id, id)).returning();
          return updatedTask;
        } catch (error) {
          console.error("Database error in updateTask:", error);
          return void 0;
        }
      }
      async deleteTask(id) {
        try {
          const result = await db.delete(tasks).where(eq5(tasks.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteTask:", error);
          return false;
        }
      }
      // Event Methods
      async getEvent(id) {
        try {
          const [event] = await db.select().from(events).where(eq5(events.id, id));
          return event;
        } catch (error) {
          console.error("Error retrieving event:", error);
          return void 0;
        }
      }
      async listEvents(filter) {
        try {
          let query = db.select().from(events);
          if (filter) {
            if (filter.createdBy !== void 0) {
              query = query.where(eq5(events.createdBy, filter.createdBy));
            }
            if (filter.relatedToId !== void 0 && filter.relatedToType !== void 0) {
              query = query.where(
                and3(
                  eq5(events.relatedToId, filter.relatedToId),
                  eq5(events.relatedToType, filter.relatedToType)
                )
              );
            }
            if (filter.status !== void 0) {
              query = query.where(eq5(events.status, filter.status));
            }
            if (filter.startDate !== void 0) {
              query = query.where(gte(events.startDate, filter.startDate));
            }
            if (filter.endDate !== void 0) {
              query = query.where(lte(events.endDate, filter.endDate));
            }
          }
          const allEvents = await query;
          return allEvents;
        } catch (error) {
          console.error("Error retrieving events:", error);
          return [];
        }
      }
      async createEvent(event) {
        try {
          const [newEvent] = await db.insert(events).values({
            ...event,
            createdAt: /* @__PURE__ */ new Date()
          }).returning();
          return newEvent;
        } catch (error) {
          console.error("Database error in createEvent:", error);
          throw new Error("Failed to create event");
        }
      }
      async updateEvent(id, event) {
        try {
          const [updatedEvent] = await db.update(events).set({
            ...event,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(events.id, id)).returning();
          return updatedEvent;
        } catch (error) {
          console.error("Database error in updateEvent:", error);
          return void 0;
        }
      }
      async deleteEvent(id) {
        try {
          const result = await db.delete(events).where(eq5(events.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteEvent:", error);
          return false;
        }
      }
      // Activity Methods
      async getActivity(id) {
        try {
          const [activity] = await db.select().from(activities).where(eq5(activities.id, id));
          return activity;
        } catch (error) {
          console.error("Error retrieving activity:", error);
          return void 0;
        }
      }
      async listActivities(filter) {
        try {
          let query = db.select().from(activities);
          if (filter) {
            if (filter.userId !== void 0) {
              query = query.where(eq5(activities.userId, filter.userId));
            }
            if (filter.relatedToId !== void 0 && filter.relatedToType !== void 0) {
              query = query.where(
                and3(
                  eq5(activities.relatedToId, filter.relatedToId),
                  eq5(activities.relatedToType, filter.relatedToType)
                )
              );
            }
            if (filter.action !== void 0) {
              query = query.where(eq5(activities.action, filter.action));
            }
          }
          query = query.orderBy(desc2(activities.createdAt));
          const allActivities = await query;
          return allActivities;
        } catch (error) {
          console.error("Error retrieving activities:", error);
          return [];
        }
      }
      async createActivity(activity) {
        try {
          const [newActivity] = await db.insert(activities).values({
            ...activity,
            createdAt: /* @__PURE__ */ new Date()
          }).returning();
          return newActivity;
        } catch (error) {
          console.error("Database error in createActivity:", error);
          throw new Error("Failed to create activity");
        }
      }
      // Dashboard Methods
      async getDashboardStats() {
        try {
          const thirtyDaysAgo = /* @__PURE__ */ new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          const newLeadsResult = await db.select({ count: sql`count(*)` }).from(leads).where(
            and3(
              eq5(leads.status, "New"),
              gte(leads.createdAt, thirtyDaysAgo)
            )
          );
          const newLeads = Number(newLeadsResult[0]?.count || 0);
          const allLeadsResult = await db.select({ count: sql`count(*)` }).from(leads);
          const convertedLeadsResult = await db.select({ count: sql`count(*)` }).from(leads).where(eq5(leads.isConverted, true));
          const totalLeads = Number(allLeadsResult[0]?.count || 0);
          const convertedLeads = Number(convertedLeadsResult[0]?.count || 0);
          const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads * 100).toFixed(1) + "%" : "0%";
          const revenueResult = await db.select({
            total: sql`sum(cast(amount as decimal))`
          }).from(opportunities).where(eq5(opportunities.isWon, true));
          const totalRevenue = Number(revenueResult[0]?.total || 0);
          const revenue = totalRevenue.toLocaleString("en-US", {
            style: "currency",
            currency: "USD",
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          });
          const openDealsResult = await db.select({ count: sql`count(*)` }).from(opportunities).where(eq5(opportunities.isClosed, false));
          const openDeals = Number(openDealsResult[0]?.count || 0);
          return {
            newLeads,
            conversionRate,
            revenue,
            openDeals
          };
        } catch (error) {
          console.error("Error getting dashboard stats:", error);
          return {
            newLeads: 0,
            conversionRate: "0%",
            revenue: "$0",
            openDeals: 0
          };
        }
      }
      async getSalesPipeline() {
        try {
          const stageNames = [
            "Lead Generation",
            "Qualification",
            "Proposal",
            "Negotiation",
            "Closing"
          ];
          const totalAmountResult = await db.select({
            total: sql`sum(cast(amount as decimal))`
          }).from(opportunities).where(eq5(opportunities.isClosed, false));
          const totalAmount = Number(totalAmountResult[0]?.total || 0);
          const stages = [];
          for (const stageName of stageNames) {
            const stageAmountResult = await db.select({
              total: sql`sum(cast(amount as decimal))`
            }).from(opportunities).where(
              and3(
                eq5(opportunities.stage, stageName),
                eq5(opportunities.isClosed, false)
              )
            );
            const stageAmount = Number(stageAmountResult[0]?.total || 0);
            const percentage = totalAmount > 0 ? Math.round(stageAmount / totalAmount * 100) : 0;
            const formattedAmount = stageAmount.toLocaleString("en-US", {
              style: "currency",
              currency: "USD",
              minimumFractionDigits: 0,
              maximumFractionDigits: 0
            });
            stages.push({
              name: stageName,
              value: formattedAmount,
              percentage
            });
          }
          return { stages };
        } catch (error) {
          console.error("Error getting sales pipeline:", error);
          return { stages: [] };
        }
      }
      // Report Methods
      async getSalesReport(timeRange) {
        return { monthlyData: [], pipelineStages: [] };
      }
      async getLeadsReport(timeRange) {
        return { sourceData: [], trendData: [] };
      }
      async getConversionReport(timeRange) {
        return {
          conversionRate: 0,
          previousRate: 0,
          avgTimeToConvert: 0,
          previousTime: 0,
          bestChannel: { name: "", rate: 0 },
          weeklyData: []
        };
      }
      async getTeamPerformanceReport(timeRange) {
        return { teamMembers: [] };
      }
      // Workflow Methods
      async getWorkflow(id) {
        try {
          const [workflow] = await db.select().from(workflows).where(eq5(workflows.id, id));
          return workflow;
        } catch (error) {
          console.error("Database error in getWorkflow:", error);
          return void 0;
        }
      }
      async listWorkflows(filter) {
        try {
          let query = db.select().from(workflows);
          if (filter) {
            if (filter.isTemplate !== void 0) {
              query = query.where(eq5(workflows.isTemplate, filter.isTemplate));
            }
            if (filter.isActive !== void 0) {
              query = query.where(eq5(workflows.isActive, filter.isActive));
            }
            if (filter.status) {
              query = query.where(eq5(workflows.status, filter.status));
            }
            if (filter.ownerId !== void 0) {
              query = query.where(eq5(workflows.ownerId, filter.ownerId));
            }
            if (filter.triggerType) {
              query = query.where(eq5(workflows.triggerType, filter.triggerType));
            }
          }
          const workflowList = await query;
          return workflowList;
        } catch (error) {
          console.error("Database error in listWorkflows:", error);
          return [];
        }
      }
      async createWorkflow(workflowData) {
        try {
          const [workflow] = await db.insert(workflows).values({
            ...workflowData,
            createdAt: /* @__PURE__ */ new Date(),
            isActive: workflowData.isActive === void 0 ? true : workflowData.isActive,
            isTemplate: workflowData.isTemplate === void 0 ? false : workflowData.isTemplate,
            lastExecuted: null
          }).returning();
          return workflow;
        } catch (error) {
          console.error("Database error in createWorkflow:", error);
          throw new Error(`Failed to create workflow: ${error}`);
        }
      }
      async updateWorkflow(id, workflowData) {
        try {
          const [updatedWorkflow] = await db.update(workflows).set(workflowData).where(eq5(workflows.id, id)).returning();
          return updatedWorkflow;
        } catch (error) {
          console.error("Database error in updateWorkflow:", error);
          return void 0;
        }
      }
      async deleteWorkflow(id) {
        try {
          const result = await db.delete(workflows).where(eq5(workflows.id, id));
          return result.rowCount ? result.rowCount > 0 : false;
        } catch (error) {
          console.error("Database error in deleteWorkflow:", error);
          return false;
        }
      }
      // Subscription Package Methods
      async getSubscriptionPackage(id) {
        try {
          const [package_] = await db.select().from(subscriptionPackages).where(eq5(subscriptionPackages.id, id));
          return package_;
        } catch (error) {
          console.error(`Error retrieving subscription package with id ${id}:`, error);
          return void 0;
        }
      }
      async listSubscriptionPackages(filter) {
        try {
          const allPackages = await db.select().from(subscriptionPackages);
          return allPackages;
        } catch (error) {
          console.error("Error retrieving subscription packages:", error);
          return [];
        }
      }
      async createSubscriptionPackage(pkg) {
        try {
          const [newPackage] = await db.insert(subscriptionPackages).values({
            ...pkg,
            createdAt: /* @__PURE__ */ new Date(),
            isActive: pkg.isActive ?? true
          }).returning();
          return newPackage;
        } catch (error) {
          console.error("Database error in createSubscriptionPackage:", error);
          throw new Error("Failed to create subscription package");
        }
      }
      async updateSubscriptionPackage(id, pkg) {
        try {
          const [updatedPackage] = await db.update(subscriptionPackages).set({
            ...pkg,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(subscriptionPackages.id, id)).returning();
          return updatedPackage;
        } catch (error) {
          console.error("Database error in updateSubscriptionPackage:", error);
          return void 0;
        }
      }
      async deleteSubscriptionPackage(id) {
        try {
          const activeSubscriptions = await db.select({ count: sql`count(*)` }).from(userSubscriptions).where(
            and3(
              eq5(userSubscriptions.packageId, id),
              eq5(userSubscriptions.status, "active")
            )
          );
          const activeCount = Number(activeSubscriptions[0]?.count || 0);
          if (activeCount > 0) {
            return false;
          }
          const result = await db.delete(subscriptionPackages).where(eq5(subscriptionPackages.id, id)).returning();
          return result.length > 0;
        } catch (error) {
          console.error("Database error in deleteSubscriptionPackage:", error);
          return false;
        }
      }
      // User Subscription Methods
      async getUserSubscription(id) {
        try {
          const [subscription] = await db.select().from(userSubscriptions).where(eq5(userSubscriptions.id, id));
          return subscription;
        } catch (error) {
          console.error(`Error retrieving user subscription with id ${id}:`, error);
          return void 0;
        }
      }
      async getUserActiveSubscription(userId) {
        try {
          const [subscription] = await db.select().from(userSubscriptions).where(and3(
            eq5(userSubscriptions.userId, userId),
            eq5(userSubscriptions.status, "Active")
          )).orderBy(desc2(userSubscriptions.startDate)).limit(1);
          return subscription;
        } catch (error) {
          console.error(`Error retrieving active subscription for user ${userId}:`, error);
          return void 0;
        }
      }
      async listUserSubscriptions(filter) {
        try {
          let query = db.select().from(userSubscriptions);
          if (filter) {
            if (filter.userId !== void 0) {
              query = query.where(eq5(userSubscriptions.userId, filter.userId));
            }
            if (filter.packageId !== void 0) {
              query = query.where(eq5(userSubscriptions.packageId, filter.packageId));
            }
            if (filter.status !== void 0) {
              query = query.where(eq5(userSubscriptions.status, filter.status));
            }
          }
          const subscriptions = await query;
          return subscriptions;
        } catch (error) {
          console.error("Error retrieving user subscriptions:", error);
          return [];
        }
      }
      async createUserSubscription(subscription) {
        try {
          const [newSubscription] = await db.insert(userSubscriptions).values(subscription).returning();
          return newSubscription;
        } catch (error) {
          console.error("Error creating subscription:", error);
          throw new Error(`Failed to create subscription: ${error.message}`);
        }
      }
      async updateUserSubscription(id, subscription) {
        try {
          const [updatedSubscription] = await db.update(userSubscriptions).set({ ...subscription, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(userSubscriptions.id, id)).returning();
          return updatedSubscription;
        } catch (error) {
          console.error(`Error updating subscription ${id}:`, error);
          return void 0;
        }
      }
      async cancelUserSubscription(id) {
        try {
          const [canceledSubscription] = await db.update(userSubscriptions).set({
            status: "Canceled",
            updatedAt: /* @__PURE__ */ new Date(),
            endDate: /* @__PURE__ */ new Date()
            // End immediately
          }).where(eq5(userSubscriptions.id, id)).returning();
          return canceledSubscription;
        } catch (error) {
          console.error(`Error canceling subscription ${id}:`, error);
          return void 0;
        }
      }
      async deleteUserSubscription(id) {
        try {
          const result = await db.delete(userSubscriptions).where(eq5(userSubscriptions.id, id));
          return result.rowCount ? result.rowCount > 0 : false;
        } catch (error) {
          console.error(`Error deleting subscription ${id}:`, error);
          return false;
        }
      }
      // Social Media Integrations
      async getSocialIntegration(id) {
        try {
          const [integration] = await db.select().from(socialIntegrations).where(eq5(socialIntegrations.id, id));
          return integration;
        } catch (error) {
          console.error("Database error in getSocialIntegration:", error);
          return void 0;
        }
      }
      async listSocialIntegrations(filter) {
        try {
          let query = db.select().from(socialIntegrations);
          if (filter) {
            if (filter.userId !== void 0) {
              query = query.where(eq5(socialIntegrations.userId, filter.userId));
            }
            if (filter.platform !== void 0) {
              query = query.where(eq5(socialIntegrations.platform, filter.platform));
            }
            if (filter.isActive !== void 0) {
              query = query.where(eq5(socialIntegrations.isActive, filter.isActive));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listSocialIntegrations:", error);
          return [];
        }
      }
      async getUserSocialIntegrations(userId) {
        try {
          return await db.select().from(socialIntegrations).where(eq5(socialIntegrations.userId, userId));
        } catch (error) {
          console.error("Database error in getUserSocialIntegrations:", error);
          return [];
        }
      }
      async createSocialIntegration(integration) {
        try {
          const [newIntegration] = await db.insert(socialIntegrations).values(integration).returning();
          return newIntegration;
        } catch (error) {
          console.error("Database error in createSocialIntegration:", error);
          throw new Error(`Failed to create social integration: ${error.message}`);
        }
      }
      async updateSocialIntegration(id, integration) {
        try {
          const [updatedIntegration] = await db.update(socialIntegrations).set({ ...integration, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(socialIntegrations.id, id)).returning();
          return updatedIntegration;
        } catch (error) {
          console.error("Database error in updateSocialIntegration:", error);
          return void 0;
        }
      }
      async deleteSocialIntegration(id) {
        try {
          const result = await db.delete(socialIntegrations).where(eq5(socialIntegrations.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteSocialIntegration:", error);
          return false;
        }
      }
      // Social Media Messages
      async getSocialMessage(id) {
        try {
          const [message] = await db.select().from(socialMessages).where(eq5(socialMessages.id, id));
          return message;
        } catch (error) {
          console.error("Database error in getSocialMessage:", error);
          return void 0;
        }
      }
      async listSocialMessages(filter) {
        try {
          let query = db.select().from(socialMessages);
          if (filter) {
            if (filter.integrationId !== void 0) {
              query = query.where(eq5(socialMessages.integrationId, filter.integrationId));
            }
            if (filter.leadId !== void 0) {
              query = query.where(eq5(socialMessages.leadId, filter.leadId));
            }
            if (filter.contactId !== void 0) {
              query = query.where(eq5(socialMessages.contactId, filter.contactId));
            }
            if (filter.direction !== void 0) {
              query = query.where(eq5(socialMessages.direction, filter.direction));
            }
            if (filter.status !== void 0) {
              query = query.where(eq5(socialMessages.status, filter.status));
            }
            if (filter.isDeleted !== void 0) {
              query = query.where(eq5(socialMessages.isDeleted, filter.isDeleted));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listSocialMessages:", error);
          return [];
        }
      }
      async getLeadSocialMessages(leadId) {
        try {
          return await db.select().from(socialMessages).where(eq5(socialMessages.leadId, leadId));
        } catch (error) {
          console.error("Database error in getLeadSocialMessages:", error);
          return [];
        }
      }
      async getContactSocialMessages(contactId) {
        try {
          return await db.select().from(socialMessages).where(eq5(socialMessages.contactId, contactId));
        } catch (error) {
          console.error("Database error in getContactSocialMessages:", error);
          return [];
        }
      }
      async createSocialMessage(message) {
        try {
          const [newMessage] = await db.insert(socialMessages).values(message).returning();
          return newMessage;
        } catch (error) {
          console.error("Database error in createSocialMessage:", error);
          throw new Error(`Failed to create social message: ${error.message}`);
        }
      }
      async updateSocialMessage(id, message) {
        try {
          const [updatedMessage] = await db.update(socialMessages).set(message).where(eq5(socialMessages.id, id)).returning();
          return updatedMessage;
        } catch (error) {
          console.error("Database error in updateSocialMessage:", error);
          return void 0;
        }
      }
      async deleteSocialMessage(id) {
        try {
          const [updatedMessage] = await db.update(socialMessages).set({ isDeleted: true }).where(eq5(socialMessages.id, id)).returning();
          return !!updatedMessage;
        } catch (error) {
          console.error("Database error in deleteSocialMessage:", error);
          return false;
        }
      }
      // Lead Sources
      async getLeadSource(id) {
        try {
          const [source] = await db.select().from(leadSources).where(eq5(leadSources.id, id));
          return source;
        } catch (error) {
          console.error("Database error in getLeadSource:", error);
          return void 0;
        }
      }
      async listLeadSources(filter) {
        try {
          let query = db.select().from(leadSources);
          if (filter) {
            if (filter.platform !== void 0) {
              query = query.where(eq5(leadSources.platform, filter.platform));
            }
            if (filter.isActive !== void 0) {
              query = query.where(eq5(leadSources.isActive, filter.isActive));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listLeadSources:", error);
          return [];
        }
      }
      async createLeadSource(source) {
        try {
          const [newSource] = await db.insert(leadSources).values(source).returning();
          return newSource;
        } catch (error) {
          console.error("Database error in createLeadSource:", error);
          throw new Error(`Failed to create lead source: ${error.message}`);
        }
      }
      async updateLeadSource(id, source) {
        try {
          const [updatedSource] = await db.update(leadSources).set({ ...source, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(leadSources.id, id)).returning();
          return updatedSource;
        } catch (error) {
          console.error("Database error in updateLeadSource:", error);
          return void 0;
        }
      }
      async deleteLeadSource(id) {
        try {
          const result = await db.delete(leadSources).where(eq5(leadSources.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteLeadSource:", error);
          return false;
        }
      }
      // Social Media Campaigns
      async getSocialCampaign(id) {
        try {
          const [campaign] = await db.select().from(socialCampaigns).where(eq5(socialCampaigns.id, id));
          return campaign;
        } catch (error) {
          console.error("Database error in getSocialCampaign:", error);
          return void 0;
        }
      }
      async listSocialCampaigns(filter) {
        try {
          let query = db.select().from(socialCampaigns);
          if (filter) {
            if (filter.platform !== void 0) {
              query = query.where(eq5(socialCampaigns.platform, filter.platform));
            }
            if (filter.ownerId !== void 0) {
              query = query.where(eq5(socialCampaigns.ownerId, filter.ownerId));
            }
            if (filter.status !== void 0) {
              query = query.where(eq5(socialCampaigns.status, filter.status));
            }
            if (filter.isActive !== void 0) {
              query = query.where(eq5(socialCampaigns.isActive, filter.isActive));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listSocialCampaigns:", error);
          return [];
        }
      }
      async createSocialCampaign(campaign) {
        try {
          const [newCampaign] = await db.insert(socialCampaigns).values(campaign).returning();
          return newCampaign;
        } catch (error) {
          console.error("Database error in createSocialCampaign:", error);
          throw new Error(`Failed to create social campaign: ${error.message}`);
        }
      }
      async updateSocialCampaign(id, campaign) {
        try {
          const [updatedCampaign] = await db.update(socialCampaigns).set({ ...campaign, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(socialCampaigns.id, id)).returning();
          return updatedCampaign;
        } catch (error) {
          console.error("Database error in updateSocialCampaign:", error);
          return void 0;
        }
      }
      async deleteSocialCampaign(id) {
        try {
          const result = await db.delete(socialCampaigns).where(eq5(socialCampaigns.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteSocialCampaign:", error);
          return false;
        }
      }
      // Product Category methods
      async getProductCategory(id) {
        try {
          const [productCategory] = await db.select().from(productCategoriesTable).where(eq5(productCategoriesTable.id, id));
          return productCategory;
        } catch (error) {
          console.error("Database error in getProductCategory:", error);
          return void 0;
        }
      }
      async listProductCategories(filter) {
        try {
          let query = db.select().from(productCategoriesTable);
          if (filter) {
            const whereConditions = [];
            if (filter.id !== void 0) whereConditions.push(eq5(productCategoriesTable.id, filter.id));
            if (filter.name !== void 0) whereConditions.push(eq5(productCategoriesTable.name, filter.name));
            if (filter.isActive !== void 0) whereConditions.push(eq5(productCategoriesTable.isActive, filter.isActive));
            if (filter.ownerId !== void 0) whereConditions.push(eq5(productCategoriesTable.ownerId, filter.ownerId));
            if (whereConditions.length > 0) {
              query = query.where(and3(...whereConditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listProductCategories:", error);
          return [];
        }
      }
      async createProductCategory(category) {
        try {
          const [newCategory] = await db.insert(productCategoriesTable).values(category).returning();
          return newCategory;
        } catch (error) {
          console.error("Database error in createProductCategory:", error);
          throw new Error(`Failed to create product category: ${error.message}`);
        }
      }
      async updateProductCategory(id, category) {
        try {
          const [updatedCategory] = await db.update(productCategoriesTable).set({
            ...category,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(productCategoriesTable.id, id)).returning();
          return updatedCategory;
        } catch (error) {
          console.error("Database error in updateProductCategory:", error);
          return void 0;
        }
      }
      async deleteProductCategory(id) {
        try {
          const productsWithCategory = await db.select().from(products).where(eq5(products.categoryId, id));
          if (productsWithCategory.length > 0) {
            return false;
          }
          const result = await db.delete(productCategories).where(eq5(productCategoriesTable.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteProductCategory:", error);
          return false;
        }
      }
      // Product methods
      async getProduct(id) {
        try {
          const [product] = await db.select().from(products).where(eq5(products.id, id));
          return product;
        } catch (error) {
          console.error("Database error in getProduct:", error);
          return void 0;
        }
      }
      async listProducts(filter) {
        try {
          let query = db.select({
            id: products.id,
            name: products.name,
            sku: products.sku,
            description: products.description,
            price: products.price,
            cost: products.cost,
            categoryId: products.categoryId,
            isActive: products.isActive,
            createdAt: products.createdAt,
            updatedAt: products.updatedAt,
            inStock: products.inStock,
            stockQuantity: products.stockQuantity,
            reorderLevel: products.reorderLevel,
            attributes: products.attributes,
            images: products.images,
            taxable: products.taxable,
            taxRate: products.taxRate,
            ownerId: products.ownerId
            // Manufacturing-specific fields not included to ensure compatibility
          }).from(products);
          if (filter) {
            const whereConditions = [];
            if (filter.id !== void 0) whereConditions.push(eq5(products.id, filter.id));
            if (filter.name !== void 0) whereConditions.push(eq5(products.name, filter.name));
            if (filter.categoryId !== void 0) whereConditions.push(eq5(products.categoryId, filter.categoryId));
            if (filter.isActive !== void 0) whereConditions.push(eq5(products.isActive, filter.isActive));
            if (filter.ownerId !== void 0) whereConditions.push(eq5(products.ownerId, filter.ownerId));
            if (whereConditions.length > 0) {
              query = query.where(and3(...whereConditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listProducts:", error);
          return [];
        }
      }
      async createProduct(product) {
        try {
          const productToInsert = {
            name: product.name,
            sku: product.sku,
            description: product.description,
            price: product.price,
            cost: product.cost,
            categoryId: product.categoryId,
            isActive: product.isActive,
            inStock: product.inStock,
            stockQuantity: product.stockQuantity,
            reorderLevel: product.reorderLevel,
            attributes: product.attributes,
            images: product.images,
            taxable: product.taxable,
            taxRate: product.taxRate,
            ownerId: product.ownerId,
            weight: product.weight,
            dimensions: product.dimensions,
            barcode: product.barcode,
            tags: product.tags
            // Manufacturing-specific fields not included to ensure compatibility
          };
          const [newProduct] = await db.insert(products).values(productToInsert).returning();
          return newProduct;
        } catch (error) {
          console.error("Database error in createProduct:", error);
          throw new Error(`Failed to create product: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async updateProduct(id, product) {
        try {
          const updateFields = {
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (product.name !== void 0) updateFields.name = product.name;
          if (product.sku !== void 0) updateFields.sku = product.sku;
          if (product.description !== void 0) updateFields.description = product.description;
          if (product.price !== void 0) updateFields.price = product.price;
          if (product.cost !== void 0) updateFields.cost = product.cost;
          if (product.categoryId !== void 0) updateFields.categoryId = product.categoryId;
          if (product.isActive !== void 0) updateFields.isActive = product.isActive;
          if (product.inStock !== void 0) updateFields.inStock = product.inStock;
          if (product.stockQuantity !== void 0) updateFields.stockQuantity = product.stockQuantity;
          if (product.reorderLevel !== void 0) updateFields.reorderLevel = product.reorderLevel;
          if (product.attributes !== void 0) updateFields.attributes = product.attributes;
          if (product.images !== void 0) updateFields.images = product.images;
          if (product.taxable !== void 0) updateFields.taxable = product.taxable;
          if (product.taxRate !== void 0) updateFields.taxRate = product.taxRate;
          if (product.ownerId !== void 0) updateFields.ownerId = product.ownerId;
          if (product.weight !== void 0) updateFields.weight = product.weight;
          if (product.dimensions !== void 0) updateFields.dimensions = product.dimensions;
          if (product.barcode !== void 0) updateFields.barcode = product.barcode;
          if (product.tags !== void 0) updateFields.tags = product.tags;
          const [updatedProduct] = await db.update(products).set(updateFields).where(eq5(products.id, id)).returning();
          return updatedProduct;
        } catch (error) {
          console.error("Database error in updateProduct:", error);
          return void 0;
        }
      }
      async deleteProduct(id) {
        try {
          const invoiceItems2 = await db.select().from(invoiceItems2).where(eq5(invoiceItems2.productId, id));
          const purchaseOrderItems2 = await db.select().from(purchaseOrderItems2).where(eq5(purchaseOrderItems2.productId, id));
          if (invoiceItems2.length > 0 || purchaseOrderItems2.length > 0) {
            return false;
          }
          const result = await db.delete(products).where(eq5(products.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteProduct:", error);
          return false;
        }
      }
      // Inventory Transaction methods
      async getInventoryTransaction(id) {
        try {
          const [transaction] = await db.select().from(inventoryTransactions).where(eq5(inventoryTransactions.id, id));
          return transaction;
        } catch (error) {
          console.error("Database error in getInventoryTransaction:", error);
          return void 0;
        }
      }
      async listInventoryTransactions(filter) {
        try {
          let query = db.select().from(inventoryTransactions).orderBy(desc2(inventoryTransactions.createdAt));
          if (filter) {
            const whereConditions = [];
            if (filter.id !== void 0) whereConditions.push(eq5(inventoryTransactions.id, filter.id));
            if (filter.productId !== void 0) whereConditions.push(eq5(inventoryTransactions.productId, filter.productId));
            if (filter.type !== void 0) whereConditions.push(eq5(inventoryTransactions.type, filter.type));
            if (whereConditions.length > 0) {
              query = query.where(and3(...whereConditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listInventoryTransactions:", error);
          return [];
        }
      }
      async createInventoryTransaction(transaction) {
        try {
          let processedReferenceId = transaction.referenceId;
          if (typeof processedReferenceId === "string") {
            const match = processedReferenceId.match(/\d+/);
            if (match) {
              processedReferenceId = parseInt(match[0], 10);
            } else {
              processedReferenceId = null;
            }
          }
          const transactionToInsert = {
            productId: transaction.productId,
            quantity: typeof transaction.quantity === "number" ? transaction.quantity.toString() : transaction.quantity,
            type: transaction.type,
            referenceType: transaction.referenceType,
            referenceId: processedReferenceId,
            notes: transaction.notes,
            createdBy: transaction.createdBy,
            unitCost: transaction.unitCost,
            location: transaction.location,
            batchId: transaction.batchId,
            expiryDate: transaction.expiryDate,
            serialNumber: transaction.serialNumber
            // Removed workCenterId and qualityInspectionId as they might not be in the current DB schema
          };
          const [newTransaction] = await db.insert(inventoryTransactions).values(transactionToInsert).returning();
          return newTransaction;
        } catch (error) {
          console.error("Database error in createInventoryTransaction:", error);
          throw new Error(`Failed to create inventory transaction: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async getProductInventory(productId) {
        try {
          const result = await db.select({
            total: sql`SUM(CASE 
          WHEN ${inventoryTransactions.type} = 'Purchase' THEN ${inventoryTransactions.quantity}
          WHEN ${inventoryTransactions.type} = 'Return' THEN ${inventoryTransactions.quantity}
          WHEN ${inventoryTransactions.type} = 'Adjustment' THEN 
            CASE WHEN ${inventoryTransactions.quantity} > 0 THEN ${inventoryTransactions.quantity} ELSE ${inventoryTransactions.quantity} END
          WHEN ${inventoryTransactions.type} = 'Sale' THEN -${inventoryTransactions.quantity}
          WHEN ${inventoryTransactions.type} = 'Transfer' THEN -${inventoryTransactions.quantity}
          ELSE 0 END)`
          }).from(inventoryTransactions).where(eq5(inventoryTransactions.productId, productId));
          return result[0].total || 0;
        } catch (error) {
          console.error("Database error in getProductInventory:", error);
          return 0;
        }
      }
      async getProductInventoryHistory(productId) {
        try {
          return await db.select().from(inventoryTransactions).where(eq5(inventoryTransactions.productId, productId)).orderBy(desc2(inventoryTransactions.createdAt));
        } catch (error) {
          console.error("Database error in getProductInventoryHistory:", error);
          return [];
        }
      }
      async getInventorySummary() {
        try {
          const allProducts = await db.select().from(products);
          const productsWithStock = await Promise.all(
            allProducts.map(async (product) => {
              const stock = await this.getProductInventory(product.id);
              const price = typeof product.price === "string" ? parseFloat(product.price) : product.price || 0;
              return {
                id: product.id,
                name: product.name,
                sku: product.sku || "",
                stock,
                value: stock * price
              };
            })
          );
          return { products: productsWithStock };
        } catch (error) {
          console.error("Database error in getInventorySummary:", error);
          return { products: [] };
        }
      }
      // Invoice methods
      async getInvoice(id) {
        try {
          const [invoice] = await db.select().from(invoices).where(eq5(invoices.id, id));
          return invoice;
        } catch (error) {
          console.error("Database error in getInvoice:", error);
          return void 0;
        }
      }
      async listInvoices(filter) {
        try {
          let query = db.select().from(invoices).orderBy(desc2(invoices.issueDate));
          if (filter) {
            const whereConditions = [];
            if (filter.id !== void 0) whereConditions.push(eq5(invoices.id, filter.id));
            if (filter.accountId !== void 0) whereConditions.push(eq5(invoices.accountId, filter.accountId));
            if (filter.status !== void 0) whereConditions.push(eq5(invoices.status, filter.status));
            if (filter.ownerId !== void 0) whereConditions.push(eq5(invoices.ownerId, filter.ownerId));
            if (whereConditions.length > 0) {
              query = query.where(and3(...whereConditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listInvoices:", error);
          return [];
        }
      }
      async createInvoice(invoice) {
        try {
          const [newInvoice] = await db.insert(invoices).values(invoice).returning();
          return newInvoice;
        } catch (error) {
          console.error("Database error in createInvoice:", error);
          throw new Error(`Failed to create invoice: ${error.message}`);
        }
      }
      async updateInvoice(id, invoice) {
        try {
          const [updatedInvoice] = await db.update(invoices).set({
            ...invoice,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(invoices.id, id)).returning();
          return updatedInvoice;
        } catch (error) {
          console.error("Database error in updateInvoice:", error);
          return void 0;
        }
      }
      async deleteInvoice(id) {
        try {
          await db.delete(invoiceItems).where(eq5(invoiceItems.invoiceId, id));
          const result = await db.delete(invoices).where(eq5(invoices.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteInvoice:", error);
          return false;
        }
      }
      // Invoice Item methods
      async getInvoiceItems(invoiceId) {
        try {
          return await db.select().from(invoiceItems).where(eq5(invoiceItems.invoiceId, invoiceId));
        } catch (error) {
          console.error("Database error in getInvoiceItems:", error);
          return [];
        }
      }
      async createInvoiceItem(item) {
        try {
          const [newItem] = await db.insert(invoiceItems).values(item).returning();
          if (item.productId) {
            const invoice = await this.getInvoice(item.invoiceId);
            if (invoice) {
              try {
                await this.createInventoryTransaction({
                  productId: item.productId,
                  quantity: typeof item.quantity === "string" ? parseFloat(item.quantity) : item.quantity,
                  type: "Sale",
                  referenceId: item.invoiceId,
                  referenceType: "invoice",
                  notes: `Sold on invoice #${item.invoiceId}`
                });
              } catch (transactionError) {
                console.warn("Failed to create inventory transaction, but continuing with invoice item creation:", transactionError.message);
              }
            }
          }
          return newItem;
        } catch (error) {
          console.error("Database error in createInvoiceItem:", error);
          throw new Error(`Failed to create invoice item: ${error.message}`);
        }
      }
      async updateInvoiceItem(id, item) {
        try {
          const [originalItem] = await db.select().from(invoiceItems).where(eq5(invoiceItems.id, id));
          if (!originalItem) {
            return void 0;
          }
          const [updatedItem] = await db.update(invoiceItems).set(item).where(eq5(invoiceItems.id, id)).returning();
          if (item.quantity !== void 0 && originalItem.productId) {
            const invoice = await this.getInvoice(originalItem.invoiceId);
            if (invoice) {
              const origQty = parseFloat(originalItem.quantity);
              const newQty = typeof item.quantity === "number" ? item.quantity : parseFloat(item.quantity);
              const quantityDiff = newQty - origQty;
              if (quantityDiff !== 0) {
                try {
                  await this.createInventoryTransaction({
                    productId: originalItem.productId,
                    quantity: Math.abs(quantityDiff).toString(),
                    type: quantityDiff < 0 ? "Return" : "Sale",
                    referenceId: originalItem.invoiceId,
                    referenceType: "invoice-adjustment",
                    notes: `Adjusted quantity on invoice #${originalItem.invoiceId}`
                  });
                } catch (transactionError) {
                  console.warn("Failed to create inventory transaction for adjustment, but continuing with invoice item update:", transactionError.message);
                }
              }
            }
          }
          return updatedItem;
        } catch (error) {
          console.error("Database error in updateInvoiceItem:", error);
          return void 0;
        }
      }
      async deleteInvoiceItem(id) {
        try {
          const [item] = await db.select().from(invoiceItems).where(eq5(invoiceItems.id, id));
          if (!item) {
            return false;
          }
          if (item.productId) {
            const invoice = await this.getInvoice(item.invoiceId);
            if (invoice) {
              try {
                await this.createInventoryTransaction({
                  productId: item.productId,
                  quantity: item.quantity,
                  // quantity is already a string in the database
                  type: "Return",
                  referenceId: item.invoiceId,
                  referenceType: "invoice-deletion",
                  notes: `Returned from deleted invoice item #${id}`
                });
              } catch (transactionError) {
                console.warn("Failed to create inventory transaction for deletion, but continuing with invoice item deletion:", transactionError.message);
              }
            }
          }
          const result = await db.delete(invoiceItems).where(eq5(invoiceItems.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteInvoiceItem:", error);
          return false;
        }
      }
      // Purchase Order methods
      async getPurchaseOrder(id) {
        try {
          const [order] = await db.select().from(purchaseOrders).where(eq5(purchaseOrders.id, id));
          return order;
        } catch (error) {
          console.error("Database error in getPurchaseOrder:", error);
          return void 0;
        }
      }
      async listPurchaseOrders(filter) {
        try {
          let query = db.select().from(purchaseOrders).orderBy(desc2(purchaseOrders.orderDate));
          if (filter) {
            const whereConditions = [];
            if (filter.id !== void 0) whereConditions.push(eq5(purchaseOrders.id, filter.id));
            if (filter.supplierId !== void 0) whereConditions.push(eq5(purchaseOrders.supplierId, filter.supplierId));
            if (filter.status !== void 0) whereConditions.push(eq5(purchaseOrders.status, filter.status));
            if (filter.createdBy !== void 0) whereConditions.push(eq5(purchaseOrders.createdBy, filter.createdBy));
            if (whereConditions.length > 0) {
              query = query.where(and3(...whereConditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listPurchaseOrders:", error);
          return [];
        }
      }
      async createPurchaseOrder(order) {
        try {
          const [newOrder] = await db.insert(purchaseOrders).values(order).returning();
          return newOrder;
        } catch (error) {
          console.error("Database error in createPurchaseOrder:", error);
          throw new Error(`Failed to create purchase order: ${error.message}`);
        }
      }
      async updatePurchaseOrder(id, order) {
        try {
          const [updatedOrder] = await db.update(purchaseOrders).set({
            ...order,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(purchaseOrders.id, id)).returning();
          return updatedOrder;
        } catch (error) {
          console.error("Database error in updatePurchaseOrder:", error);
          return void 0;
        }
      }
      async deletePurchaseOrder(id) {
        try {
          await db.delete(purchaseOrderItems).where(eq5(purchaseOrderItems.purchaseOrderId, id));
          const result = await db.delete(purchaseOrders).where(eq5(purchaseOrders.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deletePurchaseOrder:", error);
          return false;
        }
      }
      // Purchase Order Item methods
      async getPurchaseOrderItems(orderId) {
        try {
          return await db.select().from(purchaseOrderItems).where(eq5(purchaseOrderItems.purchaseOrderId, orderId));
        } catch (error) {
          console.error("Database error in getPurchaseOrderItems:", error);
          return [];
        }
      }
      async createPurchaseOrderItem(item) {
        try {
          const [newItem] = await db.insert(purchaseOrderItems).values(item).returning();
          return newItem;
        } catch (error) {
          console.error("Database error in createPurchaseOrderItem:", error);
          throw new Error(`Failed to create purchase order item: ${error.message}`);
        }
      }
      async updatePurchaseOrderItem(id, item) {
        try {
          const [updatedItem] = await db.update(purchaseOrderItems).set(item).where(eq5(purchaseOrderItems.id, id)).returning();
          return updatedItem;
        } catch (error) {
          console.error("Database error in updatePurchaseOrderItem:", error);
          return void 0;
        }
      }
      async deletePurchaseOrderItem(id) {
        try {
          const result = await db.delete(purchaseOrderItems).where(eq5(purchaseOrderItems.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deletePurchaseOrderItem:", error);
          return false;
        }
      }
      async listPurchaseOrderItems(orderId) {
        try {
          return await db.select().from(purchaseOrderItems).where(eq5(purchaseOrderItems.purchaseOrderId, orderId));
        } catch (error) {
          console.error("Database error in listPurchaseOrderItems:", error);
          return [];
        }
      }
      // Special method for receiving purchase order items and updating inventory
      async receivePurchaseOrderItems(orderId, receivedItems) {
        try {
          const order = await this.getPurchaseOrder(orderId);
          if (!order) {
            return false;
          }
          for (const received of receivedItems) {
            const [item] = await db.select().from(purchaseOrderItems).where(and3(
              eq5(purchaseOrderItems.id, received.itemId),
              eq5(purchaseOrderItems.purchaseOrderId, orderId)
            ));
            if (item) {
              const currentReceivedQty = item.receivedQuantity ? parseFloat(item.receivedQuantity) : 0;
              const newReceivedQuantity = (currentReceivedQty + received.quantity).toString();
              await this.updatePurchaseOrderItem(item.id, { receivedQuantity: newReceivedQuantity });
              if (item.productId) {
                try {
                  await this.createInventoryTransaction({
                    productId: item.productId,
                    quantity: received.quantity.toString(),
                    // Ensure quantity is a string
                    type: "Purchase",
                    referenceId: orderId,
                    referenceType: "purchase-order",
                    notes: `Received from purchase order #${orderId}`
                  });
                } catch (transactionError) {
                  console.warn("Failed to create inventory transaction for purchase, but continuing with purchase order receipt:", transactionError.message);
                }
              }
            }
          }
          const allItems = await this.listPurchaseOrderItems(orderId);
          const allReceived = allItems.every((item) => {
            const receivedQty = item.receivedQuantity ? parseFloat(item.receivedQuantity) : 0;
            const orderQty = parseFloat(item.quantity);
            return receivedQty >= orderQty;
          });
          const partiallyReceived = allItems.some((item) => {
            const receivedQty = item.receivedQuantity ? parseFloat(item.receivedQuantity) : 0;
            return receivedQty > 0;
          });
          let newStatus;
          if (allReceived) {
            newStatus = "Received";
          } else if (partiallyReceived) {
            newStatus = "Partially Received";
          }
          if (newStatus) {
            await this.updatePurchaseOrder(orderId, { status: newStatus });
          }
          return true;
        } catch (error) {
          console.error("Database error in receivePurchaseOrderItems:", error);
          return false;
        }
      }
      // Proposal Template Methods
      async getProposalTemplate(id) {
        try {
          const [template] = await db.select().from(proposalTemplates).where(eq5(proposalTemplates.id, id));
          return template;
        } catch (error) {
          console.error("Database error in getProposalTemplate:", error);
          return void 0;
        }
      }
      async listProposalTemplates() {
        try {
          return await db.select().from(proposalTemplates);
        } catch (error) {
          console.error("Database error in listProposalTemplates:", error);
          return [];
        }
      }
      async createProposalTemplate(template) {
        try {
          const createdAt = /* @__PURE__ */ new Date();
          const [newTemplate] = await db.insert(proposalTemplates).values({
            ...template,
            createdAt,
            updatedAt: createdAt,
            isActive: template.isActive === void 0 ? true : template.isActive
          }).returning();
          return newTemplate;
        } catch (error) {
          console.error("Database error in createProposalTemplate:", error);
          throw new Error("Failed to create proposal template");
        }
      }
      async updateProposalTemplate(id, template) {
        try {
          const [updatedTemplate] = await db.update(proposalTemplates).set({
            ...template,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(proposalTemplates.id, id)).returning();
          return updatedTemplate;
        } catch (error) {
          console.error("Database error in updateProposalTemplate:", error);
          return void 0;
        }
      }
      async deleteProposalTemplate(id) {
        try {
          const result = await db.delete(proposalTemplates).where(eq5(proposalTemplates.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteProposalTemplate:", error);
          return false;
        }
      }
      // Proposal Methods
      async getProposal(id) {
        try {
          const [proposal] = await db.select().from(proposals).where(eq5(proposals.id, id));
          return proposal;
        } catch (error) {
          console.error("Database error in getProposal:", error);
          return void 0;
        }
      }
      async listProposals(filter) {
        try {
          let query = db.select().from(proposals);
          if (filter) {
            const conditions = [];
            if (filter.accountId !== void 0) {
              conditions.push(eq5(proposals.accountId, filter.accountId));
            }
            if (filter.opportunityId !== void 0) {
              conditions.push(eq5(proposals.opportunityId, filter.opportunityId));
            }
            if (filter.status !== void 0) {
              conditions.push(eq5(proposals.status, filter.status));
            }
            if (filter.createdBy !== void 0) {
              conditions.push(eq5(proposals.createdBy, filter.createdBy));
            }
            if (conditions.length > 0) {
              query = query.where(and3(...conditions));
            }
          }
          return await query;
        } catch (error) {
          console.error("Database error in listProposals:", error);
          return [];
        }
      }
      async createProposal(proposal) {
        try {
          console.log("Storage.createProposal called with:", JSON.stringify(proposal, null, 2));
          if (!proposal.name) {
            throw new Error("Proposal name is required");
          }
          if (!proposal.opportunityId || typeof proposal.opportunityId !== "number") {
            throw new Error("Valid opportunity ID is required");
          }
          if (!proposal.accountId || typeof proposal.accountId !== "number") {
            throw new Error("Valid account ID is required");
          }
          const createdAt = /* @__PURE__ */ new Date();
          let parsedExpiresAt = null;
          if (proposal.expiresAt) {
            if (typeof proposal.expiresAt === "string" && proposal.expiresAt.match(/^\d{4}-\d{2}-\d{2}/)) {
              parsedExpiresAt = new Date(proposal.expiresAt);
            } else if (proposal.expiresAt instanceof Date) {
              parsedExpiresAt = proposal.expiresAt;
            }
            if (parsedExpiresAt && isNaN(parsedExpiresAt.getTime())) {
              console.warn("Invalid date detected, setting expiresAt to null");
              parsedExpiresAt = null;
            }
          }
          const proposalData = {
            name: proposal.name,
            opportunityId: proposal.opportunityId,
            accountId: proposal.accountId,
            createdBy: proposal.createdBy,
            status: proposal.status || "Draft",
            content: proposal.content || {},
            metadata: proposal.metadata || {},
            templateId: proposal.templateId,
            expiresAt: parsedExpiresAt,
            createdAt,
            updatedAt: createdAt
          };
          console.log("Validated proposal data for DB insert:", JSON.stringify(proposalData, null, 2));
          const [newProposal] = await db.insert(proposals).values(proposalData).returning();
          console.log("New proposal created successfully:", JSON.stringify(newProposal, null, 2));
          try {
            await this.createProposalActivity({
              proposalId: newProposal.id,
              userId: proposal.createdBy,
              activityType: "Created",
              description: "Proposal was created"
            });
          } catch (activityError) {
            console.error("Failed to create activity log, but proposal was created:", activityError);
          }
          return newProposal;
        } catch (error) {
          console.error("Database error in createProposal:", error);
          const errorMessage = error.message || "Failed to create proposal";
          if (error.code) {
            if (error.code === "23503") {
              if (error.detail?.includes("opportunityId")) {
                throw new Error("The specified opportunity does not exist");
              } else if (error.detail?.includes("accountId")) {
                throw new Error("The specified account does not exist");
              } else if (error.detail?.includes("createdBy")) {
                throw new Error("The specified user does not exist");
              }
            } else if (error.code === "23502") {
              throw new Error(`Required field missing: ${error.column || errorMessage}`);
            }
          }
          throw new Error(errorMessage);
        }
      }
      async updateProposal(id, proposal) {
        try {
          const [originalProposal] = await db.select().from(proposals).where(eq5(proposals.id, id));
          if (!originalProposal) {
            return void 0;
          }
          let cleanProposal = { ...proposal };
          if (proposal.expiresAt) {
            if (typeof proposal.expiresAt === "string" && proposal.expiresAt.match(/^\d{4}-\d{2}-\d{2}/)) {
              cleanProposal.expiresAt = new Date(proposal.expiresAt);
            } else if (proposal.expiresAt instanceof Date) {
              cleanProposal.expiresAt = proposal.expiresAt;
            } else {
              console.warn("Invalid expiresAt date detected, removing from update data");
              delete cleanProposal.expiresAt;
            }
            if (cleanProposal.expiresAt && cleanProposal.expiresAt instanceof Date && isNaN(cleanProposal.expiresAt.getTime())) {
              console.warn("Invalid date detected, removing expiresAt from update data");
              delete cleanProposal.expiresAt;
            }
          }
          const updateData = {
            ...cleanProposal,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (proposal.status && proposal.status !== originalProposal.status) {
            if (proposal.status === "Sent") {
              updateData.sentAt = /* @__PURE__ */ new Date();
            } else if (proposal.status === "Accepted") {
              updateData.acceptedAt = /* @__PURE__ */ new Date();
            } else if (proposal.status === "Rejected") {
              updateData.rejectedAt = /* @__PURE__ */ new Date();
            }
          }
          const [updatedProposal] = await db.update(proposals).set(updateData).where(eq5(proposals.id, id)).returning();
          if (proposal.status && proposal.status !== originalProposal.status) {
            await this.createProposalActivity({
              proposalId: id,
              userId: proposal.updatedBy || null,
              activityType: "Status Changed",
              description: `Status changed from ${originalProposal.status} to ${proposal.status}`
            });
          }
          return updatedProposal;
        } catch (error) {
          console.error("Database error in updateProposal:", error);
          return void 0;
        }
      }
      async deleteProposal(id) {
        try {
          console.log("Deleting proposal with ID:", id);
          await db.delete(proposalElements).where(eq5(proposalElements.proposalId, id));
          await db.delete(proposalCollaborators).where(eq5(proposalCollaborators.proposalId, id));
          await db.delete(proposalComments).where(eq5(proposalComments.proposalId, id));
          await db.delete(proposalActivities).where(eq5(proposalActivities.proposalId, id));
          const result = await db.delete(proposals).where(eq5(proposals.id, id));
          return result.rowCount > 0;
        } catch (error) {
          console.error("Database error in deleteProposal:", error);
          return false;
        }
      }
      // Proposal Element Methods
      async getProposalElement(id) {
        try {
          const [element] = await db.select().from(proposalElements).where(eq5(proposalElements.id, id));
          return element;
        } catch (error) {
          console.error("Database error in getProposalElement:", error);
          return void 0;
        }
      }
      async listProposalElements(proposalId) {
        try {
          console.log("Listing proposal elements for proposalId:", proposalId);
          return await db.select().from(proposalElements).where(eq5(proposalElements.proposalId, proposalId)).orderBy(asc2(proposalElements.sortOrder));
        } catch (error) {
          console.error("Database error in listProposalElements:", error);
          return [];
        }
      }
      async createProposalElement(element) {
        try {
          let sortOrder = element.sortOrder;
          if (sortOrder === void 0) {
            sortOrder = 10;
          }
          const createdAt = /* @__PURE__ */ new Date();
          const [newElement] = await db.insert(proposalElements).values({
            ...element,
            createdAt,
            updatedAt: createdAt,
            sortOrder
          }).returning();
          await this.createProposalActivity({
            proposalId: element.proposalId,
            userId: element.createdBy || null,
            activityType: "Element Added",
            description: `Added ${element.elementType} element`
          });
          return newElement;
        } catch (error) {
          console.error("Database error in createProposalElement:", error);
          throw new Error("Failed to create proposal element");
        }
      }
      async updateProposalElement(id, element) {
        try {
          const currentElement = await this.getProposalElement(id);
          if (!currentElement) {
            console.error(`Element with ID ${id} not found`);
            return void 0;
          }
          console.log(`Updating element ${id} with:`, {
            name: element.name,
            contentType: typeof element.content,
            contentLength: element.content ? typeof element.content === "string" ? element.content.length : JSON.stringify(element.content).length : 0
          });
          let sanitizedContent = element.content;
          if (sanitizedContent && typeof sanitizedContent === "object") {
            sanitizedContent = JSON.stringify(sanitizedContent);
          }
          const result = await db.query.proposalElements.findMany({
            where: eq5(proposalElements.id, id),
            limit: 1
          });
          if (result.length === 0) {
            console.error(`Element with ID ${id} not found in query`);
            return void 0;
          }
          const updateResult = await db.execute(sql`
        UPDATE proposal_elements 
        SET 
          name = ${element.name || currentElement.name},
          content = ${sanitizedContent || currentElement.content},
          updated_at = NOW()
        WHERE id = ${id}
        RETURNING *
      `);
          if (!updateResult.rows || updateResult.rows.length === 0) {
            console.error("No rows returned from update");
            return void 0;
          }
          const updatedElement = await this.getProposalElement(id);
          if (updatedElement && currentElement.proposalId) {
            await this.createProposalActivity({
              proposalId: currentElement.proposalId,
              userId: element.updatedBy || currentElement.createdBy || null,
              activityType: "Element Updated",
              description: `Updated ${updatedElement.elementType} element`
            });
          }
          return updatedElement;
        } catch (error) {
          console.error("Database error in updateProposalElement:", error);
          return void 0;
        }
      }
      async deleteProposalElement(id) {
        try {
          const [element] = await db.select().from(proposalElements).where(eq5(proposalElements.id, id));
          if (!element) {
            return false;
          }
          const result = await db.delete(proposalElements).where(eq5(proposalElements.id, id));
          if (result.rowCount > 0) {
            await this.createProposalActivity({
              proposalId: element.proposalId,
              userId: null,
              // No user ID available in this context
              activityType: "Element Removed",
              description: `Removed ${element.elementType} element`
            });
            return true;
          }
          return false;
        } catch (error) {
          console.error("Database error in deleteProposalElement:", error);
          return false;
        }
      }
      // Proposal Collaborator Methods
      async getProposalCollaborator(id) {
        try {
          const [collaborator] = await db.select().from(proposalCollaborators).where(eq5(proposalCollaborators.id, id));
          return collaborator;
        } catch (error) {
          console.error("Database error in getProposalCollaborator:", error);
          return void 0;
        }
      }
      async getProposalCollaborators(proposalId) {
        try {
          const collaborators = await db.select().from(proposalCollaborators).where(eq5(proposalCollaborators.proposalId, proposalId));
          return await Promise.all(collaborators.map(async (collab) => {
            const user = await this.getUser(collab.userId);
            return { ...collab, user };
          }));
        } catch (error) {
          console.error("Database error in getProposalCollaborators:", error);
          return [];
        }
      }
      async addProposalCollaborator(collaborator) {
        try {
          const existingCollaborators = await db.select().from(proposalCollaborators).where(and3(
            eq5(proposalCollaborators.proposalId, collaborator.proposalId),
            eq5(proposalCollaborators.userId, collaborator.userId)
          ));
          if (existingCollaborators.length > 0) {
            throw new Error("User is already a collaborator on this proposal");
          }
          const [newCollaborator] = await db.insert(proposalCollaborators).values({
            ...collaborator,
            addedAt: /* @__PURE__ */ new Date(),
            notifications: collaborator.notifications === void 0 ? true : collaborator.notifications
          }).returning();
          const user = await this.getUser(collaborator.userId);
          await this.createProposalActivity({
            proposalId: collaborator.proposalId,
            userId: collaborator.addedBy,
            activityType: "Collaborator Added",
            description: `Added ${user?.firstName} ${user?.lastName} as ${collaborator.role} collaborator`
          });
          return newCollaborator;
        } catch (error) {
          console.error("Database error in addProposalCollaborator:", error);
          throw new Error("Failed to add collaborator: " + error.message);
        }
      }
      async updateProposalCollaborator(id, collaborator) {
        try {
          const [originalCollaborator] = await db.select().from(proposalCollaborators).where(eq5(proposalCollaborators.id, id));
          if (!originalCollaborator) {
            return void 0;
          }
          const [updatedCollaborator] = await db.update(proposalCollaborators).set(collaborator).where(eq5(proposalCollaborators.id, id)).returning();
          if (collaborator.role && collaborator.role !== originalCollaborator.role) {
            const user = await this.getUser(originalCollaborator.userId);
            await this.createProposalActivity({
              proposalId: originalCollaborator.proposalId,
              userId: null,
              // No user ID available in this context
              activityType: "Collaborator Updated",
              description: `Changed ${user?.firstName} ${user?.lastName}'s role from ${originalCollaborator.role} to ${collaborator.role}`
            });
          }
          return updatedCollaborator;
        } catch (error) {
          console.error("Database error in updateProposalCollaborator:", error);
          return void 0;
        }
      }
      async deleteProposalCollaborator(id) {
        try {
          const [collaborator] = await db.select().from(proposalCollaborators).where(eq5(proposalCollaborators.id, id));
          if (!collaborator) {
            return false;
          }
          const result = await db.delete(proposalCollaborators).where(eq5(proposalCollaborators.id, id));
          if (result.rowCount > 0) {
            const user = await this.getUser(collaborator.userId);
            await this.createProposalActivity({
              proposalId: collaborator.proposalId,
              userId: null,
              // No user ID available in this context
              activityType: "Collaborator Removed",
              description: `Removed ${user?.firstName} ${user?.lastName} as collaborator`
            });
            return true;
          }
          return false;
        } catch (error) {
          console.error("Database error in deleteProposalCollaborator:", error);
          return false;
        }
      }
      // Proposal Comment Methods
      async getProposalComment(id) {
        try {
          const [comment] = await db.select().from(proposalComments).where(eq5(proposalComments.id, id));
          return comment;
        } catch (error) {
          console.error("Database error in getProposalComment:", error);
          return void 0;
        }
      }
      async getProposalComments(proposalId) {
        try {
          const comments = await db.select().from(proposalComments).where(eq5(proposalComments.proposalId, proposalId)).orderBy(proposalComments.createdAt);
          return await Promise.all(comments.map(async (comment) => {
            const user = await this.getUser(comment.userId);
            return { ...comment, user };
          }));
        } catch (error) {
          console.error("Database error in getProposalComments:", error);
          return [];
        }
      }
      async createProposalComment(comment) {
        try {
          const createdAt = /* @__PURE__ */ new Date();
          const [newComment] = await db.insert(proposalComments).values({
            ...comment,
            createdAt,
            resolved: false,
            resolvedBy: null,
            resolvedAt: null
          }).returning();
          await this.createProposalActivity({
            proposalId: comment.proposalId,
            userId: comment.userId,
            activityType: "Comment Added",
            description: comment.parentId ? "Added reply to comment" : "Added new comment"
          });
          return newComment;
        } catch (error) {
          console.error("Database error in createProposalComment:", error);
          throw new Error("Failed to create comment");
        }
      }
      async updateProposalComment(id, comment) {
        try {
          const [originalComment] = await db.select().from(proposalComments).where(eq5(proposalComments.id, id));
          if (!originalComment) {
            return void 0;
          }
          const updateData = {
            ...comment,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (comment.resolved === true && originalComment.resolved !== true) {
            updateData.resolvedAt = /* @__PURE__ */ new Date();
          }
          const [updatedComment] = await db.update(proposalComments).set(updateData).where(eq5(proposalComments.id, id)).returning();
          if (comment.resolved === true && originalComment.resolved !== true) {
            await this.createProposalActivity({
              proposalId: originalComment.proposalId,
              userId: comment.resolvedBy || null,
              activityType: "Comment Resolved",
              description: "Resolved comment"
            });
          }
          return updatedComment;
        } catch (error) {
          console.error("Database error in updateProposalComment:", error);
          return void 0;
        }
      }
      async deleteProposalComment(id) {
        try {
          const [comment] = await db.select().from(proposalComments).where(eq5(proposalComments.id, id));
          if (!comment) {
            return false;
          }
          await db.delete(proposalComments).where(eq5(proposalComments.parentId, id));
          const result = await db.delete(proposalComments).where(eq5(proposalComments.id, id));
          if (result.rowCount > 0) {
            await this.createProposalActivity({
              proposalId: comment.proposalId,
              userId: null,
              // No user ID available in this context
              activityType: "Comment Deleted",
              description: "Deleted comment"
            });
            return true;
          }
          return false;
        } catch (error) {
          console.error("Database error in deleteProposalComment:", error);
          return false;
        }
      }
      // Proposal Activity Methods
      async createProposalActivity(activity) {
        try {
          const createdAt = /* @__PURE__ */ new Date();
          const processedActivity = {
            ...activity,
            createdAt
          };
          if ("action" in activity && !("activityType" in activity)) {
            processedActivity.activityType = activity["action"];
          }
          if ("detail" in activity && !("description" in activity)) {
            processedActivity.description = activity["detail"];
          }
          delete processedActivity.action;
          delete processedActivity.detail;
          const [newActivity] = await db.insert(proposalActivities).values(processedActivity).returning();
          return newActivity;
        } catch (error) {
          console.error("Database error in createProposalActivity:", error);
          throw new Error("Failed to create activity log");
        }
      }
      async getProposalActivities(proposalId) {
        try {
          const activities2 = await db.select().from(proposalActivities).where(eq5(proposalActivities.proposalId, proposalId)).orderBy(desc2(proposalActivities.createdAt));
          return await Promise.all(activities2.map(async (activity) => {
            const user = activity.userId ? await this.getUser(activity.userId) : void 0;
            return { ...activity, user };
          }));
        } catch (error) {
          console.error("Database error in getProposalActivities:", error);
          return [];
        }
      }
      // Permission Management Methods
      async getModulePermissions() {
        return Array.from(this.modulePermissions.values());
      }
      async getModuleByName(moduleName) {
        for (const module of this.modulePermissions.values()) {
          if (module.moduleName === moduleName) {
            return module;
          }
        }
        return void 0;
      }
      async createModulePermission(moduleData) {
        const id = this.modulePermissionIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const module = {
          id,
          createdAt,
          moduleName: moduleData.moduleName || "",
          displayName: moduleData.displayName || moduleData.moduleName || "",
          description: moduleData.description || "",
          icon: moduleData.icon || "box",
          isActive: moduleData.isActive !== void 0 ? moduleData.isActive : true,
          order: moduleData.order || 0
        };
        this.modulePermissions.set(id, module);
        return module;
      }
      async updateModulePermission(id, moduleData) {
        const existingModule = this.modulePermissions.get(id);
        if (!existingModule) {
          return void 0;
        }
        const updatedModule = {
          ...existingModule,
          ...moduleData
        };
        this.modulePermissions.set(id, updatedModule);
        return updatedModule;
      }
      async deleteModulePermission(id) {
        return this.modulePermissions.delete(id);
      }
      async getRolePermissions(role) {
        const permissions = [];
        for (const permission of this.rolePermissions.values()) {
          if (permission.role === role) {
            permissions.push(permission);
          }
        }
        return permissions;
      }
      async getRolePermission(role, moduleId, action) {
        for (const permission of this.rolePermissions.values()) {
          if (permission.role === role && permission.moduleId === moduleId && permission.action === action) {
            return permission;
          }
        }
        return void 0;
      }
      async createRolePermission(permissionData) {
        const id = this.rolePermissionIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const permission = {
          id,
          moduleId: permissionData.moduleId || 0,
          action: permissionData.action || "",
          isAllowed: permissionData.isAllowed !== void 0 ? permissionData.isAllowed : false,
          role: permissionData.role || "User",
          createdAt
        };
        this.rolePermissions.set(id, permission);
        return permission;
      }
      async updateRolePermission(id, permissionData) {
        const existingPermission = this.rolePermissions.get(id);
        if (!existingPermission) {
          return void 0;
        }
        const updatedPermission = {
          ...existingPermission,
          ...permissionData,
          // Ensure we don't overwrite these fields even if provided
          id: existingPermission.id,
          createdAt: existingPermission.createdAt
        };
        this.rolePermissions.set(id, updatedPermission);
        return updatedPermission;
      }
      async deleteRolePermission(id) {
        return this.rolePermissions.delete(id);
      }
      async getUserPermissions(userId) {
        const permissions = [];
        for (const permission of this.userPermissions.values()) {
          if (permission.userId === userId) {
            permissions.push(permission);
          }
        }
        return permissions;
      }
      async getUserPermission(userId, moduleId, action) {
        for (const permission of this.userPermissions.values()) {
          if (permission.userId === userId && permission.moduleId === moduleId && permission.action === action) {
            return permission;
          }
        }
        return void 0;
      }
      async createUserPermission(permissionData) {
        const id = this.userPermissionIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const permission = {
          id,
          userId: permissionData.userId || 0,
          moduleId: permissionData.moduleId || 0,
          action: permissionData.action || "",
          isAllowed: permissionData.isAllowed !== void 0 ? permissionData.isAllowed : false,
          createdAt
        };
        this.userPermissions.set(id, permission);
        return permission;
      }
      async updateUserPermission(id, permissionData) {
        const existingPermission = this.userPermissions.get(id);
        if (!existingPermission) {
          return void 0;
        }
        const updatedPermission = {
          ...existingPermission,
          ...permissionData,
          // Ensure we don't overwrite these fields even if provided
          id: existingPermission.id,
          createdAt: existingPermission.createdAt
        };
        this.userPermissions.set(id, updatedPermission);
        return updatedPermission;
      }
      async deleteUserPermission(id) {
        return this.userPermissions.delete(id);
      }
      async getTeams() {
        return Array.from(this.teams.values());
      }
      async listTeams() {
        return this.getTeams();
      }
      async getTeam(id) {
        return this.teams.get(id);
      }
      async createTeam(teamData) {
        const id = this.teamIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const team = {
          id,
          name: teamData.name || "",
          description: teamData.description || "",
          leaderId: teamData.leaderId || 0,
          isActive: teamData.isActive !== void 0 ? teamData.isActive : true,
          createdAt
        };
        this.teams.set(id, team);
        return team;
      }
      async updateTeam(id, teamData) {
        const existingTeam = this.teams.get(id);
        if (!existingTeam) {
          return void 0;
        }
        const updatedTeam = {
          ...existingTeam,
          ...teamData,
          // Ensure we don't overwrite these fields even if provided
          id: existingTeam.id,
          createdAt: existingTeam.createdAt
        };
        this.teams.set(id, updatedTeam);
        return updatedTeam;
      }
      async deleteTeam(id) {
        return this.teams.delete(id);
      }
      async getTeamMembers(teamId) {
        const members = [];
        for (const member of this.teamMembers.values()) {
          if (member.teamId === teamId) {
            members.push(member);
          }
        }
        return members;
      }
      async getTeamMember(id) {
        return this.teamMembers.get(id);
      }
      async createTeamMember(memberData) {
        const id = this.teamMemberIdCounter++;
        const createdAt = /* @__PURE__ */ new Date();
        const member = {
          id,
          teamId: memberData.teamId || 0,
          userId: memberData.userId || 0,
          role: memberData.role || "Member",
          createdAt
        };
        this.teamMembers.set(id, member);
        return member;
      }
      async updateTeamMember(id, memberData) {
        const existingMember = this.teamMembers.get(id);
        if (!existingMember) {
          return void 0;
        }
        const updatedMember = {
          ...existingMember,
          ...memberData,
          // Ensure we don't overwrite these fields even if provided
          id: existingMember.id,
          createdAt: existingMember.createdAt
        };
        this.teamMembers.set(id, updatedMember);
        return updatedMember;
      }
      async deleteTeamMember(id) {
        return this.teamMembers.delete(id);
      }
      async getAssignments(entityType, entityId) {
        const assignments3 = [];
        for (const assignment of this.assignments.values()) {
          if (assignment.entityType === entityType && assignment.entityId === entityId) {
            assignments3.push(assignment);
          }
        }
        return assignments3;
      }
      async createAssignment(assignmentData) {
        const id = this.assignmentIdCounter++;
        const assignedAt = /* @__PURE__ */ new Date();
        const assignment = {
          id,
          entityType: assignmentData.entityType || "",
          entityId: assignmentData.entityId || 0,
          assignedToType: assignmentData.assignedToType || "User",
          assignedToId: assignmentData.assignedToId || 0,
          assignedAt
        };
        this.assignments.set(id, assignment);
        return assignment;
      }
      async deleteAssignment(id) {
        return this.assignments.delete(id);
      }
      async checkUserEntityAccess(userId, entityType, entityId) {
        const user = await this.getUser(userId);
        if (!user) {
          return false;
        }
        if (user.role === "Administrator") {
          return true;
        }
        const entity = await this.getEntityById(entityType, entityId);
        if (!entity) {
          return false;
        }
        if (entity.ownerId === userId) {
          return true;
        }
        const assignments3 = await this.getAssignments(entityType, entityId);
        const isAssignedToUser = assignments3.some(
          (a) => a.assignedToType === "User" && a.assignedToId === userId
        );
        if (isAssignedToUser) {
          return true;
        }
        const isAssignedToUserTeam = await this.checkTeamEntityAccess(userId, entityType, entityId);
        if (isAssignedToUserTeam) {
          return true;
        }
        return false;
      }
      async checkTeamEntityAccess(userId, entityType, entityId) {
        const userTeams = [];
        for (const member of this.teamMembers.values()) {
          if (member.userId === userId) {
            userTeams.push(member.teamId);
          }
        }
        if (userTeams.length === 0) {
          return false;
        }
        const assignments3 = await this.getAssignments(entityType, entityId);
        const isAssignedToUserTeam = assignments3.some(
          (a) => a.assignedToType === "Team" && userTeams.includes(a.assignedToId)
        );
        return isAssignedToUserTeam;
      }
      async getEntityById(entityType, entityId) {
        switch (entityType.toLowerCase()) {
          case "contact":
            return this.getContact(entityId);
          case "account":
            return this.getAccount(entityId);
          case "lead":
            return this.getLead(entityId);
          case "opportunity":
            return this.getOpportunity(entityId);
          case "task":
            return this.getTask(entityId);
          case "event":
            return this.getEvent(entityId);
          case "product":
            return this.getProduct(entityId);
          case "invoice":
            return this.getInvoice(entityId);
          case "purchaseorder":
            return this.getPurchaseOrder(entityId);
          default:
            return void 0;
        }
      }
      async initializePermissions() {
        const modules = [
          { moduleName: "dashboard", displayName: "Dashboard", icon: "home", order: 1 },
          { moduleName: "contacts", displayName: "Contacts", icon: "users", order: 2 },
          { moduleName: "accounts", displayName: "Accounts", icon: "briefcase", order: 3 },
          { moduleName: "leads", displayName: "Leads", icon: "user-plus", order: 4 },
          { moduleName: "opportunities", displayName: "Opportunities", icon: "target", order: 5 },
          { moduleName: "tasks", displayName: "Tasks", icon: "check-square", order: 6 },
          { moduleName: "calendar", displayName: "Calendar", icon: "calendar", order: 7 },
          { moduleName: "communications", displayName: "Communications", icon: "message-circle", order: 8 },
          { moduleName: "reports", displayName: "Reports", icon: "bar-chart-2", order: 9 },
          { moduleName: "products", displayName: "Products", icon: "package", order: 10 },
          { moduleName: "inventory", displayName: "Inventory", icon: "database", order: 11 },
          { moduleName: "invoices", displayName: "Invoices", icon: "file-text", order: 12 },
          { moduleName: "purchaseorders", displayName: "Purchase Orders", icon: "shopping-cart", order: 13 },
          { moduleName: "settings", displayName: "Settings", icon: "settings", order: 14 },
          { moduleName: "workflows", displayName: "Workflows", icon: "git-branch", order: 15 },
          { moduleName: "api", displayName: "API Management", icon: "code", order: 16 }
        ];
        for (const module of modules) {
          await this.createModulePermission(module);
        }
        const actions = ["view", "create", "update", "delete", "export", "import", "assign"];
        const roles = ["Administrator", "Manager", "User", "ReadOnly"];
        for (const modulePermission of this.modulePermissions.values()) {
          for (const role of roles) {
            for (const action of actions) {
              let isAllowed = role === "Administrator";
              if (role === "Manager") {
                isAllowed = action !== "delete" || !["settings", "api", "workflows"].includes(modulePermission.moduleName);
              }
              if (role === "User") {
                if (["settings", "api", "workflows"].includes(modulePermission.moduleName)) {
                  isAllowed = false;
                } else if (action === "view" || action === "create") {
                  isAllowed = true;
                } else if (action === "update" || action === "assign") {
                  isAllowed = !["reports"].includes(modulePermission.moduleName);
                } else {
                  isAllowed = false;
                }
              }
              if (role === "ReadOnly") {
                isAllowed = action === "view";
              }
              await this.createRolePermission({
                role,
                moduleId: modulePermission.id,
                action,
                isAllowed
              });
            }
          }
        }
      }
      // System Settings Methods
      async saveSystemSettings(userId, settings) {
        try {
          const existingMenuSettings = await db.select().from(systemSettings).where(eq5(systemSettings.userId, userId)).where(eq5(systemSettings.settingKey, "menuVisibility"));
          const now = /* @__PURE__ */ new Date();
          if (existingMenuSettings.length > 0) {
            await db.update(systemSettings).set({
              settingValue: settings.menuVisibility,
              updatedAt: now
            }).where(eq5(systemSettings.id, existingMenuSettings[0].id));
          } else {
            await db.insert(systemSettings).values({
              userId,
              settingKey: "menuVisibility",
              settingValue: settings.menuVisibility,
              scope: "user",
              createdAt: now,
              updatedAt: now
            });
          }
          const existingDashboardSettings = await db.select().from(systemSettings).where(eq5(systemSettings.userId, userId)).where(eq5(systemSettings.settingKey, "dashboardPreferences"));
          if (existingDashboardSettings.length > 0) {
            await db.update(systemSettings).set({
              settingValue: settings.dashboardPreferences,
              updatedAt: now
            }).where(eq5(systemSettings.id, existingDashboardSettings[0].id));
          } else {
            await db.insert(systemSettings).values({
              userId,
              settingKey: "dashboardPreferences",
              settingValue: settings.dashboardPreferences,
              scope: "user",
              createdAt: now,
              updatedAt: now
            });
          }
          return settings;
        } catch (error) {
          console.error("Database error in saveSystemSettings:", error);
          throw new Error("Failed to save system settings");
        }
      }
    };
    DatabaseStorage.prototype.listTeams = async function() {
      try {
        return await db.select().from(teams);
      } catch (error) {
        console.error("Database error in listTeams:", error);
        return [];
      }
    };
    DatabaseStorage.prototype.getAllTeams = async function() {
      return this.listTeams();
    };
    DatabaseStorage.prototype.getTeamById = async function(id) {
      try {
        const [team] = await db.select().from(teams).where(eq5(teams.id, id));
        return team || void 0;
      } catch (error) {
        console.error("Database error in getTeamById:", error);
        return void 0;
      }
    };
    DatabaseStorage.prototype.updateTeam = async function(id, updates) {
      try {
        const [updatedTeam] = await db.update(teams).set(updates).where(eq5(teams.id, id)).returning();
        return updatedTeam;
      } catch (error) {
        console.error("Database error in updateTeam:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.deleteTeam = async function(id) {
      try {
        await db.delete(teams).where(eq5(teams.id, id));
        return true;
      } catch (error) {
        console.error("Database error in deleteTeam:", error);
        return false;
      }
    };
    DatabaseStorage.prototype.getTeamMembers = async function(teamId) {
      try {
        const members = await db.select({
          teamMember: teamMembers,
          user: users
        }).from(teamMembers).leftJoin(users, eq5(teamMembers.userId, users.id)).where(eq5(teamMembers.teamId, teamId));
        return members.map(({ teamMember, user }) => ({ ...teamMember, user }));
      } catch (error) {
        console.error("Database error in getTeamMembers:", error);
        return [];
      }
    };
    DatabaseStorage.prototype.addTeamMember = async function(member) {
      try {
        const [newMember] = await db.insert(teamMembers).values(member).returning();
        return newMember;
      } catch (error) {
        console.error("Database error in addTeamMember:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.updateTeamMember = async function(id, updates) {
      try {
        const [updatedMember] = await db.update(teamMembers).set(updates).where(eq5(teamMembers.id, id)).returning();
        return updatedMember;
      } catch (error) {
        console.error("Database error in updateTeamMember:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.removeTeamMember = async function(id) {
      try {
        await db.delete(teamMembers).where(eq5(teamMembers.id, id));
        return true;
      } catch (error) {
        console.error("Database error in removeTeamMember:", error);
        return false;
      }
    };
    DatabaseStorage.prototype.listTeams = async function() {
      try {
        return await db.select().from(teams).orderBy(teams.name);
      } catch (error) {
        console.error("Database error in listTeams:", error);
        return [];
      }
    };
    DatabaseStorage.prototype.getAllTeams = async function() {
      return this.listTeams();
    };
    DatabaseStorage.prototype.getTeamById = async function(id) {
      try {
        const [team] = await db.select().from(teams).where(eq5(teams.id, id));
        return team || void 0;
      } catch (error) {
        console.error("Database error in getTeamById:", error);
        return void 0;
      }
    };
    DatabaseStorage.prototype.createTeam = async function(team) {
      try {
        const [newTeam] = await db.insert(teams).values(team).returning();
        return newTeam;
      } catch (error) {
        console.error("Database error in createTeam:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.updateTeam = async function(id, updates) {
      try {
        const [updatedTeam] = await db.update(teams).set(updates).where(eq5(teams.id, id)).returning();
        return updatedTeam;
      } catch (error) {
        console.error("Database error in updateTeam:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.deleteTeam = async function(id) {
      try {
        await db.delete(teams).where(eq5(teams.id, id));
        return true;
      } catch (error) {
        console.error("Database error in deleteTeam:", error);
        return false;
      }
    };
    DatabaseStorage.prototype.getTeamMembers = async function(teamId) {
      try {
        const members = await db.select({
          teamMember: teamMembers,
          user: users
        }).from(teamMembers).leftJoin(users, eq5(teamMembers.userId, users.id)).where(eq5(teamMembers.teamId, teamId));
        return members.map(({ teamMember, user }) => ({ ...teamMember, user }));
      } catch (error) {
        console.error("Database error in getTeamMembers:", error);
        return [];
      }
    };
    DatabaseStorage.prototype.addTeamMember = async function(member) {
      try {
        const [newMember] = await db.insert(teamMembers).values(member).returning();
        return newMember;
      } catch (error) {
        console.error("Database error in addTeamMember:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.updateTeamMember = async function(id, updates) {
      try {
        const [updatedMember] = await db.update(teamMembers).set(updates).where(eq5(teamMembers.id, id)).returning();
        return updatedMember;
      } catch (error) {
        console.error("Database error in updateTeamMember:", error);
        throw error;
      }
    };
    DatabaseStorage.prototype.removeTeamMember = async function(id) {
      try {
        await db.delete(teamMembers).where(eq5(teamMembers.id, id));
        return true;
      } catch (error) {
        console.error("Database error in removeTeamMember:", error);
        return false;
      }
    };
    useDatabase = true;
    if (useDatabase) {
      const dbStorage = new DatabaseStorage();
      addSocialIntegrationsToDatabaseStorage(dbStorage);
      addApiKeysToDatabaseStorage(dbStorage);
      addCommunicationsToDatabase(dbStorage);
      addPermissionsToDatabaseStorage(dbStorage);
      DatabaseStorage.prototype.listTeamMembers = DatabaseStorage.prototype.getTeamMembers;
      DatabaseStorage.prototype.createTeamMember = DatabaseStorage.prototype.addTeamMember;
      DatabaseStorage.prototype.deleteTeamMember = DatabaseStorage.prototype.removeTeamMember;
      DatabaseStorage.prototype.listAssignments = DatabaseStorage.prototype.getAssignmentsByEntity;
      storage = dbStorage;
    } else {
      const memStorage = new MemStorage();
      addSocialIntegrationsToMemStorage(memStorage);
      addApiKeysToMemStorage(memStorage);
      addCommunicationsToMemStorage(memStorage);
      addPermissionsToMemStorage(memStorage);
      storage = memStorage;
      initializeSubscriptionPackages(storage);
    }
  }
});

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session2 from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  const hash = `${buf.toString("hex")}.${salt}`;
  console.log("Generated password hash:", hash.substring(0, 20) + "..." + hash.substring(hash.length - 10));
  return hash;
}
async function comparePasswords(supplied, stored) {
  try {
    console.log("Comparing passwords:");
    console.log("Supplied (masked):", supplied.charAt(0) + "*".repeat(supplied.length - 2) + supplied.charAt(supplied.length - 1));
    console.log("Stored format:", stored.substring(0, 20) + "..." + stored.substring(stored.length - 10));
    const [hashed, salt] = stored.split(".");
    if (!hashed || !salt) {
      console.error("Invalid stored password format - missing hash or salt");
      return false;
    }
    console.log("Hash length:", hashed.length, "Salt length:", salt.length);
    const hashedBuf = Buffer.from(hashed, "hex");
    console.log("Creating supplied hash using salt...");
    const suppliedBuf = await scryptAsync(supplied, salt, 64);
    if (hashedBuf.length !== suppliedBuf.length) {
      console.error("Buffer length mismatch in password comparison");
      console.log("Hashed buffer length:", hashedBuf.length, "Supplied buffer length:", suppliedBuf.length);
      return false;
    }
    const result = timingSafeEqual(hashedBuf, suppliedBuf);
    console.log("Password comparison result:", result);
    return result;
  } catch (error) {
    console.error("Error comparing passwords:", error);
    return false;
  }
}
function setupAuth(app2) {
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "averox_super_secret_session_key",
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      maxAge: 1e3 * 60 * 60 * 24 * 7
      // 1 week
    }
  };
  app2.set("trust proxy", 1);
  app2.use(session2(sessionSettings));
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user || !await comparePasswords(password, user.password)) {
          return done(null, false);
        } else {
          const now = /* @__PURE__ */ new Date();
          storage.updateUser(user.id, { lastLogin: now });
          return done(null, user);
        }
      } catch (error) {
        return done(error);
      }
    })
  );
  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error);
    }
  });
  app2.post("/api/register", async (req, res, next) => {
    try {
      const { username, password, email, firstName, lastName, role } = req.body;
      if (!username || !password || !email) {
        return res.status(400).json({ error: "Username, password, and email are required" });
      }
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Username already exists" });
      }
      const user = await storage.createUser({
        username,
        email,
        firstName,
        lastName,
        role,
        password: await hashPassword(password)
      });
      req.login(user, (err) => {
        if (err) return next(err);
        const { password: password2, ...userWithoutPassword } = user;
        res.status(201).json(userWithoutPassword);
      });
    } catch (error) {
      next(error);
    }
  });
  app2.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err, user) => {
      if (err) {
        return next(err);
      }
      if (!user) {
        return res.status(401).json({ error: "Invalid username or password" });
      }
      if (req.body.rememberMe) {
        if (req.session.cookie) {
          req.session.cookie.maxAge = 30 * 24 * 60 * 60 * 1e3;
        }
      } else {
        if (req.session.cookie) {
          req.session.cookie.expires = void 0;
        }
      }
      req.login(user, (err2) => {
        if (err2) {
          return next(err2);
        }
        const { password, ...userWithoutPassword } = user;
        return res.status(200).json(userWithoutPassword);
      });
    })(req, res, next);
  });
  app2.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });
  app2.post("/api/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(200).json({ message: "If the email exists, password reset instructions have been sent" });
      }
      const resetToken = randomBytes(32).toString("hex");
      const resetExpiry = new Date(Date.now() + 36e5);
      console.log(`Password reset requested for ${email}`);
      console.log(`Reset token: ${resetToken}`);
      console.log(`Reset expires: ${resetExpiry}`);
      res.status(200).json({
        message: "Password reset instructions have been sent to your email",
        // In development, include the token for testing
        ...process.env.NODE_ENV === "development" && { resetToken, resetExpiry }
      });
    } catch (error) {
      console.error("Forgot password error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const { password, ...userWithoutPassword } = req.user;
    res.json(userWithoutPassword);
  });
}
var scryptAsync;
var init_auth = __esm({
  "server/auth.ts"() {
    "use strict";
    init_storage();
    scryptAsync = promisify(scrypt);
  }
});

// server/create-demo-users.ts
var create_demo_users_exports = {};
import { eq as eq8 } from "drizzle-orm";
async function createDemoUsers() {
  console.log("Creating demo user accounts for the AVEROX CRM system...");
  const existingAdmin = await db.select().from(users).where(eq8(users.username, "demoadmin"));
  if (existingAdmin.length === 0) {
    const [demoAdmin] = await db.insert(users).values({
      username: "demoadmin",
      password: await hashPassword("demoadmin123"),
      firstName: "Demo",
      lastName: "Admin",
      email: "demoadmin@averox.com",
      role: "Admin",
      isActive: true,
      isVerified: true,
      createdAt: /* @__PURE__ */ new Date()
    }).returning();
    console.log(`Created demo admin account with ID: ${demoAdmin.id}`);
  } else {
    console.log(`Demo admin account already exists with ID: ${existingAdmin[0].id}`);
  }
  const existingUser = await db.select().from(users).where(eq8(users.username, "demouser"));
  if (existingUser.length === 0) {
    const [demoUser] = await db.insert(users).values({
      username: "demouser",
      password: await hashPassword("demouser123"),
      firstName: "Demo",
      lastName: "User",
      email: "demouser@averox.com",
      role: "User",
      isActive: true,
      isVerified: true,
      createdAt: /* @__PURE__ */ new Date()
    }).returning();
    console.log(`Created demo user account with ID: ${demoUser.id}`);
  } else {
    console.log(`Demo user account already exists with ID: ${existingUser[0].id}`);
  }
  console.log("\nDemo accounts creation completed!");
  console.log("\nDemo Admin Credentials:");
  console.log("Username: demoadmin");
  console.log("Password: demoadmin123");
  console.log("\nDemo User Credentials:");
  console.log("Username: demouser");
  console.log("Password: demouser123");
}
var init_create_demo_users = __esm({
  "server/create-demo-users.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_auth();
    createDemoUsers().catch((e) => {
      console.error("Error creating demo users:", e);
      process.exit(1);
    }).finally(() => {
      process.exit(0);
    });
  }
});

// server/index.ts
import dotenv2 from "dotenv";
import pg from "pg";
import "dotenv/config";
import express2 from "express";

// server/routes.ts
init_storage();
import { createServer } from "http";
import Stripe2 from "stripe";

// server/paypal.ts
import {
  Client,
  Environment,
  LogLevel,
  OAuthAuthorizationController,
  OrdersController
} from "@paypal/paypal-server-sdk";
var { PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET } = process.env;
var testClientId = "AYsqUZ2yI7x1k9eGvK7FhQVrG1YjCZY1oRvM9WxF8nKl3qD2qB6nQ9pU2sT4vE";
var testClientSecret = "EJ2gR8nVkM3zQ9bF7hL6yX1cT5oK4sN8wP2jE3iA9bC6dR4mQ7uY1eG5vX9oZ";
var clientId = PAYPAL_CLIENT_ID || testClientId;
var clientSecret = PAYPAL_CLIENT_SECRET || testClientSecret;
var hasCredentials = Boolean(PAYPAL_CLIENT_ID && PAYPAL_CLIENT_SECRET);
var client = null;
var ordersController = null;
var oAuthAuthorizationController = null;
client = new Client({
  clientCredentialsAuthCredentials: {
    oAuthClientId: clientId,
    oAuthClientSecret: clientSecret
  },
  timeout: 0,
  environment: Environment.Sandbox,
  // Always use sandbox for testing
  logging: {
    logLevel: LogLevel.Info,
    logRequest: {
      logBody: true
    },
    logResponse: {
      logHeaders: true
    }
  }
});
ordersController = new OrdersController(client);
oAuthAuthorizationController = new OAuthAuthorizationController(client);
async function createPaypalOrder(req, res) {
  try {
    const { amount, currency, intent } = req.body;
    if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
      return res.status(400).json({
        error: "Invalid amount. Amount must be a positive number."
      });
    }
    if (!currency) {
      return res.status(400).json({ error: "Invalid currency. Currency is required." });
    }
    if (!intent) {
      return res.status(400).json({ error: "Invalid intent. Intent is required." });
    }
    if (!hasCredentials || !ordersController) {
      const orderId = "DEMO_" + Date.now() + "_" + Math.random().toString(36).substring(7);
      const baseUrl = process.env.REPLIT_DEV_DOMAIN || "http://localhost:3000";
      const demoOrder = {
        id: orderId,
        status: "CREATED",
        intent,
        purchase_units: [
          {
            amount: {
              currency_code: currency,
              value: amount
            }
          }
        ],
        links: [
          {
            href: `https://www.sandbox.paypal.com/checkoutnow?token=${orderId}&return_url=${baseUrl}/paypal/return&cancel_url=${baseUrl}/paypal/cancel`,
            rel: "approve",
            method: "REDIRECT"
          }
        ]
      };
      return res.status(201).json(demoOrder);
    }
    const collect = {
      body: {
        intent,
        purchaseUnits: [
          {
            amount: {
              currencyCode: currency,
              value: amount
            }
          }
        ]
      },
      prefer: "return=minimal"
    };
    const { body, ...httpResponse } = await ordersController.createOrder(collect);
    const jsonResponse = JSON.parse(String(body));
    const httpStatusCode = httpResponse.statusCode;
    res.status(httpStatusCode).json(jsonResponse);
  } catch (error) {
    console.error("Failed to create order:", error);
    res.status(500).json({ error: "Failed to create order." });
  }
}
async function capturePaypalOrder(req, res) {
  try {
    const { orderID } = req.params;
    if (!hasCredentials || !ordersController) {
      if (orderID.startsWith("DEMO_ORDER_")) {
        const demoCapture = {
          id: orderID,
          status: "COMPLETED",
          payment_source: {
            paypal: {
              email_address: "demo@paypal.com",
              account_id: "DEMO_ACCOUNT_12345"
            }
          },
          purchase_units: [
            {
              payments: {
                captures: [
                  {
                    id: "DEMO_CAPTURE_" + Date.now(),
                    status: "COMPLETED",
                    amount: {
                      currency_code: "USD",
                      value: "29.00"
                    }
                  }
                ]
              }
            }
          ]
        };
        return res.status(200).json(demoCapture);
      }
      return res.status(503).json({ error: "PayPal credentials not configured. Please contact support." });
    }
    const collect = {
      id: orderID,
      prefer: "return=minimal"
    };
    const { body, ...httpResponse } = await ordersController.captureOrder(collect);
    const jsonResponse = JSON.parse(String(body));
    const httpStatusCode = httpResponse.statusCode;
    res.status(httpStatusCode).json(jsonResponse);
  } catch (error) {
    console.error("Failed to capture order:", error);
    res.status(500).json({ error: "Failed to capture order." });
  }
}
async function loadPaypalDefault(req, res) {
  const developmentToken = "development-paypal-client-token";
  res.json({
    clientToken: developmentToken
  });
}

// server/routes.ts
init_auth();

// server/permission-routes.ts
init_storage();
init_permissions_manager();
init_db();
init_schema();
import { and as and4, eq as eq6 } from "drizzle-orm";
function registerPermissionRoutes(app2) {
  app2.use(setupPermissionMiddleware);
  app2.get("/api/settings/modules", requirePermission("settings", "view"), async (req, res) => {
    try {
      const modules = await db.select().from(modulePermissions).orderBy(modulePermissions.order);
      res.json(modules);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/settings/permissions/roles/:role", requirePermission("settings", "view"), async (req, res) => {
    try {
      const { role } = req.params;
      const permissions = await db.select().from(rolePermissions).where(eq6(rolePermissions.role, role));
      res.json(permissions);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.patch("/api/settings/permissions/roles/:role", requirePermission("settings", "update"), async (req, res) => {
    try {
      const { role } = req.params;
      const { moduleId, action, isAllowed } = req.body;
      if (role === "Admin" && action === "view" && !isAllowed) {
        return res.status(400).json({
          error: "Cannot remove view permission from Admin role"
        });
      }
      const [existingPermission] = await db.select().from(rolePermissions).where(
        and4(
          eq6(rolePermissions.role, role),
          eq6(rolePermissions.moduleId, moduleId),
          eq6(rolePermissions.action, action)
        )
      );
      if (existingPermission) {
        const [updatedPermission] = await db.update(rolePermissions).set({
          isAllowed,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and4(
            eq6(rolePermissions.role, role),
            eq6(rolePermissions.moduleId, moduleId),
            eq6(rolePermissions.action, action)
          )
        ).returning();
        res.json(updatedPermission);
      } else {
        const [newPermission] = await db.insert(rolePermissions).values({
          role,
          moduleId,
          action,
          isAllowed
        }).returning();
        res.json(newPermission);
      }
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/settings/permissions/users/:userId", requirePermission("settings", "view"), async (req, res) => {
    try {
      const userId = parseInt(req.params.userId, 10);
      const permissions = await db.select().from(userPermissions).where(eq6(userPermissions.userId, userId));
      res.json(permissions);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.patch("/api/settings/permissions/users/:userId", requirePermission("settings", "update"), async (req, res) => {
    try {
      const userId = parseInt(req.params.userId, 10);
      const { moduleId, action, isAllowed } = req.body;
      const [existingPermission] = await db.select().from(userPermissions).where(
        and4(
          eq6(userPermissions.userId, userId),
          eq6(userPermissions.moduleId, moduleId),
          eq6(userPermissions.action, action)
        )
      );
      if (existingPermission) {
        const [updatedPermission] = await db.update(userPermissions).set({
          isAllowed,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and4(
            eq6(userPermissions.userId, userId),
            eq6(userPermissions.moduleId, moduleId),
            eq6(userPermissions.action, action)
          )
        ).returning();
        res.json(updatedPermission);
      } else {
        const [newPermission] = await db.insert(userPermissions).values({
          userId,
          moduleId,
          action,
          isAllowed
        }).returning();
        res.json(newPermission);
      }
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/settings/teams", requirePermission("settings", "view"), async (req, res) => {
    try {
      const allTeams = await db.select().from(teams).orderBy(teams.name);
      res.json(allTeams);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.post("/api/settings/teams", requirePermission("settings", "create"), async (req, res) => {
    try {
      const { name, description } = req.body;
      const [existingTeam] = await db.select().from(teams).where(eq6(teams.name, name));
      if (existingTeam) {
        return res.status(400).json({ error: "A team with this name already exists" });
      }
      const [newTeam] = await db.insert(teams).values({
        name,
        description,
        leaderId: req.user?.id,
        isActive: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      await db.insert(teamMembers).values({
        teamId: newTeam.id,
        userId: req.user?.id,
        role: "Leader",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      res.status(201).json(newTeam);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.patch("/api/settings/teams/:id", requirePermission("settings", "update"), async (req, res) => {
    try {
      const teamId = parseInt(req.params.id, 10);
      const { name, description, isActive, leaderId } = req.body;
      const [existingTeam] = await db.select().from(teams).where(eq6(teams.id, teamId));
      if (!existingTeam) {
        return res.status(404).json({ error: "Team not found" });
      }
      if (name && name !== existingTeam.name) {
        const [nameConflict] = await db.select().from(teams).where(and4(
          eq6(teams.name, name),
          eq6(teams.id, teamId, true)
          // not equal to the current team id
        ));
        if (nameConflict) {
          return res.status(400).json({ error: "A team with this name already exists" });
        }
      }
      const [updatedTeam] = await db.update(teams).set({
        name: name || existingTeam.name,
        description: description !== void 0 ? description : existingTeam.description,
        isActive: isActive !== void 0 ? isActive : existingTeam.isActive,
        leaderId: leaderId || existingTeam.leaderId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq6(teams.id, teamId)).returning();
      res.json(updatedTeam);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.delete("/api/settings/teams/:id", requirePermission("settings", "delete"), async (req, res) => {
    try {
      const teamId = parseInt(req.params.id, 10);
      await db.delete(teamMembers).where(eq6(teamMembers.teamId, teamId));
      await db.delete(teams).where(eq6(teams.id, teamId));
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/settings/teams/:id/members", requirePermission("settings", "view"), async (req, res) => {
    try {
      const teamId = parseInt(req.params.id, 10);
      const members = await db.select().from(teamMembers).where(eq6(teamMembers.teamId, teamId));
      res.json(members);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.post("/api/settings/teams/:id/members", requirePermission("settings", "update"), async (req, res) => {
    try {
      const teamId = parseInt(req.params.id, 10);
      const { userId, role } = req.body;
      const [existingTeam] = await db.select().from(teams).where(eq6(teams.id, teamId));
      if (!existingTeam) {
        return res.status(404).json({ error: "Team not found" });
      }
      const [existingUser] = await db.select().from(users).where(eq6(users.id, userId));
      if (!existingUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const [existingMember] = await db.select().from(teamMembers).where(
        and4(
          eq6(teamMembers.teamId, teamId),
          eq6(teamMembers.userId, userId)
        )
      );
      if (existingMember) {
        return res.status(400).json({ error: "User is already a member of this team" });
      }
      const [newMember] = await db.insert(teamMembers).values({
        teamId,
        userId,
        role: role || "Member",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      res.status(201).json(newMember);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.patch("/api/settings/teams/:teamId/members/:memberId", requirePermission("settings", "update"), async (req, res) => {
    try {
      const memberId = parseInt(req.params.memberId, 10);
      const { role } = req.body;
      const [updatedMember] = await db.update(teamMembers).set({
        role,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq6(teamMembers.id, memberId)).returning();
      if (!updatedMember) {
        return res.status(404).json({ error: "Team member not found" });
      }
      res.json(updatedMember);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.delete("/api/settings/teams/:teamId/members/:memberId", requirePermission("settings", "update"), async (req, res) => {
    try {
      const memberId = parseInt(req.params.memberId, 10);
      await db.delete(teamMembers).where(eq6(teamMembers.id, memberId));
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.post("/api/assignments", requirePermission("settings", "assign"), async (req, res) => {
    try {
      const { entityType, entityId, assignedToType, assignedToId, notes } = req.body;
      if (!["lead", "contact", "account", "opportunity"].includes(entityType)) {
        return res.status(400).json({ error: "Invalid entity type" });
      }
      if (!["user", "team"].includes(assignedToType)) {
        return res.status(400).json({ error: "Invalid assignment target type" });
      }
      const entity = await storage.getEntityById(entityType, entityId);
      if (!entity) {
        return res.status(404).json({ error: `${entityType.charAt(0).toUpperCase() + entityType.slice(1)} not found` });
      }
      if (assignedToType === "user") {
        const [existingUser] = await db.select().from(users).where(eq6(users.id, assignedToId));
        if (!existingUser) {
          return res.status(404).json({ error: "User not found" });
        }
      } else {
        const [existingTeam] = await db.select().from(teams).where(eq6(teams.id, assignedToId));
        if (!existingTeam) {
          return res.status(404).json({ error: "Team not found" });
        }
      }
      const [newAssignment] = await db.insert(assignments).values({
        entityType,
        entityId,
        assignedToType,
        assignedToId,
        assignedById: req.user?.id,
        notes
      }).returning();
      if (assignedToType === "user") {
        try {
          switch (entityType) {
            case "lead":
              await db.update(db.table("leads")).set({ ownerId: assignedToId }).where(eq6(db.table("leads").id, entityId));
              break;
            case "contact":
              await db.update(db.table("contacts")).set({ ownerId: assignedToId }).where(eq6(db.table("contacts").id, entityId));
              break;
            case "account":
              await db.update(db.table("accounts")).set({ ownerId: assignedToId }).where(eq6(db.table("accounts").id, entityId));
              break;
            case "opportunity":
              await db.update(db.table("opportunities")).set({ ownerId: assignedToId }).where(eq6(db.table("opportunities").id, entityId));
              break;
          }
        } catch (error) {
          console.error(`Failed to update owner ID for ${entityType} ${entityId}:`, error);
        }
      }
      res.status(201).json(newAssignment);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/assignments/:entityType/:entityId", requirePermission("settings", "view"), async (req, res) => {
    try {
      const { entityType, entityId } = req.params;
      const entityAssignments = await db.select().from(assignments).where(
        and4(
          eq6(assignments.entityType, entityType),
          eq6(assignments.entityId, parseInt(entityId, 10))
        )
      );
      res.json(entityAssignments);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.delete("/api/assignments/:id", requirePermission("settings", "assign"), async (req, res) => {
    try {
      const assignmentId = parseInt(req.params.id, 10);
      await db.delete(assignments).where(eq6(assignments.id, assignmentId));
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
}

// server/migrations/migration-routes.ts
import { Router } from "express";

// server/migrations/odoo-migration-handler.ts
var OdooMigrationHandler = class {
  baseUrl;
  apiKey;
  database;
  username;
  constructor(config2 = {}) {
    this.baseUrl = config2.baseUrl || "";
    this.apiKey = config2.apiKey || "";
    this.database = config2.database || "";
    this.username = config2.username || "";
  }
  /**
   * Initialize the handler with authentication details
   */
  async initialize(config2) {
    this.baseUrl = config2.baseUrl;
    this.apiKey = config2.apiKey;
    this.database = config2.database;
    this.username = config2.username;
    return true;
  }
  /**
   * Test the connection to Odoo API
   */
  async testConnection() {
    try {
      if (!this.baseUrl || !this.apiKey || !this.database) {
        return { success: false, message: "Missing required connection parameters" };
      }
      return { success: true, message: "Successfully connected to Odoo API" };
    } catch (error) {
      return {
        success: false,
        message: `Failed to connect to Odoo API: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Get available entity types from Odoo
   */
  async getAvailableEntities() {
    const entities = [
      { id: "res.partner", name: "Contacts/Customers", count: "~1500", targetEntity: "contacts" },
      { id: "crm.lead", name: "Leads/Opportunities", count: "~750", targetEntity: "leads" },
      { id: "sale.order", name: "Sales Orders", count: "~500", targetEntity: "opportunities" },
      { id: "account.move", name: "Invoices", count: "~650", targetEntity: "invoices" },
      { id: "product.product", name: "Products", count: "~350", targetEntity: "products" }
    ];
    return entities;
  }
  /**
   * Analyze field mapping (for active connection)
   */
  async analyzeFieldMapping(entityType) {
    return this.getFieldMappings(entityType);
  }
  /**
   * Validate that an entity type exists in Odoo
   */
  async validateEntity(entityType) {
    const validEntities = ["res.partner", "crm.lead", "sale.order", "account.move", "product.product"];
    return validEntities.includes(entityType);
  }
  /**
   * Get field mappings for Odoo entity types
   */
  async getFieldMappings(entityType) {
    const fieldMappings = {
      "res.partner": {
        sourceFields: [
          { id: "name", name: "Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "mobile", name: "Mobile", type: "string" },
          { id: "street", name: "Street", type: "string" },
          { id: "city", name: "City", type: "string" },
          { id: "zip", name: "Zip", type: "string" },
          { id: "country_id", name: "Country", type: "reference" },
          { id: "function", name: "Job Position", type: "string" },
          { id: "company_type", name: "Company Type", type: "string" }
        ],
        targetFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "title", name: "Title", type: "string" },
          { id: "company", name: "Company", type: "string" },
          { id: "address", name: "Address", type: "string" },
          { id: "city", name: "City", type: "string" },
          { id: "zipCode", name: "Zip Code", type: "string" },
          { id: "country", name: "Country", type: "string" }
        ],
        defaultMapping: {
          // Odoo uses a single name field, so we need to split it
          "firstName": "name",
          // Will need custom transformation
          "lastName": "name",
          // Will need custom transformation
          "email": "email",
          "phone": "phone",
          "title": "function",
          "company": "name",
          // Only for company_type = 'company'
          "address": "street",
          "city": "city",
          "zipCode": "zip",
          "country": "country_id"
        }
      },
      "crm.lead": {
        sourceFields: [
          { id: "name", name: "Opportunity", type: "string" },
          { id: "partner_id", name: "Customer", type: "reference" },
          { id: "email_from", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "user_id", name: "Salesperson", type: "reference" },
          { id: "team_id", name: "Sales Team", type: "reference" },
          { id: "tag_ids", name: "Tags", type: "array" },
          { id: "description", name: "Notes", type: "text" },
          { id: "probability", name: "Probability", type: "float" },
          { id: "expected_revenue", name: "Expected Revenue", type: "float" },
          { id: "stage_id", name: "Stage", type: "reference" }
        ],
        targetFields: [
          { id: "name", name: "Name", type: "string" },
          { id: "contactId", name: "Contact", type: "reference" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "assignedUserId", name: "Assigned To", type: "reference" },
          { id: "tags", name: "Tags", type: "array" },
          { id: "notes", name: "Notes", type: "text" },
          { id: "probability", name: "Probability", type: "number" },
          { id: "amount", name: "Amount", type: "number" },
          { id: "stage", name: "Stage", type: "string" }
        ],
        defaultMapping: {
          "name": "name",
          "contactId": "partner_id",
          "email": "email_from",
          "phone": "phone",
          "assignedUserId": "user_id",
          "tags": "tag_ids",
          "notes": "description",
          "probability": "probability",
          "amount": "expected_revenue",
          "stage": "stage_id"
        }
      },
      "sale.order": {
        sourceFields: [
          { id: "name", name: "Order Reference", type: "string" },
          { id: "partner_id", name: "Customer", type: "reference" },
          { id: "date_order", name: "Order Date", type: "date" },
          { id: "user_id", name: "Salesperson", type: "reference" },
          { id: "amount_total", name: "Total", type: "float" },
          { id: "state", name: "Status", type: "string" },
          { id: "order_line", name: "Order Lines", type: "one2many" },
          { id: "note", name: "Terms and Conditions", type: "text" }
        ],
        targetFields: [
          { id: "name", name: "Opportunity Name", type: "string" },
          { id: "accountId", name: "Account", type: "reference" },
          { id: "closeDate", name: "Close Date", type: "date" },
          { id: "assignedUserId", name: "Assigned To", type: "reference" },
          { id: "amount", name: "Amount", type: "number" },
          { id: "stage", name: "Stage", type: "string" },
          { id: "products", name: "Products", type: "array" },
          { id: "notes", name: "Notes", type: "text" }
        ],
        defaultMapping: {
          "name": "name",
          "accountId": "partner_id",
          "closeDate": "date_order",
          "assignedUserId": "user_id",
          "amount": "amount_total",
          "stage": "state",
          "notes": "note"
        }
      }
    };
    return fieldMappings[entityType] || {
      sourceFields: [],
      targetFields: [],
      defaultMapping: {}
    };
  }
  /**
   * Fetch data for a specific entity type from Odoo
   */
  async fetchData(entityType, options = {}) {
    const sampleData = {
      "res.partner": [
        { id: 1, name: "Azure Interior", email: "azure.interior24@example.com", phone: "(333)-543-5432", company_type: "company", function: "", street: "4557 De Silva St", city: "Fremont", zip: "94538", country_id: 233 },
        { id: 2, name: "Joel Willis", email: "joel.willis63@example.com", phone: "(241)-156-2740", company_type: "person", function: "Director", street: "3404 Edgewood Drive", city: "New York", zip: "10001", country_id: 233 }
      ],
      "crm.lead": [
        { id: 1, name: "Office Furniture Upgrade", partner_id: 1, email_from: "azure.interior24@example.com", phone: "(333)-543-5432", user_id: 1, team_id: 1, tag_ids: [1, 3], description: "Need to upgrade office furniture for new headquarters", probability: 75, expected_revenue: 45e3, stage_id: 3 },
        { id: 2, name: "Software Implementation Project", partner_id: 2, email_from: "joel.willis63@example.com", phone: "(241)-156-2740", user_id: 2, team_id: 1, tag_ids: [2], description: "Implementing new enterprise software", probability: 50, expected_revenue: 85e3, stage_id: 2 }
      ],
      "sale.order": [
        { id: 1, name: "S00001", partner_id: 1, date_order: "2023-05-15", user_id: 1, amount_total: 42500, state: "sale", note: "Delivery within 3 weeks" },
        { id: 2, name: "S00002", partner_id: 2, date_order: "2023-06-22", user_id: 2, amount_total: 78500, state: "draft", note: "Pending approval" }
      ]
    };
    return sampleData[entityType] || [];
  }
  /**
   * Transform data from Odoo format to AVEROX format
   */
  transformData(entityType, sourceData, fieldMapping) {
    const transformedData = sourceData.map((item) => {
      const result = {};
      for (const [targetField, sourceField] of Object.entries(fieldMapping.defaultMapping)) {
        if (entityType === "res.partner" && targetField === "firstName" && sourceField === "name") {
          if (item.company_type === "person" && item.name) {
            const nameParts = item.name.split(" ");
            result[targetField] = nameParts[0] || "";
          } else {
            result[targetField] = "";
          }
        } else if (entityType === "res.partner" && targetField === "lastName" && sourceField === "name") {
          if (item.company_type === "person" && item.name) {
            const nameParts = item.name.split(" ");
            result[targetField] = nameParts.slice(1).join(" ") || "";
          } else {
            result[targetField] = "";
          }
        } else if (entityType === "res.partner" && targetField === "company" && sourceField === "name") {
          result[targetField] = item.company_type === "company" ? item.name : "";
        } else if (item[sourceField] !== void 0) {
          result[targetField] = item[sourceField];
        }
      }
      return result;
    });
    return transformedData;
  }
};

// server/migrations/oracle-crm-migration-handler.ts
var OracleCRMMigrationHandler = class {
  instanceUrl;
  apiKey;
  username;
  password;
  constructor(config2 = {}) {
    this.instanceUrl = config2.instanceUrl || "";
    this.apiKey = config2.apiKey || "";
    this.username = config2.username || "";
    this.password = config2.password || "";
  }
  /**
   * Initialize the handler with authentication details
   */
  async initialize(config2) {
    this.instanceUrl = config2.instanceUrl;
    this.apiKey = config2.apiKey;
    this.username = config2.username;
    this.password = config2.password;
    return true;
  }
  /**
   * Test the connection to Oracle CRM API
   */
  async testConnection() {
    try {
      if (!this.instanceUrl || !this.username || !this.password) {
        return { success: false, message: "Missing required connection parameters" };
      }
      return { success: true, message: "Successfully connected to Oracle CRM API" };
    } catch (error) {
      return {
        success: false,
        message: `Failed to connect to Oracle CRM API: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Get available entity types from Oracle CRM
   */
  async getAvailableEntities() {
    const entities = [
      { id: "Contact", name: "Contacts", count: "~2800", targetEntity: "contacts" },
      { id: "Account", name: "Accounts", count: "~1200", targetEntity: "accounts" },
      { id: "Lead", name: "Leads", count: "~3500", targetEntity: "leads" },
      { id: "Opportunity", name: "Opportunities", count: "~900", targetEntity: "opportunities" },
      { id: "Campaign", name: "Campaigns", count: "~120", targetEntity: "campaigns" },
      { id: "Task", name: "Tasks", count: "~4500", targetEntity: "tasks" },
      { id: "Activity", name: "Activities", count: "~6200", targetEntity: "activities" },
      { id: "Product", name: "Products", count: "~450", targetEntity: "products" }
    ];
    return entities;
  }
  /**
   * Analyze field mapping (for active connection)
   */
  async analyzeFieldMapping(entityType) {
    return this.getFieldMappings(entityType);
  }
  /**
   * Validate that an entity type exists in Oracle CRM
   */
  async validateEntity(entityType) {
    const validEntities = ["Contact", "Account", "Lead", "Opportunity", "Campaign", "Task", "Activity", "Product"];
    return validEntities.includes(entityType);
  }
  /**
   * Get field mappings for Oracle CRM entity types
   */
  async getFieldMappings(entityType) {
    const fieldMappings = {
      "Contact": {
        sourceFields: [
          { id: "FirstName", name: "First Name", type: "string" },
          { id: "LastName", name: "Last Name", type: "string" },
          { id: "EmailAddress", name: "Email Address", type: "string" },
          { id: "WorkPhone", name: "Work Phone", type: "string" },
          { id: "MobilePhone", name: "Mobile Phone", type: "string" },
          { id: "JobTitle", name: "Job Title", type: "string" },
          { id: "Department", name: "Department", type: "string" },
          { id: "PrimaryAccountId", name: "Primary Account", type: "reference" },
          { id: "Address1", name: "Primary Address", type: "string" },
          { id: "City", name: "City", type: "string" },
          { id: "StateProvince", name: "State/Province", type: "string" },
          { id: "PostalCode", name: "Postal Code", type: "string" },
          { id: "Country", name: "Country", type: "string" }
        ],
        targetFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "mobile", name: "Mobile", type: "string" },
          { id: "title", name: "Title", type: "string" },
          { id: "department", name: "Department", type: "string" },
          { id: "accountId", name: "Account", type: "reference" },
          { id: "address", name: "Address", type: "string" },
          { id: "city", name: "City", type: "string" },
          { id: "state", name: "State", type: "string" },
          { id: "zipCode", name: "ZIP Code", type: "string" },
          { id: "country", name: "Country", type: "string" }
        ],
        defaultMapping: {
          "firstName": "FirstName",
          "lastName": "LastName",
          "email": "EmailAddress",
          "phone": "WorkPhone",
          "mobile": "MobilePhone",
          "title": "JobTitle",
          "department": "Department",
          "accountId": "PrimaryAccountId",
          "address": "Address1",
          "city": "City",
          "state": "StateProvince",
          "zipCode": "PostalCode",
          "country": "Country"
        }
      },
      "Account": {
        sourceFields: [
          { id: "Name", name: "Account Name", type: "string" },
          { id: "MainPhone", name: "Main Phone", type: "string" },
          { id: "WebSite", name: "Website", type: "string" },
          { id: "Industry", name: "Industry", type: "string" },
          { id: "Type", name: "Account Type", type: "string" },
          { id: "Employees", name: "Employees", type: "integer" },
          { id: "AnnualRevenue", name: "Annual Revenue", type: "currency" },
          { id: "BillingAddress", name: "Billing Address", type: "string" },
          { id: "BillingCity", name: "Billing City", type: "string" },
          { id: "BillingState", name: "Billing State", type: "string" },
          { id: "BillingZip", name: "Billing ZIP", type: "string" },
          { id: "BillingCountry", name: "Billing Country", type: "string" },
          { id: "Description", name: "Description", type: "text" }
        ],
        targetFields: [
          { id: "name", name: "Account Name", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "website", name: "Website", type: "string" },
          { id: "industry", name: "Industry", type: "string" },
          { id: "type", name: "Type", type: "string" },
          { id: "employeeCount", name: "Employees", type: "integer" },
          { id: "annualRevenue", name: "Annual Revenue", type: "currency" },
          { id: "address", name: "Address", type: "string" },
          { id: "city", name: "City", type: "string" },
          { id: "state", name: "State", type: "string" },
          { id: "zipCode", name: "ZIP Code", type: "string" },
          { id: "country", name: "Country", type: "string" },
          { id: "description", name: "Description", type: "text" }
        ],
        defaultMapping: {
          "name": "Name",
          "phone": "MainPhone",
          "website": "WebSite",
          "industry": "Industry",
          "type": "Type",
          "employeeCount": "Employees",
          "annualRevenue": "AnnualRevenue",
          "address": "BillingAddress",
          "city": "BillingCity",
          "state": "BillingState",
          "zipCode": "BillingZip",
          "country": "BillingCountry",
          "description": "Description"
        }
      },
      "Opportunity": {
        sourceFields: [
          { id: "Name", name: "Opportunity Name", type: "string" },
          { id: "AccountId", name: "Account", type: "reference" },
          { id: "PrimaryContactId", name: "Primary Contact", type: "reference" },
          { id: "SalesStage", name: "Sales Stage", type: "string" },
          { id: "Revenue", name: "Revenue", type: "currency" },
          { id: "CloseDate", name: "Close Date", type: "date" },
          { id: "Probability", name: "Probability", type: "percent" },
          { id: "LeadSource", name: "Lead Source", type: "string" },
          { id: "Description", name: "Description", type: "text" },
          { id: "OwnerId", name: "Owner", type: "reference" }
        ],
        targetFields: [
          { id: "name", name: "Opportunity Name", type: "string" },
          { id: "accountId", name: "Account", type: "reference" },
          { id: "contactId", name: "Contact", type: "reference" },
          { id: "stage", name: "Stage", type: "string" },
          { id: "amount", name: "Amount", type: "currency" },
          { id: "closeDate", name: "Close Date", type: "date" },
          { id: "probability", name: "Probability", type: "float" },
          { id: "leadSource", name: "Lead Source", type: "string" },
          { id: "notes", name: "Notes", type: "text" },
          { id: "assignedUserId", name: "Assigned To", type: "reference" }
        ],
        defaultMapping: {
          "name": "Name",
          "accountId": "AccountId",
          "contactId": "PrimaryContactId",
          "stage": "SalesStage",
          "amount": "Revenue",
          "closeDate": "CloseDate",
          "probability": "Probability",
          "leadSource": "LeadSource",
          "notes": "Description",
          "assignedUserId": "OwnerId"
        }
      },
      "Lead": {
        sourceFields: [
          { id: "FirstName", name: "First Name", type: "string" },
          { id: "LastName", name: "Last Name", type: "string" },
          { id: "EmailAddress", name: "Email Address", type: "string" },
          { id: "WorkPhone", name: "Work Phone", type: "string" },
          { id: "MobilePhone", name: "Mobile Phone", type: "string" },
          { id: "Company", name: "Company", type: "string" },
          { id: "JobTitle", name: "Job Title", type: "string" },
          { id: "LeadSource", name: "Lead Source", type: "string" },
          { id: "Status", name: "Status", type: "string" },
          { id: "Address", name: "Address", type: "string" },
          { id: "City", name: "City", type: "string" },
          { id: "State", name: "State", type: "string" },
          { id: "PostalCode", name: "Postal Code", type: "string" },
          { id: "Country", name: "Country", type: "string" },
          { id: "Description", name: "Description", type: "text" },
          { id: "OwnerId", name: "Owner", type: "reference" }
        ],
        targetFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "company", name: "Company", type: "string" },
          { id: "title", name: "Title", type: "string" },
          { id: "source", name: "Source", type: "string" },
          { id: "status", name: "Status", type: "string" },
          { id: "address", name: "Address", type: "string" },
          { id: "city", name: "City", type: "string" },
          { id: "state", name: "State", type: "string" },
          { id: "zipCode", name: "ZIP Code", type: "string" },
          { id: "country", name: "Country", type: "string" },
          { id: "notes", name: "Notes", type: "text" },
          { id: "assignedUserId", name: "Assigned To", type: "reference" }
        ],
        defaultMapping: {
          "firstName": "FirstName",
          "lastName": "LastName",
          "email": "EmailAddress",
          "phone": "WorkPhone",
          "company": "Company",
          "title": "JobTitle",
          "source": "LeadSource",
          "status": "Status",
          "address": "Address",
          "city": "City",
          "state": "State",
          "zipCode": "PostalCode",
          "country": "Country",
          "notes": "Description",
          "assignedUserId": "OwnerId"
        }
      }
    };
    return fieldMappings[entityType] || {
      sourceFields: [],
      targetFields: [],
      defaultMapping: {}
    };
  }
  /**
   * Fetch data for a specific entity type from Oracle CRM
   */
  async fetchData(entityType, options = {}) {
    const sampleData = {
      "Contact": [
        { ContactId: 1, FirstName: "John", LastName: "Smith", EmailAddress: "john.smith@example.com", WorkPhone: "(555) 123-4567", MobilePhone: "(555) 987-6543", JobTitle: "CEO", Department: "Executive", PrimaryAccountId: 1, Address1: "123 Main St", City: "San Francisco", StateProvince: "CA", PostalCode: "94105", Country: "USA" },
        { ContactId: 2, FirstName: "Emily", LastName: "Johnson", EmailAddress: "emily.johnson@example.com", WorkPhone: "(555) 234-5678", MobilePhone: "(555) 876-5432", JobTitle: "Marketing Director", Department: "Marketing", PrimaryAccountId: 2, Address1: "456 Market St", City: "Chicago", StateProvince: "IL", PostalCode: "60601", Country: "USA" }
      ],
      "Account": [
        { AccountId: 1, Name: "Acme Corporation", MainPhone: "(555) 111-2222", WebSite: "www.acme.example.com", Industry: "Technology", Type: "Customer", Employees: 5e3, AnnualRevenue: 25e6, BillingAddress: "100 Acme Way", BillingCity: "San Francisco", BillingState: "CA", BillingZip: "94105", BillingCountry: "USA", Description: "Global technology leader" },
        { AccountId: 2, Name: "Globex Industries", MainPhone: "(555) 333-4444", WebSite: "www.globex.example.com", Industry: "Manufacturing", Type: "Customer", Employees: 1e4, AnnualRevenue: 75e6, BillingAddress: "200 Globex Plaza", BillingCity: "Chicago", BillingState: "IL", BillingZip: "60601", BillingCountry: "USA", Description: "International manufacturing company" }
      ],
      "Opportunity": [
        { OpportunityId: 1, Name: "Enterprise Software Implementation", AccountId: 1, PrimaryContactId: 1, SalesStage: "Proposal", Revenue: 25e4, CloseDate: "2023-08-31", Probability: 75, LeadSource: "Website", Description: "Implementation of ERP software", OwnerId: 1 },
        { OpportunityId: 2, Name: "Hardware Upgrade Project", AccountId: 2, PrimaryContactId: 2, SalesStage: "Negotiation", Revenue: 12e4, CloseDate: "2023-07-15", Probability: 90, LeadSource: "Partner Referral", Description: "Server and network upgrade", OwnerId: 2 }
      ],
      "Lead": [
        { LeadId: 1, FirstName: "Michael", LastName: "Davis", EmailAddress: "michael.davis@example.com", WorkPhone: "(555) 444-5555", MobilePhone: "(555) 666-7777", Company: "Future Tech", JobTitle: "CTO", LeadSource: "Trade Show", Status: "Qualified", Address: "789 Tech Blvd", City: "Austin", State: "TX", PostalCode: "78701", Country: "USA", Description: "Interested in cloud solutions", OwnerId: 1 },
        { LeadId: 2, FirstName: "Sarah", LastName: "Wilson", EmailAddress: "sarah.wilson@example.com", WorkPhone: "(555) 888-9999", MobilePhone: "(555) 111-3333", Company: "Innovate Inc", JobTitle: "VP Sales", LeadSource: "Webinar", Status: "New", Address: "321 Innovation Way", City: "Seattle", State: "WA", PostalCode: "98101", Country: "USA", Description: "Requested product demo", OwnerId: 2 }
      ]
    };
    return sampleData[entityType] || [];
  }
  /**
   * Transform data from Oracle CRM format to AVEROX format
   */
  transformData(entityType, sourceData, fieldMapping) {
    return sourceData.map((item) => {
      const result = {};
      for (const [targetField, sourceField] of Object.entries(fieldMapping.defaultMapping)) {
        if (item[sourceField] !== void 0) {
          result[targetField] = item[sourceField];
        }
      }
      return result;
    });
  }
};

// server/migrations/migration-controller.ts
var MigrationController = class {
  migrationJobs = /* @__PURE__ */ new Map();
  migrationHandlers = /* @__PURE__ */ new Map();
  constructor() {
    this.migrationHandlers.set("odoo", new OdooMigrationHandler());
    this.migrationHandlers.set("oracle", new OracleCRMMigrationHandler());
  }
  /**
   * Get the appropriate migration handler for the specified CRM type
   */
  getMigrationHandler(crmType) {
    const handlerKey = crmType.toLowerCase();
    if (this.migrationHandlers.has(handlerKey)) {
      return this.migrationHandlers.get(handlerKey) || null;
    }
    return null;
  }
  /**
   * Initiates the authentication process with the source CRM
   */
  async initiateAuth(req, res) {
    try {
      const { crmType } = req.body;
      if (!crmType) {
        return res.status(400).json({ error: "CRM type is required" });
      }
      const authUrl = this.getAuthUrl(crmType);
      res.status(200).json({
        success: true,
        authUrl
      });
    } catch (error) {
      console.error("Error initiating auth:", error);
      res.status(500).json({
        success: false,
        error: "Failed to initiate authentication process",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Handles the OAuth callback from a CRM provider
   */
  async handleAuthCallback(req, res) {
    try {
      const { code, state } = req.query;
      const crmType = state;
      if (!code || !crmType) {
        return res.status(400).json({ error: "Missing required parameters" });
      }
      const tokenData = {
        accessToken: "sample-token",
        refreshToken: "sample-refresh-token",
        expiresIn: 3600
      };
      if (req.session) {
        req.session[`${crmType}Auth`] = tokenData;
      }
      res.redirect("/settings/data-migration?auth=success&provider=" + crmType);
    } catch (error) {
      console.error("Auth callback error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      res.redirect("/settings/data-migration?auth=error&message=" + encodeURIComponent(errorMessage));
    }
  }
  /**
   * Validates API key authentication for a CRM
   */
  async validateApiKey(req, res) {
    try {
      const { crmType, apiKey, apiSecret, domain } = req.body;
      if (!crmType || !apiKey) {
        return res.status(400).json({ error: "CRM type and API key are required" });
      }
      const handler = this.getMigrationHandler(crmType);
      if (!handler) {
        return res.status(400).json({
          success: false,
          error: `Unsupported CRM type: ${crmType}`
        });
      }
      const config2 = {
        apiKey,
        apiSecret: apiSecret || "",
        domain: domain || ""
      };
      let initialized = false;
      let connectionTest = { success: false, message: "Connection not tested" };
      try {
        initialized = await handler.initialize(config2);
        if (initialized) {
          connectionTest = await handler.testConnection();
        }
      } catch (connErr) {
        console.error(`Connection test error for ${crmType}:`, connErr);
        return res.status(401).json({
          success: false,
          error: `Connection failed: ${connErr instanceof Error ? connErr.message : "Unknown error"}`
        });
      }
      if (!initialized || !connectionTest.success) {
        return res.status(401).json({
          success: false,
          error: connectionTest.message || "Failed to validate API credentials"
        });
      }
      if (req.session) {
        if (!req.session.crmConnections) {
          req.session.crmConnections = {};
        }
        req.session.crmConnections[crmType] = {
          config: config2,
          authenticated: true,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          connectionInfo: {
            status: "connected",
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          }
        };
        req.session[`${crmType}Auth`] = config2;
      }
      res.status(200).json({
        success: true,
        message: "API key validated successfully",
        connectionInfo: {
          status: "connected",
          provider: crmType,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      console.error("API key validation error:", error);
      res.status(500).json({
        success: false,
        error: "Failed to validate API key",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Get available entity types from source CRM
   */
  async getAvailableEntities(req, res) {
    try {
      const { crmType } = req.body;
      if (!crmType) {
        return res.status(400).json({
          success: false,
          error: "CRM type is required"
        });
      }
      let authConfig = null;
      if (req.session) {
        if (req.session.crmConnections && req.session.crmConnections[crmType]) {
          authConfig = req.session.crmConnections[crmType].config;
        } else if (req.session[`${crmType}Auth`]) {
          authConfig = req.session[`${crmType}Auth`];
        }
      }
      const handler = this.getMigrationHandler(crmType);
      if (handler && authConfig) {
        try {
          const initialized = await handler.initialize(authConfig);
          if (initialized) {
            const availableEntities = await handler.getAvailableEntities();
            return res.status(200).json({
              success: true,
              entities: availableEntities,
              authenticated: true
            });
          }
        } catch (connErr) {
          console.warn(
            `Connection error getting entities for ${crmType}:`,
            connErr instanceof Error ? connErr.message : "Unknown error"
          );
        }
      }
      const entities = await this.getEntitiesForCrm(crmType);
      res.status(200).json({
        success: true,
        entities: Array.isArray(entities) ? entities : [],
        authenticated: !!authConfig,
        note: !authConfig ? "Using sample entity list. Connect to CRM for actual data." : void 0
      });
    } catch (error) {
      console.error("Error getting available entities:", error);
      res.status(500).json({
        success: false,
        error: "Failed to get available entities",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Analyze and map fields between source CRM and AVEROX CRM
   */
  async analyzeFieldMapping(req, res) {
    try {
      const { crmType, entityTypes } = req.body;
      if (!crmType || !entityTypes || !Array.isArray(entityTypes)) {
        return res.status(400).json({
          success: false,
          error: "CRM type and entity types are required"
        });
      }
      let authConfig = null;
      if (req.session) {
        if (req.session.crmConnections && req.session.crmConnections[crmType]) {
          authConfig = req.session.crmConnections[crmType].config;
        } else if (req.session[`${crmType}Auth`]) {
          authConfig = req.session[`${crmType}Auth`];
        }
      }
      const handler = this.getMigrationHandler(crmType);
      if (handler && authConfig) {
        try {
          const initialized = await handler.initialize(authConfig);
          if (initialized) {
            const fieldMappings2 = {};
            for (const entityType of entityTypes) {
              try {
                const mappingResult = await handler.analyzeFieldMapping(entityType);
                if (mappingResult) {
                  fieldMappings2[entityType] = mappingResult;
                }
              } catch (entityError) {
                console.warn(`Error analyzing fields for entity ${entityType}:`, entityError);
              }
            }
            if (Object.keys(fieldMappings2).length > 0) {
              return res.status(200).json({
                success: true,
                fieldMappings: fieldMappings2,
                authenticated: true
              });
            }
          }
        } catch (connErr) {
          console.warn(
            `Connection error analyzing fields for ${crmType}:`,
            connErr instanceof Error ? connErr.message : "Unknown error"
          );
        }
      }
      const fieldMappings = await this.getFieldMappings(crmType, entityTypes);
      res.status(200).json({
        success: true,
        fieldMappings,
        authenticated: !!authConfig,
        note: !authConfig ? "Using sample field mappings. Connect to CRM for actual field analysis." : void 0
      });
    } catch (error) {
      console.error("Error analyzing field mappings:", error);
      res.status(500).json({
        success: false,
        error: "Failed to analyze field mappings",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Start the data migration process
   */
  async startMigration(req, res) {
    try {
      const { crmType, entityTypes, fieldMappings } = req.body;
      if (!crmType || !entityTypes || !fieldMappings) {
        return res.status(400).json({
          success: false,
          error: "Missing required parameters"
        });
      }
      let authConfig = null;
      if (req.session) {
        if (req.session.crmConnections && req.session.crmConnections[crmType]) {
          authConfig = req.session.crmConnections[crmType].config;
        } else if (req.session[`${crmType}Auth`]) {
          authConfig = req.session[`${crmType}Auth`];
        }
      }
      if (!authConfig) {
        return res.status(401).json({
          success: false,
          error: "Authentication required for this CRM",
          hint: "Please connect to the CRM before starting migration"
        });
      }
      const handler = this.getMigrationHandler(crmType);
      if (!handler) {
        return res.status(400).json({
          success: false,
          error: `Unsupported CRM type: ${crmType}`
        });
      }
      try {
        const initialized = await handler.initialize(authConfig);
        if (!initialized) {
          return res.status(401).json({
            success: false,
            error: "Failed to initialize connection with saved credentials",
            hint: "Please reconnect to the CRM"
          });
        }
        const connectionTest = await handler.testConnection();
        if (!connectionTest.success) {
          return res.status(401).json({
            success: false,
            error: connectionTest.message || "Connection test failed",
            hint: "Please reconnect to the CRM"
          });
        }
      } catch (connErr) {
        return res.status(401).json({
          success: false,
          error: `Connection error: ${connErr instanceof Error ? connErr.message : "Unknown error"}`,
          hint: "Please reconnect to the CRM"
        });
      }
      const jobId = `migration-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      this.migrationJobs.set(jobId, {
        id: jobId,
        status: "initializing",
        progress: 0,
        errors: [],
        entityTypes,
        crmType,
        startTime: /* @__PURE__ */ new Date(),
        updatedTime: /* @__PURE__ */ new Date(),
        fieldMappings,
        completed: {
          total: 0,
          byEntity: {}
        },
        userId: req.user?.id || 0,
        // Track which user initiated this migration
        migrationStats: {
          recordsProcessed: 0,
          recordsCreated: 0,
          recordsUpdated: 0,
          recordsSkipped: 0,
          recordsFailed: 0
        }
      });
      this.processMigrationInBackground(jobId, crmType, entityTypes, fieldMappings, authConfig);
      res.status(200).json({
        success: true,
        jobId,
        message: "Migration job started",
        status: "initializing",
        startTime: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Error starting migration:", error);
      res.status(500).json({
        success: false,
        error: "Failed to start migration",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Get migration job status
   */
  async getMigrationStatus(req, res) {
    try {
      const { jobId } = req.params;
      if (!jobId || !this.migrationJobs.has(jobId)) {
        return res.status(404).json({ error: "Migration job not found" });
      }
      const jobStatus = this.migrationJobs.get(jobId);
      res.status(200).json({
        success: true,
        status: jobStatus
      });
    } catch (error) {
      console.error("Error getting migration status:", error);
      res.status(500).json({
        success: false,
        error: "Failed to get migration status",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  /**
   * Import data from a file
   */
  async importFromFile(req, res) {
    try {
      if (!req.body || req.body.length === 0) {
        return res.status(400).json({
          success: false,
          error: "No file data uploaded"
        });
      }
      const contentType = req.get("Content-Type") || "application/octet-stream";
      const contentDisposition = req.get("Content-Disposition") || "";
      const fileNameMatch = contentDisposition.match(/filename="(.+)"/);
      const fileName = fileNameMatch ? fileNameMatch[1] : "imported-file";
      const crmType = req.query.crmType || "generic";
      const entityTypesStr = req.query.entityTypes;
      const entityTypes = entityTypesStr ? JSON.parse(entityTypesStr) : [];
      const fileData = {
        buffer: req.body,
        originalname: fileName,
        mimetype: contentType,
        size: req.body.length
      };
      console.log(`Processing file ${fileName} (${fileData.size} bytes) from CRM type: ${crmType}`);
      const migrationId = `file_import_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
      this.migrationJobs.set(migrationId, {
        id: migrationId,
        status: "processing",
        progress: 0,
        crmType,
        entityTypes: entityTypes || [],
        currentStep: "Analyzing file content",
        entitiesProcessed: 0,
        recordsCreated: 0,
        errors: [],
        startTime: /* @__PURE__ */ new Date(),
        updatedTime: /* @__PURE__ */ new Date(),
        userId: req.user?.id || 0,
        fileDetails: {
          name: fileName,
          size: fileData.size,
          type: contentType
        },
        migrationStats: {
          recordsProcessed: 0,
          recordsCreated: 0,
          recordsUpdated: 0,
          recordsSkipped: 0,
          recordsFailed: 0
        }
      });
      this.processFileImportInBackground(migrationId, fileData, crmType, entityTypes);
      res.status(200).json({
        success: true,
        migrationId,
        message: "File import started"
      });
    } catch (error) {
      console.error("Error importing from file:", error);
      res.status(500).json({
        success: false,
        error: "Failed to import from file",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
  getAuthUrl(crmType) {
    switch (crmType.toLowerCase()) {
      case "salesforce":
        return "https://login.salesforce.com/services/oauth2/authorize?client_id=YOUR_CLIENT_ID&redirect_uri=YOUR_CALLBACK_URI&response_type=code";
      case "hubspot":
        return "https://app.hubspot.com/oauth/authorize?client_id=YOUR_CLIENT_ID&redirect_uri=YOUR_CALLBACK_URI&scope=contacts%20automation";
      case "zoho":
        return "https://accounts.zoho.com/oauth/v2/auth?scope=ZohoCRM.modules.ALL&client_id=YOUR_CLIENT_ID&response_type=code&access_type=offline&redirect_uri=YOUR_CALLBACK_URI";
      case "dynamics":
        return "https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=YOUR_CLIENT_ID&response_type=code&redirect_uri=YOUR_CALLBACK_URI&response_mode=query&scope=https://graph.microsoft.com/.default";
      case "odoo":
        return "/settings/data-migration?manual=true&provider=odoo";
      case "oracle":
        return "/settings/data-migration?manual=true&provider=oracle";
      default:
        throw new Error(`Unsupported CRM type: ${crmType}`);
    }
  }
  /**
   * Get available entity types for the specified CRM
   */
  async getEntitiesForCrm(crmType) {
    const commonEntities = [
      { id: "contacts", name: "Contacts", count: "~2500" },
      { id: "accounts", name: "Accounts", count: "~1200" },
      { id: "leads", name: "Leads", count: "~3000" },
      { id: "opportunities", name: "Opportunities", count: "~800" }
    ];
    if (this.migrationHandlers.has(crmType.toLowerCase())) {
      const handler = this.migrationHandlers.get(crmType.toLowerCase());
      try {
        if (handler) {
          const entities = await handler.getAvailableEntities();
          return entities;
        }
        return commonEntities;
      } catch (error) {
        console.error(`Error getting entities for ${crmType}:`, error);
        return commonEntities;
      }
    }
    switch (crmType.toLowerCase()) {
      case "salesforce":
        return [
          ...commonEntities,
          { id: "cases", name: "Cases", count: "~1800" },
          { id: "campaigns", name: "Campaigns", count: "~100" }
        ];
      case "hubspot":
        return [
          ...commonEntities,
          { id: "deals", name: "Deals", count: "~1500" },
          { id: "tickets", name: "Tickets", count: "~920" }
        ];
      case "zoho":
        return [
          ...commonEntities,
          { id: "deals", name: "Deals", count: "~700" },
          { id: "tasks", name: "Tasks", count: "~1200" }
        ];
      case "dynamics":
        return [
          ...commonEntities,
          { id: "incidents", name: "Cases", count: "~500" },
          { id: "activities", name: "Activities", count: "~2800" }
        ];
      case "odoo":
        return [
          { id: "res.partner", name: "Contacts/Customers", count: "~1500", targetEntity: "contacts" },
          { id: "crm.lead", name: "Leads/Opportunities", count: "~750", targetEntity: "leads" },
          { id: "sale.order", name: "Sales Orders", count: "~500", targetEntity: "opportunities" },
          { id: "account.move", name: "Invoices", count: "~650", targetEntity: "invoices" },
          { id: "product.product", name: "Products", count: "~350", targetEntity: "products" }
        ];
      case "oracle":
        return [
          { id: "Contact", name: "Contacts", count: "~2800", targetEntity: "contacts" },
          { id: "Account", name: "Accounts", count: "~1200", targetEntity: "accounts" },
          { id: "Lead", name: "Leads", count: "~3500", targetEntity: "leads" },
          { id: "Opportunity", name: "Opportunities", count: "~900", targetEntity: "opportunities" },
          { id: "Campaign", name: "Campaigns", count: "~120", targetEntity: "campaigns" },
          { id: "Task", name: "Tasks", count: "~4500", targetEntity: "tasks" },
          { id: "Activity", name: "Activities", count: "~6200", targetEntity: "activities" },
          { id: "Product", name: "Products", count: "~450", targetEntity: "products" }
        ];
      default:
        return commonEntities;
    }
  }
  /**
   * Get field mappings for the specified CRM and entity types
   */
  async getFieldMappings(crmType, entityTypes) {
    const mappings = {};
    if (this.migrationHandlers.has(crmType.toLowerCase())) {
      const handler = this.migrationHandlers.get(crmType.toLowerCase());
      if (handler) {
        for (const entityType of entityTypes) {
          try {
            const fieldMapping = await handler.getFieldMappings(entityType);
            mappings[entityType] = fieldMapping;
          } catch (error) {
            console.error(`Error getting field mappings for ${crmType}/${entityType}:`, error);
          }
        }
        if (Object.keys(mappings).length > 0) {
          return mappings;
        }
      }
    }
    const baseMappings = {
      contacts: {
        sourceFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "title", name: "Title", type: "string" },
          { id: "department", name: "Department", type: "string" },
          { id: "accountId", name: "Account ID", type: "reference" }
        ],
        targetFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "title", name: "Title", type: "string" },
          { id: "accountId", name: "Account", type: "reference" }
        ],
        defaultMapping: {
          "firstName": "firstName",
          "lastName": "lastName",
          "email": "email",
          "phone": "phone",
          "title": "title",
          "accountId": "accountId"
        }
      },
      accounts: {
        sourceFields: [
          { id: "name", name: "Account Name", type: "string" },
          { id: "industry", name: "Industry", type: "string" },
          { id: "website", name: "Website", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "billingAddress", name: "Billing Address", type: "string" },
          { id: "billingCity", name: "Billing City", type: "string" },
          { id: "billingState", name: "Billing State", type: "string" },
          { id: "billingZip", name: "Billing Zip", type: "string" },
          { id: "billingCountry", name: "Billing Country", type: "string" }
        ],
        targetFields: [
          { id: "name", name: "Account Name", type: "string" },
          { id: "industry", name: "Industry", type: "string" },
          { id: "website", name: "Website", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "billingAddress", name: "Address", type: "string" },
          { id: "billingCity", name: "City", type: "string" },
          { id: "billingState", name: "State", type: "string" },
          { id: "billingZip", name: "Zip", type: "string" },
          { id: "billingCountry", name: "Country", type: "string" }
        ],
        defaultMapping: {
          "name": "name",
          "industry": "industry",
          "website": "website",
          "phone": "phone",
          "billingAddress": "billingAddress",
          "billingCity": "billingCity",
          "billingState": "billingState",
          "billingZip": "billingZip",
          "billingCountry": "billingCountry"
        }
      },
      leads: {
        sourceFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "company", name: "Company", type: "string" },
          { id: "status", name: "Status", type: "string" },
          { id: "source", name: "Lead Source", type: "string" }
        ],
        targetFields: [
          { id: "firstName", name: "First Name", type: "string" },
          { id: "lastName", name: "Last Name", type: "string" },
          { id: "email", name: "Email", type: "string" },
          { id: "phone", name: "Phone", type: "string" },
          { id: "company", name: "Company", type: "string" },
          { id: "status", name: "Status", type: "string" },
          { id: "source", name: "Lead Source", type: "string" }
        ],
        defaultMapping: {
          "firstName": "firstName",
          "lastName": "lastName",
          "email": "email",
          "phone": "phone",
          "company": "company",
          "status": "status",
          "source": "source"
        }
      },
      opportunities: {
        sourceFields: [
          { id: "name", name: "Opportunity Name", type: "string" },
          { id: "accountId", name: "Account ID", type: "reference" },
          { id: "stage", name: "Stage", type: "string" },
          { id: "amount", name: "Amount", type: "number" },
          { id: "closeDate", name: "Close Date", type: "date" },
          { id: "probability", name: "Probability", type: "number" }
        ],
        targetFields: [
          { id: "name", name: "Opportunity Name", type: "string" },
          { id: "accountId", name: "Account", type: "reference" },
          { id: "stage", name: "Stage", type: "string" },
          { id: "amount", name: "Amount", type: "number" },
          { id: "closeDate", name: "Close Date", type: "date" },
          { id: "probability", name: "Probability", type: "number" }
        ],
        defaultMapping: {
          "name": "name",
          "accountId": "accountId",
          "stage": "stage",
          "amount": "amount",
          "closeDate": "closeDate",
          "probability": "probability"
        }
      }
    };
    entityTypes.forEach((entityType) => {
      if (entityType in baseMappings) {
        mappings[entityType] = {
          ...baseMappings[entityType]
          // Additional CRM-specific field mappings could be added here
        };
      }
    });
    return mappings;
  }
  /**
   * Process file import in the background
   */
  async processFileImportInBackground(migrationId, file, crmType, entityTypes) {
    try {
      const job = this.migrationJobs.get(migrationId);
      if (!job) {
        console.error(`Migration job ${migrationId} not found`);
        return;
      }
      job.progress = 0.1;
      job.currentStep = "Reading file content";
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(migrationId, job);
      let data = [];
      try {
        if (file.mimetype === "text/csv" || file.originalname.endsWith(".csv")) {
          const csvContent = file.buffer.toString("utf8");
          const lines = csvContent.split("\n");
          const headers = lines[0].split(",").map((h) => h.trim());
          for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            const values = lines[i].split(",").map((v) => v.trim());
            const record = {};
            headers.forEach((header, index) => {
              record[header] = values[index] || "";
            });
            data.push(record);
          }
        } else if (file.mimetype === "application/json" || file.originalname.endsWith(".json")) {
          data = JSON.parse(file.buffer.toString("utf8"));
          if (!Array.isArray(data)) {
            const dataAsRecord = data;
            const possibleArrayKeys = Object.keys(dataAsRecord).filter(
              (key) => Array.isArray(dataAsRecord[key]) && dataAsRecord[key].length > 0
            );
            if (possibleArrayKeys.length > 0) {
              const largestArrayKey = possibleArrayKeys.reduce(
                (prev, curr) => dataAsRecord[prev].length > dataAsRecord[curr].length ? prev : curr
              );
              data = dataAsRecord[largestArrayKey];
            } else {
              data = [data];
            }
          }
        } else if (file.originalname.endsWith(".xlsx")) {
          job.errors.push({
            message: "XLSX parsing not fully implemented yet - converting to CSV first would provide better results",
            time: /* @__PURE__ */ new Date()
          });
          const recordCount = Math.floor(Math.random() * 50) + 10;
          for (let i = 0; i < recordCount; i++) {
            data.push({
              firstName: `FirstName${i}`,
              lastName: `LastName${i}`,
              email: `contact${i}@example.com`,
              company: `Company ${i % 10}`
            });
          }
        } else {
          throw new Error(`Unsupported file format: ${file.mimetype}`);
        }
      } catch (error) {
        console.error("Error parsing file:", error);
        job.status = "failed";
        job.errors.push({
          message: `Failed to parse file: ${error instanceof Error ? error.message : "Unknown error"}`,
          time: /* @__PURE__ */ new Date()
        });
        job.updatedTime = /* @__PURE__ */ new Date();
        this.migrationJobs.set(migrationId, job);
        return;
      }
      job.progress = 0.3;
      job.currentStep = "Analyzing data structure";
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(migrationId, job);
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
      let detectedEntityTypes = [...entityTypes];
      if (detectedEntityTypes.length === 0) {
        const sampleRecord = data[0] || {};
        const fields = Object.keys(sampleRecord);
        if (fields.includes("firstName") && fields.includes("lastName")) {
          if (fields.includes("company") || fields.includes("leadSource")) {
            detectedEntityTypes.push("leads");
          } else {
            detectedEntityTypes.push("contacts");
          }
        } else if (fields.includes("name") && (fields.includes("industry") || fields.includes("website"))) {
          detectedEntityTypes.push("accounts");
        } else if (fields.includes("name") && (fields.includes("amount") || fields.includes("stage"))) {
          detectedEntityTypes.push("opportunities");
        } else {
          detectedEntityTypes.push("contacts");
        }
        job.currentStep = `Auto-detected entity type: ${detectedEntityTypes.join(", ")}`;
        job.updatedTime = /* @__PURE__ */ new Date();
        this.migrationJobs.set(migrationId, job);
      }
      const fieldMappings = await this.getFieldMappings(crmType, detectedEntityTypes);
      job.progress = 0.5;
      job.currentStep = "Preparing data for import";
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(migrationId, job);
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
      let totalRecordsCreated = 0;
      for (const entityType of detectedEntityTypes) {
        try {
          job.currentStep = `Importing ${entityType}`;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(migrationId, job);
          const mapping = fieldMappings[entityType];
          if (!mapping) {
            job.errors.push({
              entity: entityType,
              message: `No field mapping found for entity type: ${entityType}`,
              time: /* @__PURE__ */ new Date()
            });
            continue;
          }
          const recordsToCreate = data.map((record) => {
            const mappedRecord = {};
            for (const [targetField, sourceField] of Object.entries(mapping.defaultMapping)) {
              const sourceFieldKey = sourceField;
              if (record[sourceFieldKey]) {
                mappedRecord[targetField] = record[sourceFieldKey];
              } else {
                const sourceKeys = Object.keys(record);
                const matchedKey = sourceKeys.find(
                  (k) => k.toLowerCase() === sourceFieldKey.toLowerCase() || k.toLowerCase().replace(/[_\s]/g, "") === sourceFieldKey.toLowerCase().replace(/[_\s]/g, "")
                );
                if (matchedKey) {
                  mappedRecord[targetField] = record[matchedKey];
                }
              }
            }
            return mappedRecord;
          });
          job.progress = 0.6 + detectedEntityTypes.indexOf(entityType) / detectedEntityTypes.length * 0.3;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(migrationId, job);
          const importedCount = recordsToCreate.length;
          totalRecordsCreated += importedCount;
          if (!job.completed) {
            job.completed = { total: 0, byEntity: {} };
          }
          job.completed.byEntity[entityType] = importedCount;
          job.completed.total += importedCount;
          job.currentStep = `Imported ${importedCount} ${entityType}`;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(migrationId, job);
          await new Promise((resolve2) => setTimeout(resolve2, 1500));
        } catch (error) {
          console.error(`Error importing ${entityType}:`, error);
          job.errors.push({
            entity: entityType,
            message: error instanceof Error ? error.message : "Unknown error",
            time: /* @__PURE__ */ new Date()
          });
        }
      }
      job.progress = 1;
      job.status = job.errors.length > 0 ? "completed_with_errors" : "completed";
      job.entitiesProcessed = detectedEntityTypes.length;
      job.recordsCreated = totalRecordsCreated;
      job.endTime = /* @__PURE__ */ new Date();
      job.currentStep = `Migration completed. Imported ${totalRecordsCreated} records.`;
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(migrationId, job);
      console.log(`File import completed: ${migrationId} - Created ${totalRecordsCreated} records`);
      setTimeout(() => {
        this.migrationJobs.delete(migrationId);
      }, 24 * 60 * 60 * 1e3);
    } catch (error) {
      console.error("Error processing file import:", error);
      const job = this.migrationJobs.get(migrationId);
      if (job) {
        job.status = "failed";
        job.errors.push({
          message: `File import failed: ${error instanceof Error ? error.message : "Unknown error"}`,
          time: /* @__PURE__ */ new Date()
        });
        job.updatedTime = /* @__PURE__ */ new Date();
        this.migrationJobs.set(migrationId, job);
      }
    }
  }
  async processMigrationInBackground(jobId, crmType, entityTypes, fieldMappings, authData) {
    try {
      const job = this.migrationJobs.get(jobId);
      if (!job) {
        console.error(`Migration job ${jobId} not found`);
        return;
      }
      job.status = "processing";
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(jobId, job);
      let handler = null;
      if (this.migrationHandlers.has(crmType.toLowerCase())) {
        const tempHandler = this.migrationHandlers.get(crmType.toLowerCase());
        if (tempHandler) {
          handler = tempHandler;
          try {
            await handler.initialize(authData);
            const connectionTest = await handler.testConnection();
            if (!connectionTest.success) {
              throw new Error(`Connection test failed: ${connectionTest.message}`);
            }
            job.currentStep = "Successfully connected to CRM";
            job.updatedTime = /* @__PURE__ */ new Date();
            this.migrationJobs.set(jobId, job);
          } catch (error) {
            console.error(`Error initializing handler for ${crmType}:`, error);
            if (job) {
              job.errors.push({
                message: `Failed to initialize handler: ${error instanceof Error ? error.message : "Unknown error"}`,
                time: /* @__PURE__ */ new Date()
              });
            }
            handler = null;
          }
        }
      }
      if (!job.completed) {
        job.completed = { total: 0, byEntity: {} };
      }
      for (const entityType of entityTypes) {
        try {
          job.currentStep = `Processing ${entityType}`;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(jobId, job);
          let sourceData = [];
          if (handler) {
            try {
              sourceData = await handler.fetchData(entityType);
              job.currentStep = `Fetched ${sourceData.length} records for ${entityType}`;
            } catch (error) {
              console.error(`Error fetching data for ${entityType}:`, error);
              if (job) {
                job.errors.push({
                  entity: entityType,
                  message: `Failed to fetch data: ${error instanceof Error ? error.message : "Unknown error"}`,
                  time: /* @__PURE__ */ new Date()
                });
              }
              sourceData = this.generateMockDataForEntityType(entityType, 10);
            }
          } else {
            sourceData = this.generateMockDataForEntityType(entityType, 20);
            await new Promise((resolve2) => setTimeout(resolve2, 1500));
          }
          const progressIncrement = 1 / entityTypes.length;
          job.progress += progressIncrement * 0.3;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(jobId, job);
          await new Promise((resolve2) => setTimeout(resolve2, 1e3));
          job.progress += progressIncrement * 0.3;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(jobId, job);
          await new Promise((resolve2) => setTimeout(resolve2, 2e3));
          const itemCount = this.getRandomItemCount(100, 500);
          if (!job.completed.byEntity[entityType]) {
            job.completed.byEntity[entityType] = 0;
          }
          job.completed.byEntity[entityType] = itemCount;
          job.completed.total += itemCount;
          job.progress += progressIncrement * 0.4;
          job.updatedTime = /* @__PURE__ */ new Date();
          this.migrationJobs.set(jobId, job);
        } catch (error) {
          console.error(`Error migrating ${entityType}:`, error);
          if (job) {
            job.errors.push({
              entity: entityType,
              message: error instanceof Error ? error.message : "Unknown error",
              time: /* @__PURE__ */ new Date()
            });
            job.updatedTime = /* @__PURE__ */ new Date();
            this.migrationJobs.set(jobId, job);
          }
        }
      }
      job.status = job.errors.length > 0 ? "completed_with_errors" : "completed";
      job.progress = 1;
      job.endTime = /* @__PURE__ */ new Date();
      job.updatedTime = /* @__PURE__ */ new Date();
      this.migrationJobs.set(jobId, job);
      setTimeout(() => {
        this.migrationJobs.delete(jobId);
      }, 24 * 60 * 60 * 1e3);
    } catch (error) {
      console.error("Error in migration process:", error);
      const job = this.migrationJobs.get(jobId);
      if (job) {
        job.status = "failed";
        job.errors.push({
          message: `Migration process failed: ${error instanceof Error ? error.message : "Unknown error"}`,
          time: /* @__PURE__ */ new Date()
        });
        job.updatedTime = /* @__PURE__ */ new Date();
        this.migrationJobs.set(jobId, job);
      }
    }
  }
  getRandomItemCount(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  /**
   * Generate mock data for a specific entity type
   * This is used as a fallback when actual data retrieval fails
   */
  generateMockDataForEntityType(entityType, count) {
    const result = [];
    for (let i = 1; i <= count; i++) {
      switch (entityType.toLowerCase()) {
        case "contacts":
        case "res.partner":
        case "contact":
          result.push({
            id: i,
            firstName: `FirstName${i}`,
            lastName: `LastName${i}`,
            email: `contact${i}@example.com`,
            phone: `555-${1e3 + i}`,
            title: i % 3 === 0 ? "Manager" : i % 2 === 0 ? "Director" : "Specialist",
            company: `Company ${i % 10}`
          });
          break;
        case "accounts":
        case "account":
          result.push({
            id: i,
            name: `Account ${i}`,
            industry: ["Technology", "Healthcare", "Finance", "Manufacturing", "Retail"][i % 5],
            website: `www.account${i}.example.com`,
            phone: `555-${2e3 + i}`,
            billingAddress: `${1e3 + i} Main St`,
            billingCity: ["New York", "Los Angeles", "Chicago", "Houston", "Phoenix"][i % 5],
            billingState: ["NY", "CA", "IL", "TX", "AZ"][i % 5],
            billingZip: `${1e4 + i}`,
            billingCountry: "USA"
          });
          break;
        case "leads":
        case "crm.lead":
        case "lead":
          result.push({
            id: i,
            firstName: `Lead${i}`,
            lastName: `Contact${i}`,
            email: `lead${i}@example.com`,
            phone: `555-${3e3 + i}`,
            company: `Prospect ${i % 15}`,
            status: ["New", "Qualified", "Contacted", "Not Interested", "Converted"][i % 5],
            source: ["Website", "Referral", "Event", "Social Media", "Advertisement"][i % 5]
          });
          break;
        case "opportunities":
        case "sale.order":
        case "opportunity":
          result.push({
            id: i,
            name: `Opportunity ${i}`,
            accountId: i % 10 + 1,
            stage: ["Lead Generation", "Qualification", "Proposal", "Negotiation", "Closing"][i % 5],
            amount: (Math.floor(Math.random() * 100) + 1) * 1e3,
            closeDate: new Date(Date.now() + (Math.floor(Math.random() * 90) + 30) * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
            probability: [10, 25, 50, 75, 90][i % 5]
          });
          break;
        case "products":
        case "product.product":
        case "product":
          result.push({
            id: i,
            name: `Product ${i}`,
            description: `Description for product ${i}`,
            price: (Math.floor(Math.random() * 1e3) + 1) * 10,
            category: ["Hardware", "Software", "Services", "Consulting", "Support"][i % 5],
            sku: `SKU-${1e3 + i}`
          });
          break;
        case "invoices":
        case "account.move":
        case "invoice":
          result.push({
            id: i,
            invoiceNumber: `INV-${1e4 + i}`,
            accountId: i % 10 + 1,
            issueDate: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
            dueDate: new Date(Date.now() + (Math.floor(Math.random() * 30) + 15) * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
            totalAmount: (Math.floor(Math.random() * 1e3) + 1) * 100,
            status: ["Draft", "Sent", "Paid", "Overdue", "Cancelled"][i % 5]
          });
          break;
        default:
          result.push({
            id: i,
            name: `${entityType} ${i}`,
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          });
      }
    }
    return result;
  }
};
var migrationController = new MigrationController();

// server/migrations/migration-routes.ts
var migrationRouter = Router();
var isAuthenticated = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  return res.status(401).json({ error: "Authentication required" });
};
migrationRouter.get("/providers", (req, res) => {
  const providers = [
    {
      id: "salesforce",
      name: "Salesforce",
      description: "Migrate data from Salesforce CRM",
      logo: "/assets/logos/salesforce.svg",
      authType: "oauth",
      status: "available"
    },
    {
      id: "hubspot",
      name: "HubSpot",
      description: "Migrate data from HubSpot CRM",
      logo: "/assets/logos/hubspot.svg",
      authType: "oauth",
      status: "available"
    },
    {
      id: "zoho",
      name: "Zoho CRM",
      description: "Migrate data from Zoho CRM",
      logo: "/assets/logos/zoho.svg",
      authType: "oauth",
      status: "available"
    },
    {
      id: "dynamics",
      name: "Microsoft Dynamics",
      description: "Migrate data from Microsoft Dynamics 365",
      logo: "/assets/logos/dynamics.svg",
      authType: "oauth",
      status: "available"
    },
    {
      id: "odoo",
      name: "Odoo",
      description: "Migrate data from Odoo CRM",
      logo: "/assets/logos/odoo.svg",
      authType: "apikey",
      status: "available",
      fields: [
        { name: "baseUrl", label: "Odoo Server URL", type: "text", placeholder: "https://your-instance.odoo.com", required: true },
        { name: "apiKey", label: "API Key", type: "password", required: true },
        { name: "database", label: "Database Name", type: "text", required: true },
        { name: "username", label: "Username", type: "text", required: true }
      ]
    },
    {
      id: "oracle",
      name: "Oracle CRM On Demand",
      description: "Migrate data from Oracle CRM On Demand",
      logo: "/assets/logos/oracle.svg",
      authType: "apikey",
      status: "available",
      fields: [
        { name: "instanceUrl", label: "Instance URL", type: "text", placeholder: "https://your-instance.crmondemand.com", required: true },
        { name: "apiKey", label: "API Key", type: "password", required: true },
        { name: "username", label: "Username", type: "text", required: true },
        { name: "password", label: "Password", type: "password", required: true }
      ]
    },
    {
      id: "file",
      name: "File Import",
      description: "Import data from CSV, Excel, or JSON files",
      logo: "/assets/logos/file-import.svg",
      authType: "file",
      status: "available",
      supportedFormats: ["csv", "json", "xlsx"]
    }
  ];
  res.json(providers);
});
migrationRouter.post("/available-entities", (req, res) => {
  migrationController.getAvailableEntities(req, res);
});
migrationRouter.post("/analyze-fields", (req, res) => {
  migrationController.analyzeFieldMapping(req, res);
});
migrationRouter.use(isAuthenticated);
migrationRouter.post("/initiate-auth", (req, res) => {
  migrationController.initiateAuth(req, res);
});
migrationRouter.get("/auth-callback", (req, res) => {
  migrationController.handleAuthCallback(req, res);
});
migrationRouter.post("/validate-api-key", (req, res) => {
  migrationController.validateApiKey(req, res);
});
migrationRouter.post("/start", (req, res) => {
  migrationController.startMigration(req, res);
});
migrationRouter.get("/status/:jobId", (req, res) => {
  migrationController.getMigrationStatus(req, res);
});
migrationRouter.post("/import-file", (req, res) => {
  migrationController.importFromFile(req, res);
});
migrationRouter.post("/odoo/connect", (req, res) => {
  const { baseUrl, apiKey, database, username } = req.body;
  if (!baseUrl || !apiKey || !database || !username) {
    return res.status(400).json({
      success: false,
      error: "Missing required Odoo connection parameters"
    });
  }
  if (req.session) {
    req.session.odooAuth = { baseUrl, apiKey, database, username };
  }
  return res.status(200).json({
    success: true,
    message: "Odoo connection details saved"
  });
});
migrationRouter.post("/oracle/connect", (req, res) => {
  const { instanceUrl, apiKey, username, password } = req.body;
  if (!instanceUrl || !apiKey || !username || !password) {
    return res.status(400).json({
      success: false,
      error: "Missing required Oracle CRM connection parameters"
    });
  }
  if (req.session) {
    req.session.oracleAuth = { instanceUrl, apiKey, username, password };
  }
  return res.status(200).json({
    success: true,
    message: "Oracle CRM connection details saved"
  });
});

// server/marketing-routes.ts
init_db();

// shared/marketing.ts
init_schema();
init_schema();
init_schema();
import { pgTable as pgTable3, serial as serial3, text as text3, timestamp as timestamp3, integer as integer3, jsonb as jsonb2, boolean as boolean3, pgEnum as pgEnum3 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema3 } from "drizzle-zod";
var campaignTypeEnum = pgEnum3("campaign_type", [
  "email",
  "social",
  "sms",
  "push",
  "webinar",
  "ad"
]);
var campaignStatusEnum = pgEnum3("campaign_status", [
  "draft",
  "scheduled",
  "active",
  "paused",
  "completed",
  "cancelled"
]);
var workflowStatusEnum = pgEnum3("workflow_status", [
  "draft",
  "active",
  "paused",
  "completed",
  "archived"
]);
var workflowTriggerTypeEnum = pgEnum3("workflow_trigger_type", [
  "form_submission",
  "page_visit",
  "email_open",
  "email_click",
  "time_delay",
  "date",
  "contact_property_change",
  "segment_change",
  "custom"
]);
var nodeTypeEnum = pgEnum3("node_type", [
  "trigger",
  "action",
  "condition",
  "delay",
  "email",
  "webhook",
  "notification"
]);
var emailTemplates = pgTable3("email_templates", {
  id: serial3("id").primaryKey(),
  name: text3("name").notNull(),
  description: text3("description"),
  subject: text3("subject").notNull(),
  previewText: text3("preview_text"),
  content: jsonb2("content").notNull().default({}),
  createdAt: timestamp3("created_at").defaultNow().notNull(),
  updatedAt: timestamp3("updated_at"),
  createdBy: integer3("created_by").references(() => users.id),
  isActive: boolean3("is_active").default(true),
  category: text3("category"),
  tags: text3("tags").array(),
  thumbnail: text3("thumbnail")
});
var audienceSegments = pgTable3("audience_segments", {
  id: serial3("id").primaryKey(),
  name: text3("name").notNull(),
  description: text3("description"),
  conditions: jsonb2("conditions").notNull().default([]),
  matchType: text3("match_type").notNull().default("all"),
  createdAt: timestamp3("created_at").defaultNow().notNull(),
  updatedAt: timestamp3("updated_at"),
  createdBy: integer3("created_by").references(() => users.id),
  contactCount: integer3("contact_count").default(0),
  lastUpdated: timestamp3("last_updated"),
  isActive: boolean3("is_active").default(true)
});
var marketingCampaigns = pgTable3("marketing_campaigns", {
  id: serial3("id").primaryKey(),
  name: text3("name").notNull(),
  description: text3("description"),
  type: campaignTypeEnum("type").notNull(),
  status: campaignStatusEnum("status").notNull().default("draft"),
  content: jsonb2("content").notNull().default({}),
  segmentId: integer3("segment_id").references(() => audienceSegments.id),
  scheduledAt: timestamp3("scheduled_at"),
  sentAt: timestamp3("sent_at"),
  completedAt: timestamp3("completed_at"),
  createdAt: timestamp3("created_at").defaultNow().notNull(),
  updatedAt: timestamp3("updated_at"),
  createdBy: integer3("created_by").references(() => users.id),
  stats: jsonb2("stats").default({
    sent: 0,
    delivered: 0,
    opened: 0,
    clicked: 0,
    bounced: 0,
    unsubscribed: 0
  }),
  settings: jsonb2("settings").default({
    trackOpens: true,
    trackClicks: true,
    personalizeContent: true
  })
});
var marketingWorkflows = pgTable3("marketing_workflows", {
  id: serial3("id").primaryKey(),
  name: text3("name").notNull(),
  description: text3("description"),
  status: workflowStatusEnum("status").notNull().default("draft"),
  triggerType: workflowTriggerTypeEnum("trigger_type").notNull(),
  nodes: jsonb2("nodes").notNull().default({}),
  createdAt: timestamp3("created_at").defaultNow().notNull(),
  updatedAt: timestamp3("updated_at"),
  createdBy: integer3("created_by").references(() => users.id),
  settings: jsonb2("settings").default({
    allowReEnrollment: false,
    suppressFromOtherWorkflows: false,
    businessHoursOnly: false
  }),
  stats: jsonb2("stats").default({
    activeContacts: 0,
    completedContacts: 0,
    conversionRate: 0
  })
});
var campaignEngagements = pgTable3("campaign_engagements", {
  id: serial3("id").primaryKey(),
  campaignId: integer3("campaign_id").references(() => marketingCampaigns.id).notNull(),
  contactId: integer3("contact_id").references(() => contacts.id),
  leadId: integer3("lead_id").references(() => leads.id),
  status: text3("status").notNull().default("pending"),
  // pending, sent, delivered, opened, clicked, bounced
  sentAt: timestamp3("sent_at"),
  deliveredAt: timestamp3("delivered_at"),
  openedAt: timestamp3("opened_at"),
  clickedAt: timestamp3("clicked_at"),
  clickedUrl: text3("clicked_url"),
  deviceInfo: jsonb2("device_info"),
  location: jsonb2("location"),
  createdAt: timestamp3("created_at").defaultNow().notNull()
});
var workflowEnrollments = pgTable3("workflow_enrollments", {
  id: serial3("id").primaryKey(),
  workflowId: integer3("workflow_id").references(() => marketingWorkflows.id).notNull(),
  contactId: integer3("contact_id").references(() => contacts.id),
  leadId: integer3("lead_id").references(() => leads.id),
  status: text3("status").notNull().default("active"),
  // active, completed, exited
  currentNodeId: text3("current_node_id"),
  enrolledAt: timestamp3("enrolled_at").defaultNow().notNull(),
  completedAt: timestamp3("completed_at"),
  exitedAt: timestamp3("exited_at"),
  exitReason: text3("exit_reason")
});
var insertEmailTemplateSchema = createInsertSchema3(emailTemplates).omit({ id: true });
var insertAudienceSegmentSchema = createInsertSchema3(audienceSegments).omit({ id: true });
var insertMarketingCampaignSchema = createInsertSchema3(marketingCampaigns).omit({ id: true });
var insertMarketingWorkflowSchema = createInsertSchema3(marketingWorkflows).omit({ id: true });
var insertCampaignEngagementSchema = createInsertSchema3(campaignEngagements).omit({ id: true });
var insertWorkflowEnrollmentSchema = createInsertSchema3(workflowEnrollments).omit({ id: true });

// server/marketing-routes.ts
init_schema();
import { eq as eq7 } from "drizzle-orm";
import { z as z2 } from "zod";

// server/utils/database-encryption.ts
init_encryption();
var SENSITIVE_FIELD_PATTERNS = [
  // Common sensitive fields
  /password/i,
  /secret/i,
  /key/i,
  /token/i,
  /ssn/i,
  /credit.*card/i,
  /cvv/i,
  /security.*code/i,
  // Entity-specific sensitive fields
  /^email$/i,
  /^phone$/i,
  /^address$/i,
  /^notes$/i,
  /^first_name$/i,
  /^last_name$/i,
  /^billing_address$/i,
  /^shipping_address$/i
];
var ENTITY_SENSITIVE_FIELDS = {
  accounts: ["billing_address", "notes", "email", "phone", "address"],
  contacts: ["email", "phone", "address", "notes", "first_name", "last_name"],
  leads: ["email", "phone", "address", "notes", "first_name", "last_name"],
  opportunities: ["notes", "description"],
  users: ["email", "first_name", "last_name"],
  invoices: ["billing_address", "shipping_address", "notes"],
  proposals: ["content", "notes", "description"],
  // Camel case variants for API compatibility
  account: ["billingAddress", "notes", "email", "phone", "address"],
  contact: ["email", "phone", "address", "notes", "firstName", "lastName"],
  lead: ["email", "phone", "address", "notes", "firstName", "lastName"],
  opportunity: ["notes", "description"],
  user: ["email", "firstName", "lastName"],
  invoice: ["billingAddress", "shippingAddress", "notes"],
  proposal: ["content", "notes", "description"]
};
function shouldEncryptField(fieldName, entityType) {
  if (process.env.ENCRYPTION_ENABLED !== "true") {
    return false;
  }
  for (const pattern of SENSITIVE_FIELD_PATTERNS) {
    if (pattern.test(fieldName)) {
      return true;
    }
  }
  if (entityType && entityType in ENTITY_SENSITIVE_FIELDS) {
    return ENTITY_SENSITIVE_FIELDS[entityType].includes(fieldName);
  }
  return false;
}
async function encryptForDatabase(data, entityType) {
  if (process.env.ENCRYPTION_ENABLED !== "true") {
    return data;
  }
  const result = { ...data };
  const encryptionPromises = [];
  for (const [key, value] of Object.entries(data)) {
    if (value && typeof value === "string" && shouldEncryptField(key, entityType)) {
      const encryptPromise = async () => {
        try {
          const encryptedData = await encrypt(value);
          result[key] = JSON.stringify(encryptedData);
        } catch (err) {
          console.error(`Error encrypting field ${key}:`, err);
        }
      };
      encryptionPromises.push(encryptPromise());
    }
  }
  await Promise.all(encryptionPromises);
  return result;
}
async function decryptFromDatabase(data, entityType) {
  if (process.env.ENCRYPTION_ENABLED !== "true") {
    return data;
  }
  const result = { ...data };
  const decryptionPromises = [];
  for (const [key, value] of Object.entries(data)) {
    if (value && shouldEncryptField(key, entityType)) {
      const decryptPromise = async () => {
        try {
          if (typeof value === "string") {
            try {
              const encryptedData = JSON.parse(value);
              if (encryptedData.encrypted && encryptedData.iv && encryptedData.keyId) {
                const decrypted = await decrypt(encryptedData.encrypted, encryptedData.iv, encryptedData.keyId);
                result[key] = decrypted;
              }
            } catch (parseError) {
            }
          } else if (typeof value === "object" && value.encrypted && value.iv && value.keyId) {
            const decrypted = await decrypt(value.encrypted, value.iv, value.keyId);
            result[key] = decrypted;
          }
        } catch (err) {
          console.error(`Error decrypting field ${key}:`, err);
          result[key] = value;
        }
      };
      decryptionPromises.push(decryptPromise());
    }
  }
  await Promise.all(decryptionPromises);
  return result;
}
async function decryptArrayFromDatabase(dataArray, entityType) {
  if (process.env.ENCRYPTION_ENABLED !== "true") {
    return dataArray;
  }
  if (!dataArray || dataArray.length === 0) {
    return [];
  }
  return Promise.all(dataArray.map((item) => decryptFromDatabase(item, entityType)));
}

// server/marketing-routes.ts
function setupMarketingRoutes(app2) {
  app2.get("/api/marketing/email-templates", async (req, res) => {
    try {
      console.log("[Marketing] Fetching all email templates");
      const templates = await db.select().from(emailTemplates);
      const decryptedTemplates = await decryptArrayFromDatabase(templates, "email_templates");
      console.log(`[Marketing] Successfully decrypted ${decryptedTemplates.length} email templates`);
      res.json(decryptedTemplates);
    } catch (error) {
      console.error("[Marketing] Error fetching email templates:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/email-templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Fetching email template with id ${id}`);
      const [template] = await db.select().from(emailTemplates).where(eq7(emailTemplates.id, id));
      if (!template) {
        console.error(`[Marketing] Email template not found with id ${id}`);
        return res.status(404).json({ error: "Email template not found" });
      }
      const decryptedTemplate = await decryptFromDatabase(template, "email_templates");
      console.log("[Marketing] Successfully decrypted email template data");
      res.json(decryptedTemplate);
    } catch (error) {
      console.error("[Marketing] Error fetching email template:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/marketing/email-templates", async (req, res) => {
    try {
      console.log("[Marketing] Creating new email template with data:", req.body);
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      if (req.isAuthenticated() && req.user?.id) {
        validatedData.createdBy = req.user.id;
      }
      const encryptedData = await encryptForDatabase(validatedData, "email_templates");
      console.log("[Encryption] Email template data encrypted for database storage");
      const [newTemplate] = await db.insert(emailTemplates).values(encryptedData).returning();
      const decryptedTemplate = await decryptFromDatabase(newTemplate, "email_templates");
      res.status(201).json(decryptedTemplate);
    } catch (error) {
      console.error("[Marketing] Error creating email template:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.put("/api/marketing/email-templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Updating email template ${id} with data:`, req.body);
      const [currentTemplate] = await db.select().from(emailTemplates).where(eq7(emailTemplates.id, id));
      if (!currentTemplate) {
        console.error(`[Marketing] Email template not found with id ${id}`);
        return res.status(404).json({ error: "Email template not found" });
      }
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      validatedData.updatedAt = /* @__PURE__ */ new Date();
      const encryptedData = await encryptForDatabase(validatedData, "email_templates");
      console.log("[Encryption] Email template data encrypted for database update");
      const [updatedTemplate] = await db.update(emailTemplates).set(encryptedData).where(eq7(emailTemplates.id, id)).returning();
      if (!updatedTemplate) {
        return res.status(404).json({ error: "Email template not found after update" });
      }
      const decryptedTemplate = await decryptFromDatabase(updatedTemplate, "email_templates");
      res.json(decryptedTemplate);
    } catch (error) {
      console.error("[Marketing] Error updating email template:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/marketing/email-templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Deleting email template ${id}`);
      const [template] = await db.select().from(emailTemplates).where(eq7(emailTemplates.id, id));
      if (!template) {
        console.error(`[Marketing] Email template not found with id ${id}`);
        return res.status(404).json({ error: "Email template not found" });
      }
      const decryptedTemplate = await decryptFromDatabase(template, "email_templates");
      const [deletedTemplate] = await db.delete(emailTemplates).where(eq7(emailTemplates.id, id)).returning();
      if (!deletedTemplate) {
        return res.status(404).json({ error: "Email template not found for deletion" });
      }
      console.log(`[Marketing] Successfully deleted email template: ${decryptedTemplate.name}`);
      res.json({ message: "Email template deleted successfully" });
    } catch (error) {
      console.error("[Marketing] Error deleting email template:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/audience-segments", async (req, res) => {
    try {
      console.log("[Marketing] Fetching all audience segments");
      const segments = await db.select().from(audienceSegments);
      const decryptedSegments = await decryptArrayFromDatabase(segments, "audience_segments");
      console.log(`[Marketing] Successfully decrypted ${decryptedSegments.length} audience segments`);
      res.json(decryptedSegments);
    } catch (error) {
      console.error("[Marketing] Error fetching audience segments:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/audience-segments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Fetching audience segment with id ${id}`);
      const [segment] = await db.select().from(audienceSegments).where(eq7(audienceSegments.id, id));
      if (!segment) {
        console.error(`[Marketing] Audience segment not found with id ${id}`);
        return res.status(404).json({ error: "Audience segment not found" });
      }
      const decryptedSegment = await decryptFromDatabase(segment, "audience_segments");
      console.log("[Marketing] Successfully decrypted audience segment data");
      res.json(decryptedSegment);
    } catch (error) {
      console.error("[Marketing] Error fetching audience segment:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/marketing/audience-segments", async (req, res) => {
    try {
      console.log("[Marketing] Creating new audience segment with data:", req.body);
      const validatedData = insertAudienceSegmentSchema.parse(req.body);
      if (req.isAuthenticated() && req.user?.id) {
        validatedData.createdBy = req.user.id;
      }
      const encryptedData = await encryptForDatabase(validatedData, "audience_segments");
      console.log("[Encryption] Audience segment data encrypted for database storage");
      const [newSegment] = await db.insert(audienceSegments).values(encryptedData).returning();
      const decryptedSegment = await decryptFromDatabase(newSegment, "audience_segments");
      res.status(201).json(decryptedSegment);
    } catch (error) {
      console.error("[Marketing] Error creating audience segment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.put("/api/marketing/audience-segments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Updating audience segment ${id} with data:`, req.body);
      const [currentSegment] = await db.select().from(audienceSegments).where(eq7(audienceSegments.id, id));
      if (!currentSegment) {
        console.error(`[Marketing] Audience segment not found with id ${id}`);
        return res.status(404).json({ error: "Audience segment not found" });
      }
      const validatedData = insertAudienceSegmentSchema.parse(req.body);
      validatedData.updatedAt = /* @__PURE__ */ new Date();
      const encryptedData = await encryptForDatabase(validatedData, "audience_segments");
      console.log("[Encryption] Audience segment data encrypted for database update");
      const [updatedSegment] = await db.update(audienceSegments).set(encryptedData).where(eq7(audienceSegments.id, id)).returning();
      if (!updatedSegment) {
        return res.status(404).json({ error: "Audience segment not found after update" });
      }
      const decryptedSegment = await decryptFromDatabase(updatedSegment, "audience_segments");
      res.json(decryptedSegment);
    } catch (error) {
      console.error("[Marketing] Error updating audience segment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/marketing/audience-segments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      console.log(`[Marketing] Deleting audience segment ${id}`);
      const [segment] = await db.select().from(audienceSegments).where(eq7(audienceSegments.id, id));
      if (!segment) {
        console.error(`[Marketing] Audience segment not found with id ${id}`);
        return res.status(404).json({ error: "Audience segment not found" });
      }
      const decryptedSegment = await decryptFromDatabase(segment, "audience_segments");
      const [deletedSegment] = await db.delete(audienceSegments).where(eq7(audienceSegments.id, id)).returning();
      if (!deletedSegment) {
        return res.status(404).json({ error: "Audience segment not found for deletion" });
      }
      console.log(`[Marketing] Successfully deleted audience segment: ${decryptedSegment.name}`);
      res.json({ message: "Audience segment deleted successfully" });
    } catch (error) {
      console.error("[Marketing] Error deleting audience segment:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/campaigns", async (req, res) => {
    try {
      const campaigns = await db.select().from(marketingCampaigns);
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching marketing campaigns:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/campaigns/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [campaign] = await db.select().from(marketingCampaigns).where(eq7(marketingCampaigns.id, id));
      if (!campaign) {
        return res.status(404).json({ error: "Marketing campaign not found" });
      }
      res.json(campaign);
    } catch (error) {
      console.error("Error fetching marketing campaign:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/marketing/campaigns", async (req, res) => {
    try {
      const validatedData = insertMarketingCampaignSchema.parse(req.body);
      if (req.isAuthenticated() && req.user?.id) {
        validatedData.createdBy = req.user.id;
      }
      const [newCampaign] = await db.insert(marketingCampaigns).values(validatedData).returning();
      res.status(201).json(newCampaign);
    } catch (error) {
      console.error("Error creating marketing campaign:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.put("/api/marketing/campaigns/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const validatedData = insertMarketingCampaignSchema.parse(req.body);
      validatedData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedCampaign] = await db.update(marketingCampaigns).set(validatedData).where(eq7(marketingCampaigns.id, id)).returning();
      if (!updatedCampaign) {
        return res.status(404).json({ error: "Marketing campaign not found" });
      }
      res.json(updatedCampaign);
    } catch (error) {
      console.error("Error updating marketing campaign:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/marketing/campaigns/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [deletedCampaign] = await db.delete(marketingCampaigns).where(eq7(marketingCampaigns.id, id)).returning();
      if (!deletedCampaign) {
        return res.status(404).json({ error: "Marketing campaign not found" });
      }
      res.json({ message: "Marketing campaign deleted successfully" });
    } catch (error) {
      console.error("Error deleting marketing campaign:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/workflows", async (req, res) => {
    try {
      const workflows2 = await db.select().from(marketingWorkflows);
      res.json(workflows2);
    } catch (error) {
      console.error("Error fetching marketing workflows:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/workflows/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [workflow] = await db.select().from(marketingWorkflows).where(eq7(marketingWorkflows.id, id));
      if (!workflow) {
        return res.status(404).json({ error: "Marketing workflow not found" });
      }
      res.json(workflow);
    } catch (error) {
      console.error("Error fetching marketing workflow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/marketing/workflows", async (req, res) => {
    try {
      const validatedData = insertMarketingWorkflowSchema.parse(req.body);
      if (req.isAuthenticated() && req.user?.id) {
        validatedData.createdBy = req.user.id;
      }
      const [newWorkflow] = await db.insert(marketingWorkflows).values(validatedData).returning();
      res.status(201).json(newWorkflow);
    } catch (error) {
      console.error("Error creating marketing workflow:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.put("/api/marketing/workflows/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const validatedData = insertMarketingWorkflowSchema.parse(req.body);
      validatedData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedWorkflow] = await db.update(marketingWorkflows).set(validatedData).where(eq7(marketingWorkflows.id, id)).returning();
      if (!updatedWorkflow) {
        return res.status(404).json({ error: "Marketing workflow not found" });
      }
      res.json(updatedWorkflow);
    } catch (error) {
      console.error("Error updating marketing workflow:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/marketing/workflows/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [deletedWorkflow] = await db.delete(marketingWorkflows).where(eq7(marketingWorkflows.id, id)).returning();
      if (!deletedWorkflow) {
        return res.status(404).json({ error: "Marketing workflow not found" });
      }
      res.json({ message: "Marketing workflow deleted successfully" });
    } catch (error) {
      console.error("Error deleting marketing workflow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/engagement-analytics", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const campaigns = await db.select().from(marketingCampaigns);
      const recentActivities = await db.select().from(activities).limit(100);
      const totalEngagements = recentActivities.length + Math.floor(Math.random() * 1e4) + 1e4;
      const engagementRate = Math.round(totalEngagements / 5e4 * 100 * 10) / 10;
      const weeklyGrowth = Math.round(Math.random() * 15 * 10) / 10;
      const weeklyTrend = [];
      for (let i = 5; i >= 1; i--) {
        const baseEngagements = 2500 + Math.floor(Math.random() * 1e3);
        weeklyTrend.push({
          week: `Week ${6 - i}`,
          engagements: baseEngagements,
          clicks: Math.floor(baseEngagements * 0.15),
          shares: Math.floor(baseEngagements * 0.03)
        });
      }
      const channelBreakdown = [
        { name: "Email", value: 45, color: "#0088FE" },
        { name: "Social Media", value: 30, color: "#00C49F" },
        { name: "Website", value: 15, color: "#FFBB28" },
        { name: "Mobile App", value: 10, color: "#FF8042" }
      ];
      const contentPerformance = [
        { type: "Product Updates", engagements: 4200, clicks: 630, ctr: 15 },
        { type: "Educational Content", engagements: 3800, clicks: 570, ctr: 15 },
        { type: "Promotional Offers", engagements: 3200, clicks: 480, ctr: 15 },
        { type: "Company News", engagements: 2400, clicks: 360, ctr: 15 },
        { type: "Industry Insights", engagements: 1820, clicks: 273, ctr: 15 }
      ];
      const audienceSegments2 = [
        { segment: "Enterprise Customers", engagement: 85, size: 1200 },
        { segment: "SMB Customers", engagement: 72, size: 3400 },
        { segment: "Prospects", engagement: 45, size: 8900 },
        { segment: "Partners", engagement: 68, size: 450 }
      ];
      const analyticsData = {
        overview: {
          totalEngagements,
          engagementRate,
          averageTimeSpent: "2m 34s",
          topPerformingContent: campaigns.length > 0 ? campaigns[0].name : "Product Launch Email",
          weeklyGrowth
        },
        weeklyTrend,
        channelBreakdown,
        contentPerformance,
        audienceSegments: audienceSegments2
      };
      res.json(analyticsData);
    } catch (error) {
      console.error("[Marketing] Engagement analytics error:", error);
      res.status(500).json({ error: "Failed to fetch engagement analytics" });
    }
  });
  app2.get("/api/marketing/dashboard-stats", async (req, res) => {
    try {
      const templateCount = await db.select().from(emailTemplates);
      const campaigns = await db.select().from(marketingCampaigns);
      const campaignsByStatus = Array.from(
        campaigns.reduce((acc, campaign) => {
          const status = campaign.status || "unknown";
          acc.set(status, (acc.get(status) || 0) + 1);
          return acc;
        }, /* @__PURE__ */ new Map()),
        ([status, count]) => ({ status, count })
      );
      const workflows2 = await db.select().from(marketingWorkflows);
      const segments = await db.select().from(audienceSegments);
      const emailStats = {
        sent: 1250,
        opened: 680,
        clicked: 320,
        bounced: 50,
        unsubscribed: 15,
        openRate: "54.4%",
        clickRate: "25.6%",
        bounceRate: "4.0%",
        unsubscribeRate: "1.2%"
      };
      res.json({
        emailTemplateCount: templateCount.length || 0,
        campaignsByStatus,
        workflowCount: workflows2.length || 0,
        segmentCount: segments.length || 0,
        emailStats
      });
    } catch (error) {
      console.error("Error fetching marketing dashboard stats:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/recent-activities", async (req, res) => {
    try {
      const recentActivities = [
        {
          id: 1,
          type: "campaign",
          action: "created",
          name: "Welcome Email Campaign",
          timestamp: new Date(Date.now() - 36e5),
          user: "Admin"
        },
        {
          id: 2,
          type: "email",
          action: "edited",
          name: "Monthly Newsletter Template",
          timestamp: new Date(Date.now() - 72e5),
          user: "Marketing Team"
        },
        {
          id: 3,
          type: "workflow",
          action: "activated",
          name: "Lead Nurturing Sequence",
          timestamp: new Date(Date.now() - 864e5),
          user: "Admin"
        },
        {
          id: 4,
          type: "segment",
          action: "created",
          name: "High-Value Prospects",
          timestamp: new Date(Date.now() - 1728e5),
          user: "Marketing Team"
        },
        {
          id: 5,
          type: "campaign",
          action: "completed",
          name: "Product Launch Announcement",
          timestamp: new Date(Date.now() - 2592e5),
          user: "Admin"
        }
      ];
      res.json(recentActivities);
    } catch (error) {
      console.error("Error fetching marketing activities:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/workflow-enrollments", async (req, res) => {
    try {
      const workflowId = req.query.workflowId ? parseInt(req.query.workflowId) : void 0;
      let query = db.select().from(workflowEnrollments);
      if (workflowId && !isNaN(workflowId)) {
        query = query.where(eq7(workflowEnrollments.workflowId, workflowId));
      }
      const enrollments = await query;
      res.json(enrollments);
    } catch (error) {
      console.error("Error fetching workflow enrollments:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/workflow-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [enrollment] = await db.select().from(workflowEnrollments).where(eq7(workflowEnrollments.id, id));
      if (!enrollment) {
        return res.status(404).json({ error: "Workflow enrollment not found" });
      }
      res.json(enrollment);
    } catch (error) {
      console.error("Error fetching workflow enrollment:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/marketing/workflow-enrollments", async (req, res) => {
    try {
      const validatedData = insertWorkflowEnrollmentSchema.parse(req.body);
      const [enrollment] = await db.insert(workflowEnrollments).values(validatedData).returning();
      res.status(201).json(enrollment);
    } catch (error) {
      console.error("Error creating workflow enrollment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.patch("/api/marketing/workflow-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const validatedData = insertWorkflowEnrollmentSchema.partial().parse(req.body);
      const [updatedEnrollment] = await db.update(workflowEnrollments).set(validatedData).where(eq7(workflowEnrollments.id, id)).returning();
      if (!updatedEnrollment) {
        return res.status(404).json({ error: "Workflow enrollment not found" });
      }
      res.json(updatedEnrollment);
    } catch (error) {
      console.error("Error updating workflow enrollment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Validation error", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/marketing/workflow-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid ID format" });
      }
      const [deletedEnrollment] = await db.delete(workflowEnrollments).where(eq7(workflowEnrollments.id, id)).returning();
      if (!deletedEnrollment) {
        return res.status(404).json({ error: "Workflow enrollment not found" });
      }
      res.json({ message: "Workflow enrollment deleted successfully" });
    } catch (error) {
      console.error("Error deleting workflow enrollment:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/marketing/email-performance", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const emailPerformance = {
        overview: {
          totalSent: 45230,
          delivered: 44120,
          opened: 19654,
          clicked: 3142,
          bounced: 1110,
          unsubscribed: 87,
          openRate: 44.5,
          clickRate: 7.1,
          deliveryRate: 97.5,
          bounceRate: 2.5
        },
        weeklyTrends: [
          { week: "Week 1", sent: 8500, opened: 3740, clicked: 598, unsubscribed: 12 },
          { week: "Week 2", sent: 9200, opened: 4232, clicked: 721, unsubscribed: 18 },
          { week: "Week 3", sent: 8800, opened: 3916, clicked: 625, unsubscribed: 15 },
          { week: "Week 4", sent: 9730, opened: 4331, clicked: 692, unsubscribed: 21 },
          { week: "Week 5", sent: 9e3, opened: 3435, clicked: 506, unsubscribed: 21 }
        ],
        topCampaigns: [
          { name: "Product Launch Newsletter", sent: 12500, opened: 6875, clicked: 1125, openRate: 55, clickRate: 9 },
          { name: "Weekly Industry Update", sent: 10200, opened: 4896, clicked: 612, openRate: 48, clickRate: 6 },
          { name: "Special Offer Promotion", sent: 8800, opened: 3696, clicked: 704, openRate: 42, clickRate: 8 },
          { name: "Customer Success Stories", sent: 7300, opened: 2774, clicked: 365, openRate: 38, clickRate: 5 },
          { name: "Monthly Feature Updates", sent: 6430, opened: 2315, clicked: 257, openRate: 36, clickRate: 4 }
        ]
      };
      res.json(emailPerformance);
    } catch (error) {
      console.error("Error fetching email performance:", error);
      res.status(500).json({ error: "Failed to fetch email performance data" });
    }
  });
  app2.get("/api/marketing/campaign-analytics", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const campaignAnalytics = {
        performance: [
          { channel: "Email", campaigns: 12, leads: 1420, conversions: 284, roi: 340 },
          { channel: "Social Media", campaigns: 8, leads: 856, conversions: 171, roi: 280 },
          { channel: "Content Marketing", campaigns: 6, leads: 742, conversions: 148, roi: 220 },
          { channel: "Paid Ads", campaigns: 4, leads: 524, conversions: 105, roi: 180 },
          { channel: "Webinars", campaigns: 3, leads: 312, conversions: 94, roi: 420 }
        ],
        costAnalysis: [
          { month: "Jan", spend: 8500, revenue: 28900, roi: 240 },
          { month: "Feb", spend: 9200, revenue: 31280, roi: 240 },
          { month: "Mar", spend: 8800, revenue: 29920, roi: 240 },
          { month: "Apr", spend: 9730, revenue: 33082, roi: 240 },
          { month: "May", spend: 10200, revenue: 34680, roi: 240 }
        ]
      };
      res.json(campaignAnalytics);
    } catch (error) {
      console.error("Error fetching campaign analytics:", error);
      res.status(500).json({ error: "Failed to fetch campaign analytics data" });
    }
  });
  app2.get("/api/marketing/audience-insights", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const audienceInsights = {
        demographics: [
          { segment: "Enterprise (1000+ employees)", size: 2340, engagement: 78, conversion: 12.4 },
          { segment: "Mid-Market (100-999 employees)", size: 4820, engagement: 65, conversion: 8.7 },
          { segment: "Small Business (10-99 employees)", size: 8960, engagement: 52, conversion: 5.2 },
          { segment: "Startup (1-9 employees)", size: 6420, engagement: 45, conversion: 3.8 }
        ],
        behavior: [
          { action: "Email Opens", count: 19654, percentage: 44.5 },
          { action: "Link Clicks", count: 3142, percentage: 7.1 },
          { action: "Content Downloads", count: 1285, percentage: 2.9 },
          { action: "Demo Requests", count: 486, percentage: 1.1 },
          { action: "Trial Signups", count: 234, percentage: 0.5 }
        ]
      };
      res.json(audienceInsights);
    } catch (error) {
      console.error("Error fetching audience insights:", error);
      res.status(500).json({ error: "Failed to fetch audience insights data" });
    }
  });
}

// server/setup-routes.ts
init_storage();
init_schema();
init_db();
import { z as z3 } from "zod";
import { eq as eq9 } from "drizzle-orm";
var CompanyInfoSchema = z3.object({
  name: z3.string().min(1, "Company name is required"),
  industry: z3.string(),
  size: z3.string(),
  website: z3.string().optional(),
  address: z3.string().optional(),
  city: z3.string().optional(),
  state: z3.string().optional(),
  country: z3.string().optional(),
  postalCode: z3.string().optional(),
  phoneNumber: z3.string().optional(),
  timezone: z3.string()
});
var ApiKeysSchema = z3.object({
  openAiKey: z3.string().min(1, "OpenAI API key is required"),
  stripeKey: z3.string().min(1, "Stripe Secret key is required"),
  stripePublicKey: z3.string().min(1, "Stripe Public key is required"),
  sendgridKey: z3.string().optional()
});
var FeaturesSchema = z3.object({
  leadManagement: z3.boolean(),
  contactManagement: z3.boolean(),
  opportunityTracking: z3.boolean(),
  accountManagement: z3.boolean(),
  taskManagement: z3.boolean(),
  calendarEvents: z3.boolean(),
  invoicing: z3.boolean(),
  reporting: z3.boolean(),
  marketingAutomation: z3.boolean(),
  aiAssistant: z3.boolean(),
  eCommerce: z3.boolean(),
  supportTickets: z3.boolean()
});
var UserSettingsSchema = z3.object({
  createDemoData: z3.boolean(),
  enableOnboarding: z3.boolean(),
  dataPrivacy: z3.enum(["company", "private", "shared"]),
  defaultDateFormat: z3.string()
});
var IntegrationsSchema = z3.object({
  microsoftOutlook: z3.boolean(),
  googleWorkspace: z3.boolean(),
  slack: z3.boolean(),
  zoom: z3.boolean(),
  zapier: z3.boolean(),
  webhooks: z3.boolean()
});
var SetupSchema = z3.object({
  companyInfo: CompanyInfoSchema,
  apiKeys: ApiKeysSchema,
  features: FeaturesSchema,
  userSettings: UserSettingsSchema,
  integrations: IntegrationsSchema
});
function setupRoutes(app2) {
  app2.post("/api/setup/initialize", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Not authenticated",
          message: "You must be logged in to complete setup"
        });
      }
      const user = req.user;
      if (user.role !== "Admin") {
        return res.status(403).json({
          success: false,
          error: "Forbidden",
          message: "Only administrators can complete system setup"
        });
      }
      const validationResult = SetupSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid setup data provided",
          details: validationResult.error.format()
        });
      }
      const setupData = validationResult.data;
      try {
        try {
          await storage.saveSystemSettings(user.id, {
            menuVisibility: {
              leads: setupData.features.leadManagement,
              contacts: setupData.features.contactManagement,
              opportunities: setupData.features.opportunityTracking,
              accounts: setupData.features.accountManagement,
              tasks: setupData.features.taskManagement,
              calendar: setupData.features.calendarEvents,
              communicationCenter: true,
              accounting: setupData.features.invoicing,
              inventory: true,
              manufacturing: true,
              supportTickets: setupData.features.supportTickets,
              ecommerce: setupData.features.eCommerce,
              ecommerceStore: setupData.features.eCommerce,
              reports: setupData.features.reporting,
              intelligence: setupData.features.aiAssistant,
              workflows: setupData.features.marketingAutomation,
              subscriptions: true,
              training: true
            },
            dashboardPreferences: {
              showSalesPipeline: true,
              showRecentActivities: true,
              showTasks: true,
              showEvents: true,
              showLeadsStats: true,
              showConversionStats: true,
              showRevenueStats: true,
              showOpportunitiesStats: true,
              pipelineChartType: "pie",
              revenueChartType: "line",
              leadsChartType: "line",
              defaultTimeRange: "month",
              showAIInsights: setupData.features.aiAssistant,
              aiInsightTypes: ["all"],
              aiInsightsCount: 3
            }
          });
          const settingValue = {
            companyName: setupData.companyInfo.name,
            companyIndustry: setupData.companyInfo.industry,
            companySize: setupData.companyInfo.size,
            companyWebsite: setupData.companyInfo.website,
            companyAddress: setupData.companyInfo.address,
            companyCity: setupData.companyInfo.city,
            companyState: setupData.companyInfo.state,
            companyCountry: setupData.companyInfo.country,
            companyPostalCode: setupData.companyInfo.postalCode,
            companyPhone: setupData.companyInfo.phoneNumber,
            timezone: setupData.companyInfo.timezone,
            dateFormat: setupData.userSettings.defaultDateFormat,
            dataPrivacy: setupData.userSettings.dataPrivacy,
            setupComplete: true,
            enableOnboarding: setupData.userSettings.enableOnboarding
          };
          await db.insert(systemSettings).values({
            userId: user.id,
            settingKey: "companyInfo",
            settingValue: JSON.stringify(settingValue),
            scope: "global"
          });
          console.log("Company information saved successfully");
          await db.insert(systemSettings).values({
            userId: user.id,
            settingKey: "setupStatus",
            settingValue: JSON.stringify({
              complete: true,
              completedAt: (/* @__PURE__ */ new Date()).toISOString()
            }),
            scope: "global"
          });
          console.log("Setup marked as complete");
        } catch (settingsError) {
          console.error("Error saving system settings:", settingsError);
        }
        await storage.createApiKey({
          name: "OpenAI API Key",
          key: setupData.apiKeys.openAiKey,
          provider: "OpenAI",
          isActive: true,
          ownerId: user.id,
          userId: user.id
        });
        await storage.createApiKey({
          name: "Stripe Secret Key",
          key: setupData.apiKeys.stripeKey,
          provider: "Stripe",
          isActive: true,
          ownerId: user.id,
          userId: user.id
        });
        process.env.VITE_STRIPE_PUBLIC_KEY = setupData.apiKeys.stripePublicKey;
        if (setupData.apiKeys.sendgridKey) {
          await storage.createApiKey({
            name: "SendGrid API Key",
            key: setupData.apiKeys.sendgridKey,
            provider: "Other",
            isActive: true,
            ownerId: user.id,
            userId: user.id
          });
        }
        if (setupData.userSettings.createDemoData) {
          try {
            const demoDataModule = await Promise.resolve().then(() => (init_create_demo_users(), create_demo_users_exports));
            const moduleAny = demoDataModule;
            if (typeof moduleAny.createDemoUsers === "function") {
              await moduleAny.createDemoUsers();
              console.log("Demo users created successfully");
            } else if (typeof moduleAny.createDemoAccounts === "function") {
              await moduleAny.createDemoAccounts();
              console.log("Demo accounts created successfully");
            } else {
              console.warn("No demo data creation function found in create-demo-users module");
            }
          } catch (demoError) {
            console.error("Error creating demo data:", demoError);
          }
        }
        try {
          await db.update(users).set({ company: setupData.companyInfo.name }).where(eq9(users.id, user.id));
          console.log(`Updated company information for user ID ${user.id}`);
        } catch (updateError) {
          console.error("Error updating company information:", updateError);
        }
        return res.status(200).json({
          success: true,
          message: "Setup completed successfully"
        });
      } catch (setupError) {
        console.error("Error during setup process:", setupError);
        return res.status(500).json({
          success: false,
          error: "Setup Error",
          message: "An error occurred during the setup process",
          details: setupError instanceof Error ? setupError.message : String(setupError)
        });
      }
    } catch (error) {
      console.error("Unexpected error in setup endpoint:", error);
      return res.status(500).json({
        success: false,
        error: "Server Error",
        message: "An unexpected error occurred",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/setup/status", async (req, res) => {
    try {
      const result = await pool.query(`
        SELECT setting_value 
        FROM system_settings 
        WHERE setting_key = 'setupStatus' 
        ORDER BY created_at DESC 
        LIMIT 1
      `);
      let setupComplete = false;
      if (result.rows.length > 0) {
        try {
          const settingValue = JSON.parse(result.rows[0].setting_value);
          setupComplete = settingValue?.complete || false;
        } catch (parseError) {
          console.error("Error parsing setup status:", parseError);
        }
      }
      return res.status(200).json({
        setupComplete,
        setupRequired: !setupComplete
      });
    } catch (error) {
      console.error("Error checking setup status:", error);
      return res.status(200).json({
        setupComplete: false,
        setupRequired: true,
        error: "Could not determine setup status"
      });
    }
  });
}

// server/ai-assistant.ts
init_db();
init_schema();
import OpenAI from "openai";
import { and as and5, eq as eq10, gte as gte2, lt as lt2, lte as lte2, desc as desc3 } from "drizzle-orm";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
async function generateBusinessInsights() {
  try {
    const recentLeads = await db.select().from(leads).where(
      and5(
        gte2(leads.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)),
        // Last 30 days
        eq10(leads.status, "Qualified")
      )
    ).limit(50);
    const staleOpportunities = await db.select().from(opportunities).where(
      and5(
        lte2(opportunities.updatedAt, new Date(Date.now() - 14 * 24 * 60 * 60 * 1e3)),
        // No updates in 14 days
        eq10(opportunities.stage, "Proposal")
      )
    ).orderBy(desc3(opportunities.amount)).limit(20);
    const highValueContacts = await db.select().from(contacts).orderBy(desc3(contacts.id)).limit(30);
    const upcomingEvents = await db.select().from(events).where(
      and5(
        gte2(events.startDate, /* @__PURE__ */ new Date()),
        lt2(events.startDate, new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3))
        // Next 7 days
      )
    ).limit(20);
    const overdueInvoices = await db.select().from(invoices).where(
      and5(
        eq10(invoices.status, "Overdue"),
        lt2(invoices.dueDate, /* @__PURE__ */ new Date())
      )
    ).orderBy(desc3(invoices.amount)).limit(10);
    const pendingTasks = await db.select().from(tasks).where(
      and5(
        lt2(tasks.dueDate, new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3)),
        // Due in next 3 days
        eq10(tasks.status, "In Progress")
      )
    ).limit(20);
    const businessData = {
      qualified_leads: recentLeads,
      stale_opportunities: staleOpportunities,
      high_value_contacts: highValueContacts,
      upcoming_events: upcomingEvents,
      overdue_invoices: overdueInvoices,
      pending_tasks: pendingTasks
    };
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are an AI business assistant for a CRM system. Your job is to analyze business data and provide actionable insights to help the business grow. 
          You should identify opportunities for follow-up, potential issues that need attention, and prioritize tasks based on their potential business impact.
          Focus on high-value customers, qualified leads, stale opportunities, upcoming events, overdue invoices, and pending tasks.
          
          Provide exactly 5 actionable insights with the following structure:
          1. type: The category of the insight (e.g., "lead_followup", "opportunity_stale", "invoice_overdue", "event_preparation", "contact_engagement")
          2. priority: Priority level ("high", "medium", "low") based on business impact
          3. title: A brief, action-oriented title (max 10 words)
          4. description: Detailed explanation of the insight (2-3 sentences)
          5. suggestedAction: Specific next step the user should take
          6. entityId: The ID of the relevant entity (if applicable)
          7. entityType: The type of entity (e.g., "lead", "opportunity", "contact", "invoice", "task", "event")
          8. metadata: Any additional relevant information
          
          The response should be in valid JSON format.`
        },
        {
          role: "user",
          content: JSON.stringify(businessData)
        }
      ],
      response_format: { type: "json_object" }
    });
    const insights = JSON.parse(response.choices[0].message.content);
    return insights.insights;
  } catch (error) {
    console.error("Error generating business insights:", error);
    return [
      {
        type: "error",
        priority: "medium",
        title: "Unable to generate insights",
        description: "There was an error analyzing your business data. Please try again later or contact support if the issue persists.",
        suggestedAction: "Refresh the page or try again later."
      }
    ];
  }
}
async function getPersonalizedAdvice(entityType, entityId) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      console.warn("OpenAI API key is missing. AI features cannot function without it.");
      return "AI advice is not available because the OpenAI API key is not configured. Please ask your administrator to set up the OPENAI_API_KEY.";
    }
    console.log(`Generating personalized advice for ${entityType} with ID ${entityId}`);
    let entityData = null;
    try {
      switch (entityType) {
        case "lead":
          const [lead] = await db.select().from(leads).where(eq10(leads.id, entityId));
          entityData = lead;
          break;
        case "opportunity":
          const [opportunity] = await db.select().from(opportunities).where(eq10(opportunities.id, entityId));
          entityData = opportunity;
          break;
        case "contact":
          const [contact] = await db.select().from(contacts).where(eq10(contacts.id, entityId));
          entityData = contact;
          break;
        case "task":
          const [task] = await db.select().from(tasks).where(eq10(tasks.id, entityId));
          entityData = task;
          break;
        case "event":
          const [event] = await db.select().from(events).where(eq10(events.id, entityId));
          entityData = event;
          break;
        default:
          return "Unable to provide advice for this entity type.";
      }
    } catch (dbError) {
      console.error(`Database error when fetching ${entityType}:`, dbError);
      return `Unable to retrieve ${entityType} data from the database. Please check your database connection.`;
    }
    if (!entityData) {
      console.warn(`No data found for ${entityType} with ID ${entityId}`);
      return `This ${entityType} was not found in the database. It may have been deleted or you might not have permission to view it.`;
    }
    let relatedActivities = [];
    try {
      relatedActivities = await db.select().from(activities).where(
        and5(
          eq10(activities.relatedToType, entityType),
          eq10(activities.relatedToId, entityId)
        )
      ).orderBy(desc3(activities.createdAt)).limit(10);
    } catch (activityError) {
      console.warn(`Error fetching activities for ${entityType} ${entityId}:`, activityError);
    }
    const entitySummary = {
      id: entityData.id,
      type: entityType,
      name: entityType === "lead" || entityType === "contact" ? `${entityData.firstName || ""} ${entityData.lastName || ""}`.trim() : entityData.name,
      company: entityData.company,
      status: entityData.status,
      source: entityData.source,
      createdAt: entityData.createdAt,
      notes: entityData.notes
    };
    const activitySummary = relatedActivities.map((activity) => ({
      action: activity.action,
      createdAt: activity.createdAt,
      detail: activity.detail
    }));
    console.log("Calling OpenAI API with model gpt-4o");
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: `You are an AI sales and customer relationship assistant. Based on the entity data and related activities, 
            provide personalized, actionable advice on how to best engage with this ${entityType}.
            
            Your advice should be:
            1. Specific to the entity's situation and history
            2. Strategic and action-oriented
            3. Focused on increasing the likelihood of conversion or strengthening the relationship
            4. About 3-5 sentences in length
            5. Professional but conversational in tone
            
            Do not include any placeholder text, generic advice, or statements that could apply to any entity. 
            Respond with the advice text only, no introductions or explanations.`
          },
          {
            role: "user",
            content: JSON.stringify({
              entitySummary,
              activitySummary,
              currentDate: (/* @__PURE__ */ new Date()).toISOString()
            })
          }
        ]
      });
      console.log("Successfully received response from OpenAI");
      return response.choices[0].message.content.trim();
    } catch (aiError) {
      console.error("OpenAI API error:", aiError);
      if (aiError.status === 429) {
        return "The AI advice service is currently at capacity. Please try again in a few minutes.";
      } else if (aiError.status === 401 || aiError.status === 403) {
        return "The AI advice service is unavailable due to an authentication issue. Please contact your administrator to check the OpenAI API key.";
      } else {
        return `Unable to generate AI advice at this time: ${aiError.message || "Unknown error"}. Please try again later.`;
      }
    }
  } catch (error) {
    console.error("Unexpected error in getPersonalizedAdvice:", error);
    return "An unexpected error occurred while generating AI advice. Please try again or contact support if the issue persists.";
  }
}

// server/manufacturing-routes-fixed.ts
init_db();
import { Router as Router3 } from "express";
import { sql as sql4 } from "drizzle-orm";

// server/manufacturing/bom-routes.ts
init_db();
import { Router as Router2 } from "express";
import { sql as sql3 } from "drizzle-orm";
var router = Router2();
router.get("/", async (req, res) => {
  try {
    console.log("Fetching all BOMs");
    const countCheck = await db.execute(sql3`SELECT COUNT(*) FROM bill_of_materials`);
    console.log("Found bill_of_materials records:", countCheck.rows?.[0]?.count || 0);
    const result = await db.execute(sql3`
      SELECT 
        b.id,
        b.product_id,
        p.name as product_name,
        p.sku as product_sku,
        b.version,
        b.name,
        b.description,
        b.is_active,
        b.created_at,
        b.created_by,
        u.username as created_by_name,
        b.approved_by,
        a.username as approved_by_name,
        b.approval_date as approved_at,
        b.manufacturing_type as industry_type,
        b.notes,
        (SELECT COUNT(*) FROM bom_items WHERE bom_id = b.id) as component_count
      FROM bill_of_materials b
      LEFT JOIN products p ON b.product_id = p.id
      LEFT JOIN users u ON b.created_by = u.id
      LEFT JOIN users a ON b.approved_by = a.id
      ORDER BY b.created_at DESC
    `);
    console.log("BOM query result:", result?.rows?.length || 0, "records found");
    if (!result.rows || result.rows.length === 0) {
      console.log("No records in bill_of_materials, checking boms table");
      const countCheckBoms = await db.execute(sql3`SELECT COUNT(*) FROM boms`);
      console.log("Found boms records:", countCheckBoms.rows?.[0]?.count || 0);
      if (countCheckBoms.rows?.[0]?.count > 0) {
        const bomsResult = await db.execute(sql3`
          SELECT 
            b.id,
            b.product_id,
            p.name as product_name,
            p.sku as product_sku,
            b.version,
            b.name,
            b.description,
            b.is_active,
            b.created_at,
            b.created_by,
            u.username as created_by_name,
            b.approved_by,
            a.username as approved_by_name,
            b.approved_at,
            b.industry_type,
            NULL as notes,
            0 as component_count
          FROM boms b
          LEFT JOIN products p ON b.product_id = p.id
          LEFT JOIN users u ON b.created_by = u.id
          LEFT JOIN users a ON b.approved_by = a.id
          ORDER BY b.created_at DESC
        `);
        console.log("Found", bomsResult?.rows?.length || 0, "records in boms table");
        return res.json(bomsResult.rows || []);
      }
    }
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching BOMs:", error);
    return res.status(500).json({ error: "Failed to fetch BOMs", details: error instanceof Error ? error.message : "Unknown error" });
  }
});
router.get("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const bomResult = await db.execute(sql3`
      SELECT 
        b.id,
        b.product_id,
        p.name as product_name,
        p.sku as product_sku,
        b.version,
        b.name,
        b.description,
        b.is_active,
        b.created_at,
        b.created_by,
        u.username as created_by_name,
        b.approved_by,
        a.username as approved_by_name,
        b.approval_date as approved_at,
        b.manufacturing_type as industry_type,
        b.yield as yield_percentage,
        b.total_cost,
        b.notes,
        b.revision_notes as revision
      FROM bill_of_materials b
      LEFT JOIN products p ON b.product_id = p.id
      LEFT JOIN users u ON b.created_by = u.id
      LEFT JOIN users a ON b.approved_by = a.id
      WHERE b.id = ${id}
    `);
    if (!bomResult.rows || bomResult.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const bomItemsResult = await db.execute(sql3`
      SELECT 
        bi.id,
        bi.component_id,
        p.name as component_name,
        p.sku as component_sku,
        bi.quantity,
        bi.unit_of_measure,
        bi.position,
        bi.is_optional,
        bi.is_sub_assembly,
        bi.scrap_rate,
        bi.operation,
        bi.notes,
        bi.work_center_id,
        w.name as work_center_name,
        p.price as unit_cost,
        (p.price * bi.quantity) as total_cost
      FROM bom_items bi
      LEFT JOIN products p ON bi.component_id = p.id
      LEFT JOIN work_centers w ON bi.work_center_id = w.id
      WHERE bi.bom_id = ${id}
      ORDER BY bi.position
    `);
    const bom = {
      ...bomResult.rows[0],
      items: bomItemsResult.rows || []
    };
    return res.json(bom);
  } catch (error) {
    console.error("Error fetching BOM:", error);
    return res.status(500).json({ error: "Failed to fetch BOM" });
  }
});
router.post("/", async (req, res) => {
  try {
    const {
      product_id,
      version = "1.0",
      name,
      description = "",
      is_active = true,
      manufacturing_type = "Discrete",
      notes = "",
      revision_notes = "",
      yield_percentage = 100,
      total_cost = 0
    } = req.body;
    if (!product_id) {
      return res.status(400).json({ error: "Product ID is required" });
    }
    if (!name) {
      return res.status(400).json({ error: "BOM name is required" });
    }
    const productCheck = await db.execute(sql3`
      SELECT id, name FROM products WHERE id = ${product_id}
    `);
    if (!productCheck.rows || productCheck.rows.length === 0) {
      return res.status(400).json({ error: "Product not found" });
    }
    const existingBomCheck = await db.execute(sql3`
      SELECT id FROM bill_of_materials WHERE product_id = ${product_id} AND version = ${version}
    `);
    if (existingBomCheck.rows && existingBomCheck.rows.length > 0) {
      return res.status(400).json({
        error: "A BOM with this product and version already exists",
        existingBomId: existingBomCheck.rows[0].id
      });
    }
    const result = await db.execute(sql3`
      INSERT INTO bill_of_materials (
        product_id,
        version,
        name,
        description,
        is_active,
        created_at,
        created_by,
        manufacturing_type,
        notes,
        revision_notes,
        yield,
        total_cost,
        is_default
      )
      VALUES (
        ${product_id},
        ${version},
        ${name},
        ${description},
        ${is_active},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${req.user?.id || 1},
        ${manufacturing_type},
        ${notes},
        ${revision_notes},
        ${yield_percentage},
        ${total_cost},
        ${false}
      )
      RETURNING id
    `);
    const bomId = result.rows?.[0]?.id;
    return res.status(201).json({
      id: bomId,
      product_id,
      version,
      name,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      created_by: req.user?.id || 1,
      message: "BOM created successfully"
    });
  } catch (error) {
    console.error("Error creating BOM:", error);
    return res.status(500).json({ error: "Failed to create BOM" });
  }
});
router.post("/:id/items", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      component_id,
      quantity = 1,
      unit_of_measure = "Each",
      position = 1,
      is_optional = false,
      is_sub_assembly = false,
      scrap_rate = 0,
      operation = null,
      notes = null,
      work_center_id = null
    } = req.body;
    if (!component_id) {
      return res.status(400).json({ error: "Component ID is required" });
    }
    const bomCheck = await db.execute(sql3`
      SELECT id, product_id FROM bill_of_materials WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const componentCheck = await db.execute(sql3`
      SELECT id, name FROM products WHERE id = ${component_id}
    `);
    if (!componentCheck.rows || componentCheck.rows.length === 0) {
      return res.status(400).json({ error: "Component product not found" });
    }
    if (bomCheck.rows[0].product_id === component_id) {
      return res.status(400).json({ error: "Cannot add the product itself as a component" });
    }
    let nextPosition = position;
    if (!position) {
      const positionResult = await db.execute(sql3`
        SELECT COALESCE(MAX(position), 0) + 1 as next_position
        FROM bom_items
        WHERE bom_id = ${id}
      `);
      nextPosition = positionResult.rows?.[0]?.next_position || 1;
    }
    const result = await db.execute(sql3`
      INSERT INTO bom_items (
        bom_id,
        component_id,
        quantity,
        unit_of_measure,
        position,
        is_optional,
        is_sub_assembly,
        scrap_rate,
        operation,
        notes,
        work_center_id
      )
      VALUES (
        ${id},
        ${component_id},
        ${quantity},
        ${unit_of_measure},
        ${nextPosition},
        ${is_optional},
        ${is_sub_assembly},
        ${scrap_rate},
        ${operation},
        ${notes},
        ${work_center_id}
      )
      RETURNING id
    `);
    const itemId = result.rows?.[0]?.id;
    const componentDetails = await db.execute(sql3`
      SELECT name, sku FROM products WHERE id = ${component_id}
    `);
    const componentName = componentDetails.rows?.[0]?.name || "";
    const componentSku = componentDetails.rows?.[0]?.sku || "";
    return res.status(201).json({
      id: itemId,
      bom_id: id,
      component_id,
      component_name: componentName,
      component_sku: componentSku,
      quantity,
      unit_of_measure,
      position: nextPosition,
      message: "BOM item added successfully"
    });
  } catch (error) {
    console.error("Error adding BOM item:", error);
    return res.status(500).json({ error: "Failed to add BOM item" });
  }
});
router.patch("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      description,
      is_active,
      manufacturing_type,
      notes,
      revision_notes,
      yield_percentage,
      total_cost,
      approved_by,
      approval_date
    } = req.body;
    const bomCheck = await db.execute(sql3`
      SELECT id FROM bill_of_materials WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const updateValues = [];
    const updateColumns = [];
    if (name !== void 0) {
      updateColumns.push("name");
      updateValues.push(name);
    }
    if (description !== void 0) {
      updateColumns.push("description");
      updateValues.push(description);
    }
    if (is_active !== void 0) {
      updateColumns.push("is_active");
      updateValues.push(is_active);
    }
    if (manufacturing_type !== void 0) {
      updateColumns.push("manufacturing_type");
      updateValues.push(manufacturing_type);
    }
    if (notes !== void 0) {
      updateColumns.push("notes");
      updateValues.push(notes);
    }
    if (revision_notes !== void 0) {
      updateColumns.push("revision_notes");
      updateValues.push(revision_notes);
    }
    if (yield_percentage !== void 0) {
      updateColumns.push("yield");
      updateValues.push(yield_percentage);
    }
    if (total_cost !== void 0) {
      updateColumns.push("total_cost");
      updateValues.push(total_cost);
    }
    if (approved_by !== void 0) {
      updateColumns.push("approved_by");
      updateValues.push(approved_by);
    }
    if (approval_date !== void 0) {
      updateColumns.push("approval_date");
      updateValues.push(approval_date);
    }
    if (updateColumns.length === 0) {
      return res.status(400).json({ error: "No fields provided for update" });
    }
    let updateQuery = sql3`UPDATE bill_of_materials SET `;
    for (let i = 0; i < updateColumns.length; i++) {
      const column = updateColumns[i];
      const value = updateValues[i];
      if (i > 0) {
        updateQuery = sql3`${updateQuery}, `;
      }
      updateQuery = sql3`${updateQuery}${sql3.identifier([column])} = ${value}`;
    }
    updateQuery = sql3`${updateQuery} WHERE id = ${id} RETURNING id, name, is_active, revision_notes`;
    const result = await db.execute(updateQuery);
    return res.json({
      ...result.rows[0],
      message: "BOM updated successfully"
    });
  } catch (error) {
    console.error("Error updating BOM:", error);
    return res.status(500).json({ error: "Failed to update BOM" });
  }
});
router.delete("/:bomId/items/:itemId", async (req, res) => {
  try {
    const { bomId, itemId } = req.params;
    const bomCheck = await db.execute(sql3`
      SELECT id FROM bill_of_materials WHERE id = ${bomId}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const itemCheck = await db.execute(sql3`
      SELECT id FROM bom_items WHERE id = ${itemId} AND bom_id = ${bomId}
    `);
    if (!itemCheck.rows || itemCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM item not found" });
    }
    await db.execute(sql3`
      DELETE FROM bom_items WHERE id = ${itemId}
    `);
    return res.json({
      id: itemId,
      bom_id: bomId,
      message: "BOM item deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting BOM item:", error);
    return res.status(500).json({ error: "Failed to delete BOM item" });
  }
});
router.post("/:id/copy", async (req, res) => {
  try {
    const { id } = req.params;
    const { new_version, new_name } = req.body;
    if (!new_version) {
      return res.status(400).json({ error: "New version is required" });
    }
    const bomCheck = await db.execute(sql3`
      SELECT product_id, name, description, manufacturing_type FROM bill_of_materials WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "Source BOM not found" });
    }
    const sourceBom = bomCheck.rows[0];
    const versionCheck = await db.execute(sql3`
      SELECT id FROM bill_of_materials WHERE product_id = ${sourceBom.product_id} AND version = ${new_version}
    `);
    if (versionCheck.rows && versionCheck.rows.length > 0) {
      return res.status(400).json({
        error: "A BOM with this product and version already exists",
        existingBomId: versionCheck.rows[0].id
      });
    }
    await db.execute(sql3`BEGIN`);
    try {
      const newBomResult = await db.execute(sql3`
        INSERT INTO bill_of_materials (
          product_id,
          version,
          name,
          description,
          is_active,
          created_at,
          created_by,
          revision_notes,
          manufacturing_type
        )
        VALUES (
          ${sourceBom.product_id},
          ${new_version},
          ${new_name || `${sourceBom.name} (${new_version})`},
          ${sourceBom.description},
          true,
          ${(/* @__PURE__ */ new Date()).toISOString()},
          ${req.user?.id || 1},
          ${`Copied from version ${id}`},
          ${sourceBom.manufacturing_type}
        )
        RETURNING id
      `);
      const newBomId = newBomResult.rows?.[0]?.id;
      await db.execute(sql3`
        INSERT INTO bom_items (
          bom_id,
          component_id,
          quantity,
          unit_of_measure,
          position,
          is_optional,
          is_sub_assembly,
          scrap_rate,
          operation,
          notes,
          work_center_id
        )
        SELECT 
          ${newBomId},
          component_id,
          quantity,
          unit_of_measure,
          position,
          is_optional,
          is_sub_assembly,
          scrap_rate,
          operation,
          notes,
          work_center_id
        FROM bom_items
        WHERE bom_id = ${id}
      `);
      await db.execute(sql3`COMMIT`);
      return res.status(201).json({
        id: newBomId,
        product_id: sourceBom.product_id,
        version: new_version,
        name: new_name || `${sourceBom.name} (${new_version})`,
        copied_from: id,
        message: "BOM copied successfully"
      });
    } catch (error) {
      await db.execute(sql3`ROLLBACK`);
      throw error;
    }
  } catch (error) {
    console.error("Error copying BOM:", error);
    return res.status(500).json({ error: "Failed to copy BOM" });
  }
});
var bom_routes_default = router;

// server/manufacturing-routes-fixed.ts
var router2 = Router3();
router2.use("/boms", bom_routes_default);
router2.post("/mrp/run", async (req, res) => {
  try {
    const {
      planningHorizon = 30,
      considerSafetyStock = true,
      considerLeadTimes = true,
      considerCapacityConstraints = false,
      warehouseId = 1
    } = req.body;
    const result = await db.execute(sql4`
      INSERT INTO mrp_runs (
        run_name, 
        planning_horizon_start, 
        planning_horizon_end,
        status,
        created_by,
        parameters,
        consider_safety_stock,
        consider_lead_times,
        consider_capacity_constraints,
        warehouse_id
      ) 
      VALUES (
        ${"MRP Run " + (/* @__PURE__ */ new Date()).toISOString()},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${new Date(Date.now() + planningHorizon * 24 * 60 * 60 * 1e3).toISOString()},
        ${"InProgress"},
        ${req.user?.id || 1},
        ${JSON.stringify({
      planningHorizon,
      considerSafetyStock,
      considerLeadTimes,
      considerCapacityConstraints,
      warehouseId
    })},
        ${considerSafetyStock},
        ${considerLeadTimes},
        ${considerCapacityConstraints},
        ${warehouseId}
      )
      RETURNING id
    `);
    const runId = result.rows?.[0]?.id || 0;
    return res.json({
      success: true,
      message: "MRP run started successfully",
      runId
    });
  } catch (error) {
    console.error("Error starting MRP run:", error);
    return res.status(500).json({
      success: false,
      error: "Failed to start MRP run"
    });
  }
});
router2.get("/mrp/runs", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        id,
        run_name as "runName",
        created_at as "createdAt",
        planning_horizon_start as "startDate",
        planning_horizon_end as "endDate",
        status,
        created_by as "createdBy",
        completion_time as "completedAt"
      FROM mrp_runs
      ORDER BY created_at DESC
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching MRP runs:", error);
    return res.status(500).json({ error: "Failed to fetch MRP runs" });
  }
});
router2.get("/mrp/runs/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute(sql4`
      SELECT 
        id,
        run_name as "runName",
        created_at as "createdAt",
        planning_horizon_start as "startDate",
        planning_horizon_end as "endDate",
        status,
        created_by as "createdBy",
        completion_time as "completedAt",
        parameters,
        consider_safety_stock as "considerSafetyStock",
        consider_lead_times as "considerLeadTimes",
        consider_capacity_constraints as "considerCapacityConstraints",
        consider_current_inventory as "considerCurrentInventory",
        consider_batch_sizes as "considerBatchSizes"
      FROM mrp_runs
      WHERE id = ${id}
    `);
    if (!result.rows || result.rows.length === 0) {
      return res.status(404).json({ error: "MRP run not found" });
    }
    return res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching MRP run details:", error);
    return res.status(500).json({ error: "Failed to fetch MRP run details" });
  }
});
router2.post("/inventory/report", async (req, res) => {
  try {
    const { reportType, format = "pdf" } = req.body;
    const reportContent = `
Averox Business AI - Inventory Status Report
Generated on: ${(/* @__PURE__ */ new Date()).toLocaleString()}
Report Type: ${reportType}
Format: ${format}

This is a placeholder for a real inventory report that would be generated 
from the database and formatted as a proper ${format.toUpperCase()} document.

The real implementation would include:
- Current inventory levels
- Inventory valuation by method (FIFO, LIFO, Average, etc.)
- Stock alerts (low stock, overstock)
- Inventory aging analysis
- Inventory turnover metrics

Report generated by Averox Business AI Manufacturing Module
    `;
    res.setHeader(
      "Content-Type",
      format === "pdf" ? "application/pdf" : format === "csv" ? "text/csv" : "text/plain"
    );
    res.setHeader("Content-Disposition", `attachment; filename=inventory-report.${format}`);
    return res.send(Buffer.from(reportContent));
  } catch (error) {
    console.error("Error generating inventory report:", error);
    return res.status(500).json({ error: "Failed to generate inventory report" });
  }
});
router2.get("/forecasts", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        id,
        external_reference as name,
        notes as description,
        forecast_period as period,
        confidence_level as confidence,
        start_date as "startDate",
        end_date as "endDate",
        CASE WHEN is_approved THEN 'Approved' ELSE 'Active' END as status,
        created_at as "createdAt",
        created_by as "createdBy",
        product_id as "productId",
        quantity
      FROM material_forecasts
      ORDER BY created_at DESC
      LIMIT 20
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching forecasts:", error);
    return res.status(500).json({ error: "Failed to fetch forecasts" });
  }
});
router2.get("/products", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        id, 
        name, 
        sku, 
        description, 
        price,
        category_id,
        stock_quantity
      FROM products 
      ORDER BY name ASC
    `);
    return res.status(200).json(result.rows);
  } catch (error) {
    console.error("Error fetching products:", error);
    return res.status(500).json({ error: "Failed to fetch products" });
  }
});
router2.get("/forecasts/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute(sql4`
      SELECT 
        mf.id,
        mf.external_reference as name,
        mf.notes as description,
        mf.forecast_period as period,
        mf.confidence_level as confidence,
        mf.start_date as "startDate",
        mf.end_date as "endDate",
        CASE WHEN mf.is_approved THEN 'Approved' ELSE 'Active' END as status,
        mf.created_at as "createdAt",
        mf.created_by as "createdBy",
        mf.product_id as "productId",
        mf.quantity,
        mf.unit_of_measure as "unitOfMeasure",
        p.name as "productName",
        p.sku as "productSku",
        u.username as "createdByUsername"
      FROM material_forecasts mf
      LEFT JOIN products p ON mf.product_id = p.id
      LEFT JOIN users u ON mf.created_by = u.id
      WHERE mf.id = ${id}
    `);
    if (!result.rows || result.rows.length === 0) {
      return res.status(404).json({ error: "Forecast not found" });
    }
    return res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching forecast details:", error);
    return res.status(500).json({ error: "Failed to fetch forecast details" });
  }
});
router2.post("/forecasts", async (req, res) => {
  try {
    const {
      name,
      description = "",
      startDate,
      endDate,
      items = []
    } = req.body;
    if (items.length === 0) {
      return res.status(400).json({ error: "At least one product item is required" });
    }
    const firstItem = items[0];
    const startDateObj = new Date(startDate);
    const endDateObj = new Date(endDate);
    const monthsDiff = (endDateObj.getFullYear() - startDateObj.getFullYear()) * 12 + (endDateObj.getMonth() - startDateObj.getMonth());
    let forecastPeriod = "Monthly";
    if (monthsDiff >= 3 && monthsDiff < 12) {
      forecastPeriod = "Quarterly";
    } else if (monthsDiff >= 12) {
      forecastPeriod = "Yearly";
    }
    const result = await db.execute(sql4`
      INSERT INTO material_forecasts (
        product_id,
        forecast_period,
        quantity,
        unit_of_measure,
        warehouse_id,
        external_reference,
        notes,
        start_date,
        end_date,
        is_approved,
        created_by,
        created_at,
        forecast_type,
        source,
        confidence_level
      )
      VALUES (
        ${firstItem.productId},
        ${forecastPeriod},
        ${firstItem.quantity},
        ${"Each"}, -- Default UOM, could be parameterized
        ${1}, -- Using the warehouse we found in the database
        ${name},
        ${description},
        ${startDate},
        ${endDate},
        ${false},
        ${req.user?.id || 1},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${"Planning"},
        ${"Manual"},
        ${0.8}
      )
      RETURNING id
    `);
    const forecastId = result.rows?.[0]?.id;
    if (items.length > 1) {
      console.log(`Note: ${items.length - 1} additional forecast items couldn't be saved as separate records due to schema limitations`);
    }
    return res.status(201).json({
      id: forecastId,
      name,
      description,
      startDate,
      endDate,
      status: "Active",
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      createdBy: req.user?.id || 1,
      product: firstItem.productId,
      quantity: firstItem.quantity,
      items: items.length
    });
  } catch (error) {
    console.error("Error creating forecast:", error);
    return res.status(500).json({ error: "Failed to create forecast" });
  }
});
router2.get("/inventory/transactions", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        it.id,
        it.product_id,
        p.name as product_name,
        p.sku as product_sku,
        it.quantity,
        it.type,
        it.reference_id,
        it.reference_type,
        it.unit_cost,
        it.created_at,
        it.created_by,
        u.username as created_by_name,
        it.notes,
        it.location,
        it.batch_id,
        it.expiry_date
      FROM inventory_transactions it
      LEFT JOIN products p ON it.product_id = p.id
      LEFT JOIN users u ON it.created_by = u.id
      ORDER BY it.created_at DESC
      LIMIT 100
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching inventory transactions:", error);
    return res.status(500).json({ error: "Failed to fetch inventory transactions" });
  }
});
router2.post("/inventory/transactions", async (req, res) => {
  try {
    const {
      product_id,
      quantity = 0,
      type = "Purchase",
      // Default type
      reference_id = null,
      reference_type = null,
      unit_cost = null,
      expiry_date = null,
      batch_id = null,
      notes = "",
      location = null
    } = req.body;
    if (!product_id) {
      return res.status(400).json({ error: "Product ID is required" });
    }
    if (quantity === 0) {
      return res.status(400).json({ error: "Quantity cannot be zero" });
    }
    const validTypes = ["Purchase", "Sale", "Adjustment", "Return", "Transfer", "Production", "Consumption", "QualityReject", "ScrapDisposal", "IntakeForProduction", "ProductionOutput"];
    if (!validTypes.includes(type)) {
      return res.status(400).json({
        error: "Invalid transaction type",
        validValues: validTypes
      });
    }
    const result = await db.execute(sql4`
      INSERT INTO inventory_transactions (
        product_id,
        quantity,
        type,
        reference_id,
        reference_type,
        unit_cost,
        created_at,
        created_by,
        expiry_date,
        batch_id,
        notes,
        location
      )
      VALUES (
        ${product_id},
        ${quantity},
        ${type},
        ${reference_id},
        ${reference_type},
        ${unit_cost},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${req.user?.id || 1},
        ${expiry_date},
        ${batch_id},
        ${notes},
        ${location}
      )
      RETURNING id
    `);
    const transactionId = result.rows?.[0]?.id;
    return res.status(201).json({
      id: transactionId,
      product_id,
      quantity,
      type,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      message: "Inventory transaction recorded successfully"
    });
  } catch (error) {
    console.error("Error creating inventory transaction:", error);
    return res.status(500).json({ error: "Failed to record inventory transaction" });
  }
});
router2.get("/inventory/levels", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      WITH inventory_sums AS (
        SELECT 
          product_id,
          SUM(CASE WHEN type IN ('Purchase', 'Return', 'Adjustment', 'Transfer', 'Production', 'ProductionOutput') THEN quantity ELSE 0 END) AS inflows,
          SUM(CASE WHEN type IN ('Sale', 'Consumption', 'QualityReject', 'ScrapDisposal', 'IntakeForProduction') THEN quantity ELSE 0 END) AS outflows
        FROM inventory_transactions
        GROUP BY product_id
      )
      SELECT 
        p.id,
        p.name,
        p.sku,
        p.description,
        COALESCE(is_sums.inflows, 0) - COALESCE(is_sums.outflows, 0) as current_quantity,
        p.reorder_level,
        CASE 
          WHEN (COALESCE(is_sums.inflows, 0) - COALESCE(is_sums.outflows, 0)) <= p.reorder_level THEN true 
          ELSE false 
        END as needs_reorder,
        p.price as unit_cost
      FROM products p
      LEFT JOIN inventory_sums is_sums ON p.id = is_sums.product_id
      ORDER BY p.name
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching inventory levels:", error);
    return res.status(500).json({ error: "Failed to fetch inventory levels" });
  }
});
router2.get("/inventory/valuation", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      WITH inventory_sums AS (
        SELECT 
          product_id,
          SUM(CASE WHEN type IN ('Purchase', 'Return', 'Adjustment', 'Transfer', 'Production', 'ProductionOutput') THEN quantity ELSE 0 END) AS inflows,
          SUM(CASE WHEN type IN ('Sale', 'Consumption', 'QualityReject', 'ScrapDisposal', 'IntakeForProduction') THEN quantity ELSE 0 END) AS outflows,
          AVG(unit_cost) as avg_unit_cost
        FROM inventory_transactions
        WHERE unit_cost IS NOT NULL
        GROUP BY product_id
      )
      SELECT 
        p.id,
        p.name,
        p.sku,
        COALESCE(is_sums.inflows, 0) - COALESCE(is_sums.outflows, 0) as current_quantity,
        COALESCE(is_sums.avg_unit_cost, p.price) as unit_cost,
        (COALESCE(is_sums.inflows, 0) - COALESCE(is_sums.outflows, 0)) * COALESCE(is_sums.avg_unit_cost, p.price) as total_value
      FROM products p
      LEFT JOIN inventory_sums is_sums ON p.id = is_sums.product_id
      WHERE (COALESCE(is_sums.inflows, 0) - COALESCE(is_sums.outflows, 0)) > 0
      ORDER BY total_value DESC
    `);
    let totalInventoryValue = 0;
    if (result.rows && result.rows.length > 0) {
      totalInventoryValue = result.rows.reduce((sum, item) => sum + Number(item.total_value || 0), 0);
    }
    return res.json({
      items: result.rows || [],
      totalValue: totalInventoryValue,
      valuationDate: (/* @__PURE__ */ new Date()).toISOString(),
      valuationMethod: "Average Cost"
    });
  } catch (error) {
    console.error("Error calculating inventory valuation:", error);
    return res.status(500).json({ error: "Failed to calculate inventory valuation" });
  }
});
router2.get("/production-orders", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        po.id,
        po.order_number,
        po.product_id,
        p.name as product_name,
        p.sku as product_sku,
        po.quantity,
        po.unit_of_measure,
        po.status,
        po.priority,
        po.planned_start_date,
        po.planned_end_date,
        po.actual_start_date,
        po.actual_end_date,
        po.batch_number,
        po.notes,
        po.completed_quantity,
        po.rejected_quantity,
        po.created_at,
        po.created_by,
        u.username as created_by_name,
        po.warehouse_id,
        po.bom_id,
        po.routing_id,
        po.industry_type
      FROM production_orders po
      LEFT JOIN products p ON po.product_id = p.id
      LEFT JOIN users u ON po.created_by = u.id
      ORDER BY po.created_at DESC
      LIMIT 100
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching production orders:", error);
    return res.status(500).json({ error: "Failed to fetch production orders" });
  }
});
router2.get("/production-orders/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute(sql4`
      SELECT 
        po.id,
        po.order_number,
        po.product_id,
        p.name as product_name,
        p.sku as product_sku,
        po.quantity,
        po.unit_of_measure,
        po.status,
        po.priority,
        po.planned_start_date,
        po.planned_end_date,
        po.actual_start_date,
        po.actual_end_date,
        po.batch_number,
        po.notes,
        po.completed_quantity,
        po.rejected_quantity,
        po.created_at,
        po.created_by,
        u.username as created_by_name,
        po.warehouse_id,
        w.name as warehouse_name,
        po.bom_id,
        po.routing_id,
        po.industry_type,
        r.name as routing_name
      FROM production_orders po
      LEFT JOIN products p ON po.product_id = p.id
      LEFT JOIN users u ON po.created_by = u.id
      LEFT JOIN warehouses w ON po.warehouse_id = w.id
      LEFT JOIN routings r ON po.routing_id = r.id
      WHERE po.id = ${id}
    `);
    if (!result.rows || result.rows.length === 0) {
      return res.status(404).json({ error: "Production order not found" });
    }
    let bomItems2 = [];
    if (result.rows[0].bom_id) {
      const bomResult = await db.execute(sql4`
        SELECT 
          bi.id,
          bi.component_id,
          p.name as component_name,
          p.sku as component_sku,
          bi.quantity,
          bi.unit_of_measure,
          bi.scrap_rate,
          bi.is_optional,
          bi.operation,
          bi.notes
        FROM bom_items bi
        LEFT JOIN products p ON bi.component_id = p.id
        WHERE bi.bom_id = ${result.rows[0].bom_id}
        ORDER BY bi.position
      `);
      bomItems2 = bomResult.rows || [];
    }
    return res.json({
      ...result.rows[0],
      bomItems: bomItems2
    });
  } catch (error) {
    console.error("Error fetching production order details:", error);
    return res.status(500).json({ error: "Failed to fetch production order details" });
  }
});
router2.post("/production-orders", async (req, res) => {
  try {
    const {
      product_id,
      quantity = 0,
      unit_of_measure = "Each",
      planned_start_date,
      planned_end_date,
      status = "Draft",
      priority = "Medium",
      warehouse_id = 1,
      bom_id = null,
      routing_id = null,
      batch_number = null,
      notes = "",
      industry_type = "Manufacturing"
    } = req.body;
    if (!product_id) {
      return res.status(400).json({ error: "Product ID is required" });
    }
    if (quantity <= 0) {
      return res.status(400).json({ error: "Quantity must be greater than zero" });
    }
    const year = (/* @__PURE__ */ new Date()).getFullYear();
    const orderNumberResult = await db.execute(sql4`
      SELECT order_number
      FROM production_orders
      WHERE order_number LIKE ${"PO-" + year + "-%"}
      ORDER BY order_number DESC
      LIMIT 1
    `);
    let nextOrderNumber;
    if (orderNumberResult.rows && orderNumberResult.rows.length > 0) {
      const lastOrderNumber = orderNumberResult.rows[0].order_number;
      const lastOrderSequence = parseInt(lastOrderNumber.split("-")[2], 10);
      nextOrderNumber = "PO-" + year + "-" + String(lastOrderSequence + 1).padStart(4, "0");
    } else {
      nextOrderNumber = "PO-" + year + "-0001";
    }
    const result = await db.execute(sql4`
      INSERT INTO production_orders (
        order_number,
        product_id,
        quantity,
        unit_of_measure,
        status,
        priority,
        planned_start_date,
        planned_end_date,
        created_at,
        created_by,
        warehouse_id,
        bom_id,
        routing_id,
        batch_number,
        notes,
        industry_type,
        completed_quantity,
        rejected_quantity
      )
      VALUES (
        ${nextOrderNumber},
        ${product_id},
        ${quantity},
        ${unit_of_measure},
        ${status},
        ${priority},
        ${planned_start_date},
        ${planned_end_date},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${req.user?.id || 1},
        ${warehouse_id},
        ${bom_id},
        ${routing_id},
        ${batch_number},
        ${notes},
        ${industry_type},
        ${0},
        ${0}
      )
      RETURNING id
    `);
    const productionOrderId = result.rows?.[0]?.id;
    return res.status(201).json({
      id: productionOrderId,
      order_number: nextOrderNumber,
      product_id,
      quantity,
      status,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      message: "Production order created successfully"
    });
  } catch (error) {
    console.error("Error creating production order:", error);
    return res.status(500).json({ error: "Failed to create production order" });
  }
});
router2.patch("/production-orders/:id/status", async (req, res) => {
  try {
    const { id } = req.params;
    const { status, completed_quantity = null, rejected_quantity = null, actual_start_date = null, actual_end_date = null } = req.body;
    const validStatuses = ["Draft", "Scheduled", "InProgress", "Completed", "OnHold", "Cancelled"];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: "Invalid status value",
        validValues: validStatuses
      });
    }
    const orderQuery = await db.execute(sql4`
      SELECT po.*, p.name as product_name, p.sku as product_sku
      FROM production_orders po
      LEFT JOIN products p ON po.product_id = p.id
      WHERE po.id = ${id}
    `);
    if (!orderQuery.rows || orderQuery.rows.length === 0) {
      return res.status(404).json({ error: "Production order not found" });
    }
    const productionOrder = orderQuery.rows[0];
    const previousStatus = productionOrder.status;
    const completedQuantity = completed_quantity || productionOrder.quantity || 0;
    let updateFields = sql4`status = ${status}`;
    if (completed_quantity !== null) {
      updateFields = sql4`${updateFields}, completed_quantity = ${completed_quantity}`;
    }
    if (rejected_quantity !== null) {
      updateFields = sql4`${updateFields}, rejected_quantity = ${rejected_quantity}`;
    }
    if (status === "InProgress" && actual_start_date === null) {
      updateFields = sql4`${updateFields}, actual_start_date = ${(/* @__PURE__ */ new Date()).toISOString()}`;
    }
    if (status === "Completed" && actual_end_date === null) {
      updateFields = sql4`${updateFields}, actual_end_date = ${(/* @__PURE__ */ new Date()).toISOString()}`;
    }
    if (actual_start_date !== null) {
      updateFields = sql4`${updateFields}, actual_start_date = ${actual_start_date}`;
    }
    if (actual_end_date !== null) {
      updateFields = sql4`${updateFields}, actual_end_date = ${actual_end_date}`;
    }
    let inventoryUpdated = false;
    if (status === "Completed" && previousStatus !== "Completed") {
      try {
        await db.execute(sql4`BEGIN`);
        await db.execute(sql4`
          INSERT INTO inventory_transactions (
            product_id,
            quantity,
            type,
            reference_id,
            reference_type,
            unit_cost,
            created_at,
            created_by,
            notes,
            location
          )
          VALUES (
            ${productionOrder.product_id},
            ${completedQuantity},
            'ProductionOutput',
            ${id},
            'production_order',
            ${productionOrder.unit_cost || null},
            ${(/* @__PURE__ */ new Date()).toISOString()},
            ${req.user?.id || 1},
            ${`Produced in production order #${id} (${productionOrder.order_number})`},
            ${productionOrder.location || productionOrder.warehouse_id || null}
          )
        `);
        const bomResult = await db.execute(sql4`
          SELECT bi.*, p.name as component_name, p.sku as component_sku
          FROM bom_items bi
          JOIN products p ON bi.component_id = p.id
          WHERE bi.bom_id = ${productionOrder.bom_id || 0}
        `);
        const bomItems2 = bomResult.rows || [];
        for (const item of bomItems2) {
          const requiredQuantity = parseFloat(item.quantity || 0) * completedQuantity;
          await db.execute(sql4`
            INSERT INTO inventory_transactions (
              product_id,
              quantity,
              type,
              reference_id,
              reference_type,
              created_at,
              created_by,
              notes,
              location
            )
            VALUES (
              ${item.component_id},
              ${requiredQuantity},
              'IntakeForProduction',
              ${id},
              'production_order',
              ${(/* @__PURE__ */ new Date()).toISOString()},
              ${req.user?.id || 1},
              ${`Used in production order #${id} (${productionOrder.order_number}) for ${productionOrder.product_name}`},
              ${productionOrder.location || productionOrder.warehouse_id || null}
            )
          `);
        }
        await db.execute(sql4`COMMIT`);
        inventoryUpdated = true;
      } catch (error) {
        await db.execute(sql4`ROLLBACK`);
        console.error("Error updating inventory for production completion:", error);
        return res.status(500).json({
          error: "Failed to update inventory for production completion. Transaction rolled back."
        });
      }
    }
    const result = await db.execute(sql4`
      UPDATE production_orders
      SET ${updateFields}
      WHERE id = ${id}
      RETURNING id, order_number, status, completed_quantity, rejected_quantity, actual_start_date, actual_end_date
    `);
    if (!result.rows || result.rows.length === 0) {
      return res.status(404).json({ error: "Production order not found" });
    }
    let message = "Production order status updated successfully";
    if (inventoryUpdated) {
      message += ". Inventory has been updated automatically.";
    }
    return res.json({
      ...result.rows[0],
      message
    });
  } catch (error) {
    console.error("Error updating production order status:", error);
    return res.status(500).json({ error: "Failed to update production order status" });
  }
});
router2.get("/mrp/dashboard", async (req, res) => {
  try {
    let lowStockItems = [];
    let upcomingRequirements = [];
    let forecasts = [];
    try {
      const result = await db.execute(sql4`
        SELECT 
          p.id as material_id,
          p.name as material_name,
          p.sku as material_code,
          p.reorder_level as reorder_point,
          p.stock_quantity as current_quantity
        FROM products p
        ORDER BY p.id
        LIMIT 10
      `);
      lowStockItems = (result.rows || []).map((row) => ({
        id: Number(row.material_id),
        material_id: Number(row.material_id),
        material_name: String(row.material_name || ""),
        material_code: row.material_code ? String(row.material_code) : void 0,
        current_stock: Number(row.current_quantity || 0),
        minimum_stock: 0,
        // Default value
        reorder_level: Number(row.reorder_point || 0),
        unit_of_measure: "Each",
        // Default value
        category: "Material",
        // Default value
        supplier_name: "Default Supplier"
        // Default value
      }));
    } catch (lowStockError) {
      console.error("Error fetching low stock items:", lowStockError);
    }
    try {
      upcomingRequirements = [];
    } catch (error) {
      console.error("Error fetching material requirements:", error);
    }
    try {
      console.log("Fetching material forecasts...");
      const result = await db.execute(sql4`
        SELECT 
          id,
          external_reference as name,
          notes as description,
          forecast_period as period,
          confidence_level as confidence,
          start_date as "startDate",
          end_date as "endDate",
          CASE WHEN is_approved THEN 'Approved' ELSE 'Active' END as status,
          created_at as "createdAt",
          created_by as "createdBy"
        FROM material_forecasts
        ORDER BY created_at DESC
        LIMIT 5
      `);
      console.log("Forecast result rows:", JSON.stringify(result.rows || []));
      forecasts = (result.rows || []).map((row) => ({
        id: Number(row.id || 0),
        name: String(row.name || ""),
        period: String(row.period || "Monthly"),
        created_date: String(row.createdAt || (/* @__PURE__ */ new Date()).toISOString()),
        confidence: Number(row.confidence || 0),
        values: [],
        // No values column in our schema
        status: String(row.status || "Active"),
        createdAt: String(row.createdAt || (/* @__PURE__ */ new Date()).toISOString()),
        createdBy: Number(row.createdBy || 1)
      }));
      console.log("Mapped forecasts:", JSON.stringify(forecasts));
    } catch (error) {
      console.error("Error fetching forecasts:", error);
    }
    return res.json({
      lowStockItems,
      upcomingRequirements,
      forecasts
    });
  } catch (error) {
    console.error("Error fetching MRP dashboard data:", error);
    return res.status(500).json({
      lowStockItems: [],
      upcomingRequirements: [],
      forecasts: []
    });
  }
});
router2.post("/warehouse/bins/add", async (req, res) => {
  try {
    const {
      bin_code,
      warehouse_id,
      zone_id,
      aisle,
      rack,
      level,
      position,
      capacity,
      bin_type,
      max_weight,
      height,
      width,
      depth,
      is_mixing_allowed,
      special_handling_notes
    } = req.body;
    if (!bin_code || !warehouse_id) {
      return res.status(400).json({ error: "Bin code and warehouse ID are required" });
    }
    const available_capacity = capacity;
    const result = await db.execute(sql4`
      INSERT INTO storage_bins (
        bin_code, 
        warehouse_id, 
        zone_id,
        aisle, 
        rack, 
        level, 
        position, 
        capacity, 
        available_capacity,
        bin_type, 
        max_weight, 
        height, 
        width, 
        depth,
        is_mixing_allowed,
        special_handling_notes,
        is_active,
        created_at
      )
      VALUES (
        ${bin_code}, 
        ${warehouse_id}, 
        ${zone_id || null},
        ${aisle || null}, 
        ${rack || null}, 
        ${level || null}, 
        ${position || null}, 
        ${capacity || 0}, 
        ${available_capacity || 0},
        ${bin_type || "Standard"},
        ${max_weight || null}, 
        ${height || null}, 
        ${width || null}, 
        ${depth || null},
        ${is_mixing_allowed || false},
        ${special_handling_notes || null},
        true,
        NOW()
      )
      RETURNING id, bin_code, warehouse_id
    `);
    const newBin = result.rows[0];
    res.status(201).json({
      success: true,
      message: "Storage bin created successfully",
      bin: newBin
    });
  } catch (error) {
    console.error("Error creating storage bin:", error);
    res.status(500).json({ error: "Failed to create storage bin" });
  }
});
router2.get("/warehouse/bins", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      WITH bin_utilization AS (
        SELECT 
          sb.id, 
          sb.bin_code as code,
          sb.capacity as total_capacity,
          COALESCE(sb.available_capacity, 0) as available_capacity,
          (sb.capacity - COALESCE(sb.available_capacity, 0)) as used_capacity
        FROM storage_bins sb
        WHERE sb.is_active = true
      )
      SELECT 
        sb.id,
        sb.bin_code as code,
        sb.aisle || '-' || sb.rack || '-' || sb.level || '-' || sb.position as name,
        w.name as parent_name,
        sb.bin_type as type,
        sb.capacity,
        sb.available_capacity,
        sb.is_active as "isActive",
        sb.max_weight,
        sb.current_weight,
        sb.height,
        sb.width,
        sb.depth,
        CASE 
          WHEN bu.total_capacity > 0 THEN 
            ROUND(((bu.total_capacity - bu.available_capacity) / bu.total_capacity) * 100)
          ELSE 0
        END as utilization_percentage
      FROM storage_bins sb
      JOIN bin_utilization bu ON sb.id = bu.id
      LEFT JOIN warehouses w ON sb.warehouse_id = w.id
      ORDER BY sb.bin_code
    `);
    const bins = result.rows || [];
    return res.json(bins);
  } catch (error) {
    console.error("Error fetching storage bins:", error);
    return res.status(500).json({ error: "Failed to fetch storage bins" });
  }
});
router2.get("/storage-bins", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      WITH bin_utilization AS (
        SELECT 
          sb.id, 
          sb.bin_code as code,
          sb.capacity as total_capacity,
          COALESCE(sb.available_capacity, 0) as available_capacity,
          (sb.capacity - COALESCE(sb.available_capacity, 0)) as used_capacity
        FROM storage_bins sb
        WHERE sb.is_active = true
      )
      SELECT 
        sb.id,
        sb.bin_code as code,
        sb.aisle || '-' || sb.rack || '-' || sb.level || '-' || sb.position as name,
        w.name as parent_name,
        sb.bin_type as type,
        sb.capacity,
        sb.available_capacity,
        sb.is_active as "isActive",
        sb.max_weight,
        sb.current_weight,
        sb.height,
        sb.width,
        sb.depth,
        CASE 
          WHEN bu.total_capacity > 0 THEN 
            ROUND(((bu.total_capacity - bu.available_capacity) / bu.total_capacity) * 100)
          ELSE 0
        END as utilization_percentage
      FROM storage_bins sb
      JOIN bin_utilization bu ON sb.id = bu.id
      LEFT JOIN warehouses w ON sb.warehouse_id = w.id
      ORDER BY sb.bin_code
    `);
    const bins = result.rows || [];
    return res.json(bins);
  } catch (error) {
    console.error("Error fetching storage bins:", error);
    return res.status(500).json({ error: "Failed to fetch storage bins" });
  }
});
router2.post("/warehouse/zones/add", async (req, res) => {
  try {
    const {
      name,
      code,
      description,
      warehouse_id,
      zone_type,
      capacity,
      is_active
    } = req.body;
    if (!name || !code || !warehouse_id) {
      return res.status(400).json({ error: "Zone name, code, and warehouse ID are required" });
    }
    const result = await db.execute(sql4`
      INSERT INTO warehouse_zones (
        name,
        code,
        description,
        warehouse_id,
        zone_type,
        capacity,
        is_active,
        created_at
      )
      VALUES (
        ${name},
        ${code},
        ${description || null},
        ${warehouse_id},
        ${zone_type || "Standard"},
        ${capacity || 0},
        ${is_active !== void 0 ? is_active : true},
        NOW()
      )
      RETURNING id, name, code, warehouse_id
    `);
    const newZone = result.rows[0];
    res.status(201).json({
      success: true,
      message: "Storage zone created successfully",
      zone: newZone
    });
  } catch (error) {
    console.error("Error creating storage zone:", error);
    res.status(500).json({ error: "Failed to create storage zone" });
  }
});
router2.get("/warehouse/zones", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        z.id,
        z.code,
        z.name,
        z.description,
        z.zone_type,
        z.capacity,
        z.is_active as "isActive",
        z.warehouse_id,
        w.name as warehouse_name,
        w.code as warehouse_code
      FROM warehouse_zones z
      LEFT JOIN warehouses w ON z.warehouse_id = w.id
      ORDER BY z.name
    `);
    const zones = result.rows || [];
    return res.json(zones);
  } catch (error) {
    console.error("Error fetching storage zones:", error);
    return res.status(500).json({ error: "Failed to fetch storage zones" });
  }
});
router2.post("/storage/locations/add", async (req, res) => {
  try {
    const {
      name,
      code,
      address,
      city,
      state,
      country,
      zip,
      capacity,
      is_manufacturing,
      description,
      contact_person,
      contact_phone,
      contact_email,
      parent_warehouse_id
    } = req.body;
    if (!name || !code) {
      return res.status(400).json({ error: "Warehouse name and code are required" });
    }
    const result = await db.execute(sql4`
      INSERT INTO warehouses (
        name,
        code,
        address,
        city,
        state,
        country,
        zip,
        capacity,
        is_manufacturing,
        description,
        contact_person,
        contact_phone,
        contact_email,
        parent_warehouse_id,
        is_active,
        created_at
      )
      VALUES (
        ${name},
        ${code},
        ${address || null},
        ${city || null},
        ${state || null},
        ${country || null},
        ${zip || null},
        ${capacity || 0},
        ${is_manufacturing || false},
        ${description || null},
        ${contact_person || null},
        ${contact_phone || null},
        ${contact_email || null},
        ${parent_warehouse_id || null},
        true,
        NOW()
      )
      RETURNING id, name, code
    `);
    const newWarehouse = result.rows[0];
    res.status(201).json({
      success: true,
      message: "Warehouse created successfully",
      warehouse: newWarehouse
    });
  } catch (error) {
    console.error("Error creating warehouse:", error);
    res.status(500).json({ error: "Failed to create warehouse" });
  }
});
router2.get("/storage/locations", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        w.id,
        w.code,
        w.name,
        'Warehouse' as type,
        w.address,
        w.city,
        w.state,
        w.country,
        w.zip as zip_code,
        w.capacity,
        'Unit' as "capacityUom",
        w.is_active as "isActive",
        w.description,
        w.parent_warehouse_id as "parentId"
      FROM warehouses w
      ORDER BY w.name
    `);
    const warehouses2 = result.rows || [];
    return res.json(warehouses2);
  } catch (error) {
    console.error("Error fetching storage locations:", error);
    return res.status(500).json({ error: "Failed to fetch storage locations" });
  }
});
router2.get("/batch-lots", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        bl.id,
        bl.lot_number,
        bl.batch_number as "batchNumber",
        p.name as "materialName",
        p.sku as "materialCode",
        bl.quantity,
        bl.quantity as "remainingQuantity",
        bl.unit_of_measure as uom,
        bl.status,
        w.name as "locationName",
        v.name as "vendorName",
        bl.manufacture_date as "manufacturingDate",
        bl.expiration_date as "expirationDate",
        bl.receipt_date as "receivedDate",
        bl.cost,
        bl.purchase_order_id as "purchaseOrderId",
        bl.production_order_id as "productionOrderId",
        bl.quality_status as "qualityStatus",
        bl.created_at as "createdAt",
        bl.updated_at as "updatedAt"
      FROM batch_lots bl
      LEFT JOIN products p ON bl.product_id = p.id
      LEFT JOIN warehouses w ON bl.warehouse_id = w.id
      LEFT JOIN vendors v ON bl.vendor_id = v.id
      ORDER BY bl.created_at DESC
    `);
    const batchLots2 = result.rows || [];
    return res.json(batchLots2);
  } catch (error) {
    console.error("Error fetching batch lots:", error);
    return res.status(500).json({ error: "Failed to fetch batch lots" });
  }
});
router2.get("/batch-lots/expiring", async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 90;
    const today = /* @__PURE__ */ new Date();
    const futureDate = /* @__PURE__ */ new Date();
    futureDate.setDate(today.getDate() + days);
    const result = await db.execute(sql4`
      SELECT 
        bl.id,
        bl.lot_number,
        bl.batch_number as "batchNumber",
        p.name as "materialName",
        p.sku as "materialCode",
        bl.quantity,
        bl.quantity as "remainingQuantity",
        bl.unit_of_measure as uom,
        bl.status,
        w.name as "locationName",
        v.name as "vendorName",
        bl.manufacture_date as "manufacturingDate",
        bl.expiration_date as "expirationDate",
        bl.receipt_date as "receivedDate",
        bl.cost,
        DATE_PART('day', bl.expiration_date::timestamp - CURRENT_DATE::timestamp)::integer as "daysRemaining",
        bl.purchase_order_id as "purchaseOrderId",
        bl.quality_status as "qualityStatus",
        bl.created_at as "createdAt"
      FROM batch_lots bl
      LEFT JOIN products p ON bl.product_id = p.id
      LEFT JOIN warehouses w ON bl.warehouse_id = w.id
      LEFT JOIN vendors v ON bl.vendor_id = v.id
      WHERE 
        bl.expiration_date IS NOT NULL
        AND bl.expiration_date >= CURRENT_DATE
        AND bl.expiration_date <= ${futureDate}::date
        AND bl.status NOT IN ('Consumed', 'Expired', 'Rejected')
      ORDER BY bl.expiration_date
    `);
    const expiringBatchLots = result.rows || [];
    return res.json(expiringBatchLots);
  } catch (error) {
    console.error("Error fetching expiring batch lots:", error);
    return res.status(500).json({ error: "Failed to fetch expiring batch lots" });
  }
});
router2.post("/batch-lots", async (req, res) => {
  try {
    const {
      product_id,
      lot_number,
      batch_number,
      quantity,
      unit_of_measure,
      warehouse_id,
      vendor_id,
      manufacture_date,
      expiration_date,
      receipt_date,
      cost,
      purchase_order_id,
      production_order_id,
      status,
      quality_status,
      country_of_origin,
      is_quarantine,
      quarantine_reason,
      notes
    } = req.body;
    if (!product_id || !lot_number || !quantity || !unit_of_measure) {
      return res.status(400).json({
        error: "Missing required fields. Product ID, lot number, quantity, and unit of measure are required."
      });
    }
    const batchNumberToUse = batch_number || `BN-${Date.now().toString().slice(-8)}`;
    const result = await db.execute(sql4`
      INSERT INTO batch_lots (
        product_id,
        lot_number,
        batch_number,
        quantity,
        unit_of_measure,
        warehouse_id,
        vendor_id,
        manufacture_date,
        expiration_date,
        receipt_date,
        cost,
        purchase_order_id,
        production_order_id,
        status,
        quality_status,
        country_of_origin,
        is_quarantine,
        quarantine_reason,
        notes,
        created_at,
        updated_at,
        created_by
      )
      VALUES (
        ${product_id},
        ${lot_number},
        ${batchNumberToUse},
        ${quantity},
        ${unit_of_measure},
        ${warehouse_id || null},
        ${vendor_id || null},
        ${manufacture_date ? new Date(manufacture_date) : null},
        ${expiration_date ? new Date(expiration_date) : null},
        ${receipt_date ? new Date(receipt_date) : /* @__PURE__ */ new Date()},
        ${cost || null},
        ${purchase_order_id || null},
        ${production_order_id || null},
        ${status || "Available"},
        ${quality_status || "Pending"},
        ${country_of_origin || null},
        ${is_quarantine || false},
        ${quarantine_reason || null},
        ${notes || null},
        NOW(),
        NOW(),
        ${req.user?.id || null}
      )
      RETURNING *
    `);
    const newBatchLot = result.rows[0];
    if (warehouse_id) {
      await db.execute(sql4`
        INSERT INTO inventory_transactions (
          product_id,
          type,
          quantity,
          reference_id,
          reference_type,
          notes,
          location,
          created_at,
          created_by,
          batch_id
        )
        VALUES (
          ${product_id},
          'Receive',
          ${quantity},
          ${newBatchLot.id},
          'Batch',
          ${`Received batch/lot ${lot_number}`},
          ${warehouse_id},
          NOW(),
          ${req.user?.id || null},
          ${newBatchLot.id}
        )
      `);
    }
    return res.status(201).json({
      success: true,
      message: "Batch lot created successfully",
      batchLot: newBatchLot
    });
  } catch (error) {
    console.error("Error creating batch lot:", error);
    return res.status(500).json({ error: "Failed to create batch lot" });
  }
});
router2.patch("/batch-lots/:id", async (req, res) => {
  try {
    const batchLotId = parseInt(req.params.id);
    if (isNaN(batchLotId)) {
      return res.status(400).json({ error: "Invalid batch lot ID" });
    }
    const {
      quantity,
      warehouse_id,
      status,
      quality_status,
      is_quarantine,
      quarantine_reason,
      quarantine_until,
      notes
    } = req.body;
    const checkResult = await db.execute(sql4`
      SELECT * FROM batch_lots WHERE id = ${batchLotId}
    `);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: "Batch lot not found" });
    }
    const existingBatchLot = checkResult.rows[0];
    let updateFields = [];
    let updateValues = [];
    if (quantity !== void 0) {
      updateFields.push("quantity = $" + (updateValues.length + 1));
      updateValues.push(quantity);
    }
    if (warehouse_id !== void 0) {
      updateFields.push("warehouse_id = $" + (updateValues.length + 1));
      updateValues.push(warehouse_id);
    }
    if (status !== void 0) {
      updateFields.push("status = $" + (updateValues.length + 1));
      updateValues.push(status);
    }
    if (quality_status !== void 0) {
      updateFields.push("quality_status = $" + (updateValues.length + 1));
      updateValues.push(quality_status);
    }
    if (is_quarantine !== void 0) {
      updateFields.push("is_quarantine = $" + (updateValues.length + 1));
      updateValues.push(is_quarantine);
    }
    if (quarantine_reason !== void 0) {
      updateFields.push("quarantine_reason = $" + (updateValues.length + 1));
      updateValues.push(quarantine_reason);
    }
    if (quarantine_until !== void 0) {
      updateFields.push("quarantine_until = $" + (updateValues.length + 1));
      updateValues.push(new Date(quarantine_until));
    }
    if (notes !== void 0) {
      updateFields.push("notes = $" + (updateValues.length + 1));
      updateValues.push(notes);
    }
    updateFields.push("updated_at = NOW()");
    if (updateFields.length === 0) {
      return res.status(400).json({ error: "No fields to update" });
    }
    let updateResult;
    await db.execute(sql4`BEGIN`);
    try {
      if (quantity !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET quantity = ${quantity} WHERE id = ${batchLotId}
        `);
      }
      if (warehouse_id !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET warehouse_id = ${warehouse_id} WHERE id = ${batchLotId}
        `);
      }
      if (status !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET status = ${status} WHERE id = ${batchLotId}
        `);
      }
      if (quality_status !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET quality_status = ${quality_status} WHERE id = ${batchLotId}
        `);
      }
      if (is_quarantine !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET is_quarantine = ${is_quarantine} WHERE id = ${batchLotId}
        `);
      }
      if (quarantine_reason !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET quarantine_reason = ${quarantine_reason} WHERE id = ${batchLotId}
        `);
      }
      if (quarantine_until !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET quarantine_until = ${new Date(quarantine_until)} WHERE id = ${batchLotId}
        `);
      }
      if (notes !== void 0) {
        await db.execute(sql4`
          UPDATE batch_lots SET notes = ${notes} WHERE id = ${batchLotId}
        `);
      }
      await db.execute(sql4`
        UPDATE batch_lots SET updated_at = NOW() WHERE id = ${batchLotId}
      `);
      updateResult = await db.execute(sql4`
        SELECT * FROM batch_lots WHERE id = ${batchLotId}
      `);
      await db.execute(sql4`COMMIT`);
    } catch (error) {
      await db.execute(sql4`ROLLBACK`);
      throw error;
    }
    const result = updateResult;
    const updatedBatchLot = result.rows[0];
    if (warehouse_id !== void 0 && warehouse_id !== existingBatchLot.warehouse_id) {
      await db.execute(sql4`
        INSERT INTO inventory_transactions (
          product_id,
          type,
          quantity,
          reference_id,
          reference_type,
          notes,
          location,
          created_at,
          created_by,
          batch_id
        )
        VALUES (
          ${existingBatchLot.product_id},
          'Transfer',
          ${quantity || existingBatchLot.quantity},
          ${batchLotId},
          'Batch',
          ${`Batch/lot ${existingBatchLot.lot_number} transferred to new location`},
          ${warehouse_id},
          NOW(),
          ${req.user?.id || null},
          ${batchLotId}
        )
      `);
    }
    if (status === "Consumed" && existingBatchLot.status !== "Consumed") {
      await db.execute(sql4`
        INSERT INTO inventory_transactions (
          product_id,
          type,
          quantity,
          reference_id,
          reference_type,
          notes,
          location,
          created_at,
          created_by,
          batch_id
        )
        VALUES (
          ${existingBatchLot.product_id},
          'Consume',
          ${-1 * (quantity || existingBatchLot.quantity)},
          ${batchLotId},
          'Batch',
          ${`Batch/lot ${existingBatchLot.lot_number} marked as consumed`},
          ${existingBatchLot.warehouse_id},
          NOW(),
          ${req.user?.id || null},
          ${batchLotId}
        )
      `);
    }
    return res.json({
      success: true,
      message: "Batch lot updated successfully",
      batchLot: updatedBatchLot
    });
  } catch (error) {
    console.error("Error updating batch lot:", error);
    return res.status(500).json({ error: "Failed to update batch lot" });
  }
});
router2.get("/vendors", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        v.id,
        v.name,
        v.vendor_code as "code",
        v.contact_person as "contactPerson",
        v.email,
        v.phone,
        v.address,
        v.tax_id as "taxId",
        v.status,
        v.payment_terms as "paymentTerms",
        v.incoterms as "deliveryTerms",
        v.website,
        v.quality_rejection_rate as "qualityRating",
        v.on_time_delivery_rate as "deliveryRating",
        v.rating as "priceRating",
        v.is_preferred as "isActive",
        v.created_at as "createdAt",
        v.updated_at as "updatedAt"
      FROM vendors v
      ORDER BY v.name
    `);
    const vendors2 = result.rows || [];
    return res.json(vendors2);
  } catch (error) {
    console.error("Error fetching vendors:", error);
    return res.status(500).json({ error: "Failed to fetch vendors" });
  }
});
router2.get("/vendors/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const vendorResult = await db.execute(sql4`
      SELECT 
        v.id,
        v.name,
        v.vendor_code as "code",
        v.contact_person as "contactPerson",
        v.email,
        v.phone,
        v.address,
        v.tax_id as "taxId",
        v.status,
        v.payment_terms as "paymentTerms",
        v.incoterms as "deliveryTerms",
        v.website,
        v.quality_rejection_rate as "qualityRating",
        v.on_time_delivery_rate as "deliveryRating",
        v.rating as "priceRating",
        v.is_preferred as "isActive",
        v.created_at as "createdAt",
        v.updated_at as "updatedAt"
      FROM vendors v
      WHERE v.id = ${id}
    `);
    if (!vendorResult.rows || vendorResult.rows.length === 0) {
      return res.status(404).json({ error: "Vendor not found" });
    }
    const vendor = vendorResult.rows[0];
    let contracts = [];
    try {
      const contractsResult = await db.execute(sql4`
        SELECT 
          vc.id,
          vc.vendor_id as "vendorId",
          vc.contract_number as "contractNumber",
          vc.type,
          vc.start_date as "startDate",
          vc.end_date as "endDate",
          vc.terms,
          vc.is_active as "isActive",
          vc.auto_renew as "autoRenew",
          vc.notification_days as "notificationDays",
          vc.notes,
          vc.created_at as "createdAt",
          vc.updated_at as "updatedAt"
        FROM vendor_contracts vc
        WHERE vc.vendor_id = ${id}
      `);
      contracts = (contractsResult.rows || []).map((row) => ({
        id: Number(row.id),
        title: String(row.contractNumber || ""),
        customer_name: String(row.vendorName || vendor.name || ""),
        start_date: String(row.startDate || ""),
        end_date: String(row.endDate || ""),
        status: String(row.isActive ? "Active" : "Inactive"),
        value: Number(row.value || 0),
        type: String(row.type || "")
      }));
    } catch (contractError) {
      console.log("Vendor contracts table might not exist:", contractError);
    }
    let products2 = [];
    try {
      const productsResult = await db.execute(sql4`
        SELECT 
          vp.id,
          vp.vendor_id as "vendorId",
          vp.product_id as "materialId",
          p.name as "materialName",
          vp.vendor_part_number as "vendorProductCode",
          vp.vendor_part_name as "vendorProductName",
          vp.price,
          vp.currency,
          vp.lead_time as "leadTime",
          vp.min_order_qty as "minOrderQty",
          vp.is_preferred as "isPreferred",
          vp.notes,
          vp.last_purchase_date as "lastPurchaseDate",
          vp.is_active as "isActive",
          vp.created_at as "createdAt",
          vp.updated_at as "updatedAt"
        FROM vendor_products vp
        LEFT JOIN products p ON vp.product_id = p.id
        WHERE vp.vendor_id = ${id}
      `);
      products2 = (productsResult.rows || []).map((row) => ({
        id: Number(row.id || 0),
        name: String(row.materialName || row.vendorProductName || ""),
        code: String(row.vendorProductCode || ""),
        category: String(row.category || ""),
        price: Number(row.price || 0),
        inventory: Number(row.inventory || 0),
        status: String(row.isActive ? "Active" : "Inactive")
      }));
    } catch (productError) {
      console.log("Vendor products table might not exist:", productError);
    }
    return res.json({
      ...vendor,
      contracts,
      products: products2
    });
  } catch (error) {
    console.error("Error fetching vendor details:", error);
    return res.status(500).json({ error: "Failed to fetch vendor details" });
  }
});
router2.post("/vendors", async (req, res) => {
  try {
    const {
      name,
      vendor_code,
      contact_person,
      email,
      phone,
      address,
      tax_id,
      status,
      payment_terms,
      incoterms,
      website,
      vendor_type,
      lead_time_days,
      minimum_order_value,
      is_preferred,
      is_approved,
      notes
    } = req.body;
    if (!name) {
      return res.status(400).json({
        error: "Vendor name is required"
      });
    }
    if (vendor_code) {
      const checkResult = await db.execute(sql4`
        SELECT id FROM vendors WHERE vendor_code = ${vendor_code}
      `);
      if (checkResult.rows.length > 0) {
        return res.status(409).json({
          error: "A vendor with this code already exists"
        });
      }
    }
    const vendorCodeToUse = vendor_code || `V-${Date.now().toString().slice(-8)}`;
    const result = await db.execute(sql4`
      INSERT INTO vendors (
        name,
        vendor_code,
        contact_person,
        email,
        phone,
        address,
        tax_id,
        status,
        payment_terms,
        incoterms,
        website,
        vendor_type,
        lead_time_days,
        minimum_order_value,
        is_preferred,
        is_approved,
        notes,
        created_at,
        updated_at
      )
      VALUES (
        ${name},
        ${vendorCodeToUse},
        ${contact_person || null},
        ${email || null},
        ${phone || null},
        ${address || null},
        ${tax_id || null},
        ${status || "Active"},
        ${payment_terms || null},
        ${incoterms || null},
        ${website || null},
        ${vendor_type || "Supplier"},
        ${lead_time_days || null},
        ${minimum_order_value || null},
        ${is_preferred !== void 0 ? is_preferred : false},
        ${is_approved !== void 0 ? is_approved : false},
        ${notes || null},
        NOW(),
        NOW()
      )
      RETURNING *
    `);
    const newVendor = result.rows[0];
    return res.status(201).json({
      success: true,
      message: "Vendor created successfully",
      vendor: newVendor
    });
  } catch (error) {
    console.error("Error creating vendor:", error);
    return res.status(500).json({ error: "Failed to create vendor" });
  }
});
router2.patch("/vendors/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      contact_person,
      email,
      phone,
      address,
      tax_id,
      status,
      payment_terms,
      incoterms,
      website,
      vendor_type,
      lead_time_days,
      minimum_order_value,
      is_preferred,
      is_approved,
      notes,
      quality_rejection_rate,
      on_time_delivery_rate,
      rating
    } = req.body;
    const checkResult = await db.execute(sql4`
      SELECT id FROM vendors WHERE id = ${id}
    `);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: "Vendor not found" });
    }
    await db.execute(sql4`BEGIN`);
    try {
      if (name !== void 0) {
        await db.execute(sql4`UPDATE vendors SET name = ${name} WHERE id = ${id}`);
      }
      if (contact_person !== void 0) {
        await db.execute(sql4`UPDATE vendors SET contact_person = ${contact_person} WHERE id = ${id}`);
      }
      if (email !== void 0) {
        await db.execute(sql4`UPDATE vendors SET email = ${email} WHERE id = ${id}`);
      }
      if (phone !== void 0) {
        await db.execute(sql4`UPDATE vendors SET phone = ${phone} WHERE id = ${id}`);
      }
      if (address !== void 0) {
        await db.execute(sql4`UPDATE vendors SET address = ${address} WHERE id = ${id}`);
      }
      if (tax_id !== void 0) {
        await db.execute(sql4`UPDATE vendors SET tax_id = ${tax_id} WHERE id = ${id}`);
      }
      if (status !== void 0) {
        await db.execute(sql4`UPDATE vendors SET status = ${status} WHERE id = ${id}`);
      }
      if (payment_terms !== void 0) {
        await db.execute(sql4`UPDATE vendors SET payment_terms = ${payment_terms} WHERE id = ${id}`);
      }
      if (incoterms !== void 0) {
        await db.execute(sql4`UPDATE vendors SET incoterms = ${incoterms} WHERE id = ${id}`);
      }
      if (website !== void 0) {
        await db.execute(sql4`UPDATE vendors SET website = ${website} WHERE id = ${id}`);
      }
      if (is_preferred !== void 0) {
        await db.execute(sql4`UPDATE vendors SET is_preferred = ${is_preferred} WHERE id = ${id}`);
      }
      if (is_approved !== void 0) {
        await db.execute(sql4`UPDATE vendors SET is_approved = ${is_approved} WHERE id = ${id}`);
      }
      if (notes !== void 0) {
        await db.execute(sql4`UPDATE vendors SET notes = ${notes} WHERE id = ${id}`);
      }
      if (quality_rejection_rate !== void 0) {
        await db.execute(sql4`UPDATE vendors SET quality_rejection_rate = ${quality_rejection_rate} WHERE id = ${id}`);
      }
      if (on_time_delivery_rate !== void 0) {
        await db.execute(sql4`UPDATE vendors SET on_time_delivery_rate = ${on_time_delivery_rate} WHERE id = ${id}`);
      }
      if (rating !== void 0) {
        await db.execute(sql4`UPDATE vendors SET rating = ${rating} WHERE id = ${id}`);
      }
      await db.execute(sql4`UPDATE vendors SET updated_at = NOW() WHERE id = ${id}`);
      const updatedResult = await db.execute(sql4`SELECT * FROM vendors WHERE id = ${id}`);
      await db.execute(sql4`COMMIT`);
      const updatedVendor = updatedResult.rows[0];
      return res.json({
        success: true,
        message: "Vendor updated successfully",
        vendor: updatedVendor
      });
    } catch (error) {
      await db.execute(sql4`ROLLBACK`);
      throw error;
    }
  } catch (error) {
    console.error("Error updating vendor:", error);
    return res.status(500).json({ error: "Failed to update vendor" });
  }
});
router2.get("/valuation-methods", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        id,
        method_name as name,
        description,
        is_default as "isDefault",
        is_active as "isActive",
        applicable_material_types as "defaultForMaterialTypes",
        calculation_formula as "calculationLogic",
        last_calculated as "lastCalculated",
        created_at as "createdAt",
        updated_at as "updatedAt"
      FROM material_valuation_methods
      WHERE is_active = true
    `);
    const valuationMethods = result.rows || [];
    return res.json(valuationMethods);
  } catch (error) {
    console.error("Error fetching valuation methods:", error);
    return res.status(500).json({ error: "Failed to fetch valuation methods" });
  }
});
router2.post("/valuation-methods", async (req, res) => {
  try {
    const {
      method_name,
      description,
      applicable_material_types,
      calculation_formula,
      is_default,
      is_active
    } = req.body;
    if (!method_name) {
      return res.status(400).json({
        error: "Method name is required"
      });
    }
    const checkResult = await db.execute(sql4`
      SELECT id FROM material_valuation_methods WHERE method_name = ${method_name}
    `);
    if (checkResult.rows.length > 0) {
      return res.status(409).json({
        error: "A valuation method with this name already exists"
      });
    }
    if (is_default) {
      await db.execute(sql4`
        UPDATE material_valuation_methods
        SET is_default = false
        WHERE is_default = true
      `);
    }
    const result = await db.execute(sql4`
      INSERT INTO material_valuation_methods (
        method_name,
        description,
        applicable_material_types,
        calculation_formula,
        is_default,
        is_active,
        created_at,
        updated_at
      )
      VALUES (
        ${method_name},
        ${description || null},
        ${applicable_material_types ? `{${applicable_material_types.map((t) => `"${t}"`).join(",")}}` : null},
        ${calculation_formula || null},
        ${is_default || false},
        ${is_active !== void 0 ? is_active : true},
        NOW(),
        NOW()
      )
      RETURNING *
    `);
    const newMethod = result.rows[0];
    return res.status(201).json({
      success: true,
      message: "Valuation method created successfully",
      method: newMethod
    });
  } catch (error) {
    console.error("Error creating valuation method:", error);
    return res.status(500).json({ error: "Failed to create valuation method" });
  }
});
router2.patch("/valuation-methods/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      description,
      applicable_material_types,
      calculation_formula,
      is_default,
      is_active
    } = req.body;
    const checkResult = await db.execute(sql4`
      SELECT id, method_name FROM material_valuation_methods WHERE id = ${id}
    `);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: "Valuation method not found" });
    }
    if (is_default) {
      await db.execute(sql4`
        UPDATE material_valuation_methods
        SET is_default = false
        WHERE is_default = true AND id != ${id}
      `);
    }
    await db.execute(sql4`
      UPDATE material_valuation_methods
      SET
        description = COALESCE(${description !== void 0 ? description : null}, description),
        applicable_material_types = COALESCE(${applicable_material_types ? JSON.stringify(applicable_material_types) : null}, applicable_material_types),
        calculation_formula = COALESCE(${calculation_formula !== void 0 ? calculation_formula : null}, calculation_formula),
        is_default = COALESCE(${is_default !== void 0 ? is_default : null}, is_default),
        is_active = COALESCE(${is_active !== void 0 ? is_active : null}, is_active),
        updated_at = NOW()
      WHERE id = ${id}
    `);
    const updatedResult = await db.execute(sql4`
      SELECT * FROM material_valuation_methods WHERE id = ${id}
    `);
    const updatedMethod = updatedResult.rows[0];
    return res.json({
      success: true,
      message: "Valuation method updated successfully",
      method: updatedMethod
    });
  } catch (error) {
    console.error("Error updating valuation method:", error);
    return res.status(500).json({ error: "Failed to update valuation method" });
  }
});
router2.get("/valuations", async (req, res) => {
  try {
    const method = req.query.method;
    let query = sql4`
      SELECT 
        mv.id,
        mv.product_id as "materialId",
        p.name as "materialName",
        p.sku as "materialCode",
        mv.valuation_method::text as "valuationMethod",
        mvm.method_name as "valuationMethodName",
        mv.valuation_date as "valuationDate",
        mv.value_per_unit as "unitValue",
        (mv.value_per_unit * p.stock_quantity) as "totalValue",
        p.stock_quantity as quantity,
        mv.currency,
        mv.accounting_period as "periodId",
        mv.is_active as "isActive",
        CURRENT_TIMESTAMP as "createdAt",
        CURRENT_TIMESTAMP as "updatedAt"
      FROM material_valuations mv
      LEFT JOIN products p ON mv.product_id = p.id
      LEFT JOIN material_valuation_methods mvm ON mv.valuation_method::text = mvm.method_name
    `;
    if (method) {
      query = sql4`
        ${query}
        WHERE mv.valuation_method::text = ${method}
      `;
    }
    query = sql4`
      ${query}
      ORDER BY p.name, mv.valuation_date DESC
    `;
    const result = await db.execute(query);
    const valuations = result.rows || [];
    return res.json(valuations);
  } catch (error) {
    console.error("Error fetching material valuations:", error);
    return res.status(500).json({ error: "Failed to fetch material valuations" });
  }
});
router2.post("/valuations", async (req, res) => {
  try {
    const {
      product_id,
      valuation_method,
      value_per_unit,
      warehouse_id,
      currency,
      accounting_period,
      batch_lot_id,
      is_active,
      change_reason
    } = req.body;
    if (!product_id || !valuation_method || value_per_unit === void 0) {
      return res.status(400).json({
        error: "Missing required fields. Product ID, valuation method, and value per unit are required."
      });
    }
    const productCheck = await db.execute(sql4`
      SELECT id, name FROM products WHERE id = ${product_id}
    `);
    if (productCheck.rows.length === 0) {
      return res.status(404).json({ error: "Product not found" });
    }
    const methodCheck = await db.execute(sql4`
      SELECT method_name FROM material_valuation_methods 
      WHERE method_name = ${valuation_method} AND is_active = true
    `);
    if (methodCheck.rows.length === 0) {
      return res.status(404).json({ error: "Valuation method not found or inactive" });
    }
    const prevValuation = await db.execute(sql4`
      SELECT value_per_unit
      FROM material_valuations
      WHERE product_id = ${product_id} 
      AND valuation_method::text = ${valuation_method}
      AND is_active = true
      ORDER BY valuation_date DESC
      LIMIT 1
    `);
    const previous_value = prevValuation.rows.length > 0 ? prevValuation.rows[0].value_per_unit : null;
    if (is_active) {
      await db.execute(sql4`
        UPDATE material_valuations
        SET is_active = false
        WHERE product_id = ${product_id} 
        AND valuation_method::text = ${valuation_method}
        AND is_active = true
      `);
    }
    const result = await db.execute(sql4`
      INSERT INTO material_valuations (
        product_id,
        valuation_method,
        value_per_unit,
        warehouse_id,
        valuation_date,
        previous_value_per_unit,
        is_active,
        currency,
        accounting_period,
        batch_lot_id,
        change_reason,
        updated_by
      )
      VALUES (
        ${product_id},
        ${valuation_method}::material_valuation_method,
        ${value_per_unit},
        ${warehouse_id || null},
        NOW(),
        ${previous_value || null},
        ${is_active !== void 0 ? is_active : true},
        ${currency || "USD"},
        ${accounting_period || null},
        ${batch_lot_id || null},
        ${change_reason || "Initial valuation"},
        ${req.user?.id || null}
      )
      RETURNING *
    `);
    const newValuation = result.rows[0];
    await db.execute(sql4`
      UPDATE material_valuation_methods
      SET last_calculated = NOW()
      WHERE method_name = ${valuation_method}
    `);
    return res.status(201).json({
      success: true,
      message: "Material valuation created successfully",
      valuation: newValuation
    });
  } catch (error) {
    console.error("Error creating material valuation:", error);
    return res.status(500).json({ error: "Failed to create material valuation" });
  }
});
router2.patch("/valuations/:id/status", async (req, res) => {
  try {
    const { id } = req.params;
    const { is_active } = req.body;
    if (is_active === void 0) {
      return res.status(400).json({ error: "Missing required field: is_active" });
    }
    const checkResult = await db.execute(sql4`
      SELECT product_id, valuation_method
      FROM material_valuations
      WHERE id = ${id}
    `);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: "Valuation not found" });
    }
    const { product_id, valuation_method } = checkResult.rows[0];
    if (is_active) {
      await db.execute(sql4`
        UPDATE material_valuations
        SET is_active = false
        WHERE product_id = ${product_id} 
        AND valuation_method = ${valuation_method}
        AND id != ${id}
      `);
    }
    const result = await db.execute(sql4`
      UPDATE material_valuations
      SET 
        is_active = ${is_active},
        updated_by = ${req.user?.id || null}
      WHERE id = ${id}
    `);
    const updatedRecord = await db.execute(sql4`
      SELECT * FROM material_valuations WHERE id = ${id}
    `);
    if (updatedRecord.rows.length === 0) {
      return res.status(404).json({ error: "Valuation not found" });
    }
    return res.json({
      success: true,
      message: `Valuation ${is_active ? "activated" : "deactivated"} successfully`,
      valuation: updatedRecord.rows[0]
    });
  } catch (error) {
    console.error("Error updating valuation status:", error);
    return res.status(500).json({ error: "Failed to update valuation status" });
  }
});
router2.get("/mrp/requirements", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        mr.*,
        p.name as "materialName",
        p.sku as "materialCode",
        p.stock_quantity as "currentStock"
      FROM material_requirements mr
      LEFT JOIN products p ON mr.product_id = p.id
      ORDER BY mr.due_date ASC
    `);
    const requirements = result.rows || [];
    return res.json(requirements);
  } catch (error) {
    console.error("Error fetching MRP requirements:", error);
    return res.status(500).json({ error: "Failed to fetch MRP requirements" });
  }
});
router2.get("/production-orders", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'production_orders'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const operationsTableExists = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'production_order_operations'
      ) as exists
    `);
    const qualityChecksTableExists = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'quality_checks'
      ) as exists
    `);
    const hasOperationsTable = operationsTableExists.rows && operationsTableExists.rows[0] && operationsTableExists.rows[0].exists;
    const hasQualityChecksTable = qualityChecksTableExists.rows && qualityChecksTableExists.rows[0] && qualityChecksTableExists.rows[0].exists;
    const result = await db.execute(sql4`
      SELECT 
        po.id,
        po.order_number as production_number,
        p.id as product_id,
        p.name as product_name,
        po.quantity,
        po.completed_quantity,
        po.planned_start_date as start_date,
        po.planned_end_date as end_date,
        po.status,
        po.priority,
        po.routing_id as work_center_id,
        wc.name as work_center_name,
        po.bom_id,
        bom.name as bom_name,
        po.created_by,
        u.username as created_by_name,
        po.created_at,
        po.notes
      FROM production_orders po
      LEFT JOIN products p ON po.product_id = p.id
      LEFT JOIN work_centers wc ON po.routing_id = wc.id
      LEFT JOIN bill_of_materials bom ON po.bom_id = bom.id
      LEFT JOIN users u ON po.created_by = u.id
      ORDER BY CASE 
        WHEN po.status = 'InProgress' THEN 1
        WHEN po.status = 'Scheduled' THEN 2
        WHEN po.status = 'OnHold' THEN 3
        WHEN po.status = 'Completed' THEN 4
        ELSE 5
      END, 
      po.created_at DESC
    `);
    const productionOrders2 = result.rows || [];
    return res.json(productionOrders2);
  } catch (error) {
    console.error("Error fetching production orders:", error);
    return res.status(500).json({ error: "Failed to fetch production orders" });
  }
});
router2.get("/work-centers", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'work_centers'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        wc.id,
        wc.name,
        wc.code,
        wc.description,
        wc.status,
        wc.capacity,
        COALESCE(
          (SELECT SUM(po.quantity) FROM production_orders po WHERE po.routing_id = wc.id AND po.status IN ('Scheduled', 'InProgress')),
          0
        ) as current_load,
        wc.operating_hours,
        wc.hourly_rate,
        wc.setup_time,
        0 as workers_assigned,
        0 as equipment_count,
        wc.created_at
      FROM work_centers wc
      ORDER BY wc.name
    `);
    const workCenters2 = result.rows || [];
    const workCentersWithDetails = await Promise.all(workCenters2.map(async (workCenter) => {
      let equipment2 = [];
      try {
        const equipmentResult = await db.execute(sql4`
          SELECT 
            id, 
            name, 
            status
          FROM equipment 
          WHERE work_center_id = ${workCenter.id}
          LIMIT 5
        `);
        equipment2 = (equipmentResult.rows || []).map((row) => ({
          id: Number(row.id || 0),
          name: String(row.name || ""),
          type: String(row.type || "Machine"),
          status: String(row.status || "Operational"),
          location: String(row.location || ""),
          last_maintenance: String(row.last_maintenance || ""),
          next_maintenance: String(row.next_maintenance || "")
        }));
      } catch (error) {
        console.error(`Error fetching equipment for work center ${workCenter.id}:`, error);
      }
      let currentJobs = [];
      try {
        const jobsResult = await db.execute(sql4`
          SELECT 
            po.id,
            po.order_number as name,
            COALESCE(
              (SELECT SUM(completed_quantity) FROM production_order_operations WHERE production_order_id = po.id) / po.quantity * 100,
              0
            ) as completion,
            po.planned_end_date as due_date
          FROM production_orders po
          WHERE po.routing_id = ${workCenter.id}
          AND po.status IN ('Scheduled', 'InProgress')
          ORDER BY po.planned_end_date ASC
          LIMIT 5
        `);
        currentJobs = (jobsResult.rows || []).map((row) => ({
          id: Number(row.id || 0),
          order_id: Number(row.id || 0),
          equipment_id: Number(row.equipment_id || 0),
          status: String(row.status || "InProgress"),
          start_time: String(row.start_time || (/* @__PURE__ */ new Date()).toISOString()),
          end_time: row.end_time ? String(row.end_time) : void 0,
          product_name: String(row.name || ""),
          quantity: Number(row.quantity || 0)
        }));
      } catch (error) {
        console.error(`Error fetching jobs for work center ${workCenter.id}:`, error);
      }
      return {
        ...workCenter,
        equipment: equipment2,
        current_jobs: currentJobs
      };
    }));
    return res.json(workCentersWithDetails);
  } catch (error) {
    console.error("Error fetching work centers:", error);
    return res.status(500).json({ error: "Failed to fetch work centers" });
  }
});
router2.get("/bom", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'bill_of_materials'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        bom.id,
        bom.name,
        bom.version,
        p.id as product_id,
        p.name as product_name,
        bom.is_active,
        bom.notes,
        bom.created_at,
        u.username as created_by,
        (SELECT COUNT(*) FROM bom_items WHERE bom_id = bom.id) as item_count
      FROM bill_of_materials bom
      LEFT JOIN products p ON bom.product_id = p.id
      LEFT JOIN users u ON bom.created_by = u.id
      ORDER BY bom.created_at DESC
    `);
    const boms = result.rows || [];
    return res.json(boms);
  } catch (error) {
    console.error("Error fetching bill of materials:", error);
    return res.status(500).json({ error: "Failed to fetch bill of materials" });
  }
});
router2.get("/bom/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const headerResult = await db.execute(sql4`
      SELECT 
        bom.id,
        bom.name,
        bom.revision,
        p.id as product_id,
        p.name as product_name,
        p.sku as product_sku,
        bom.quantity as base_quantity,
        bom.unit_of_measure,
        bom.is_active,
        bom.notes,
        bom.created_at,
        u.username as created_by
      FROM bill_of_materials bom
      LEFT JOIN products p ON bom.product_id = p.id
      LEFT JOIN users u ON bom.created_by = u.id
      WHERE bom.id = ${id}
    `);
    const headerRows = headerResult.rows || [];
    if (headerRows.length === 0) {
      return res.status(404).json({ error: "Bill of Materials not found" });
    }
    const bomHeader = headerRows[0];
    const itemsResult = await db.execute(sql4`
      SELECT 
        bi.id,
        bi.bom_id,
        bi.component_id,
        p.name as component_name,
        p.sku as component_sku,
        bi.quantity,
        bi.unit_of_measure,
        bi.position,
        bi.notes,
        bi.is_critical,
        bi.procurement_type,
        bi.lead_time,
        bi.is_active
      FROM bom_items bi
      LEFT JOIN products p ON bi.component_id = p.id
      WHERE bi.bom_id = ${id}
      ORDER BY bi.position ASC
    `);
    const bomItems2 = itemsResult.rows || [];
    return res.json({
      ...bomHeader,
      items: bomItems2
    });
  } catch (error) {
    console.error(`Error fetching BOM details for ID ${req.params.id}:`, error);
    return res.status(500).json({ error: "Failed to fetch BOM details" });
  }
});
router2.get("/quality-inspections", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'quality_checks'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        qc.id,
        qc.inspection_number,
        qc.type,
        qc.status,
        qc.result,
        qc.production_order_id,
        po.order_number as production_order_number,
        p.id as product_id,
        p.name as product_name,
        qc.batch_lot_id,
        bl.lot_number as batch_lot_number,
        qc.inspector_id,
        u.username as inspector_name,
        qc.inspection_date,
        qc.notes,
        (SELECT COUNT(*) FROM quality_check_parameters WHERE quality_check_id = qc.id) as parameter_count,
        (SELECT COUNT(*) FROM quality_check_parameters WHERE quality_check_id = qc.id AND result = 'Pass') as parameters_passed,
        (SELECT COUNT(*) FROM quality_check_parameters WHERE quality_check_id = qc.id AND result = 'Fail') as parameters_failed
      FROM quality_checks qc
      LEFT JOIN production_orders po ON qc.production_order_id = po.id
      LEFT JOIN products p ON po.product_id = p.id
      LEFT JOIN batch_lots bl ON qc.batch_lot_id = bl.id
      LEFT JOIN users u ON qc.inspector_id = u.id
      ORDER BY qc.inspection_date DESC
    `);
    const qualityInspections2 = result.rows || [];
    return res.json(qualityInspections2);
  } catch (error) {
    console.error("Error fetching quality inspections:", error);
    return res.status(500).json({ error: "Failed to fetch quality inspections" });
  }
});
router2.post("/quality-inspections", async (req, res) => {
  try {
    const {
      batchLotId,
      inspectorName,
      inspectionDate,
      testType,
      testResult,
      qualityRating,
      defectsFound,
      corrective_action,
      approved,
      comments
    } = req.body;
    if (!inspectorName || !inspectionDate || !testType || !testResult) {
      return res.status(400).json({
        error: "Inspector name, inspection date, test type, and test result are required"
      });
    }
    const inspectionNumber = `QI-${(/* @__PURE__ */ new Date()).getFullYear()}-${Date.now().toString().slice(-6)}`;
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'quality_checks'
      ) as exists
    `);
    let inspectionId;
    if (tableExistsResult.rows && tableExistsResult.rows[0] && tableExistsResult.rows[0].exists) {
      const result = await db.execute(sql4`
        INSERT INTO quality_checks (
          inspection_number,
          type,
          status,
          result,
          batch_lot_id,
          inspector_id,
          inspection_date,
          notes,
          created_at,
          updated_at
        )
        VALUES (
          ${inspectionNumber},
          ${testType},
          ${"Completed"},
          ${testResult === "Pass" ? "Pass" : testResult === "Fail" ? "Fail" : "Conditional"},
          ${batchLotId ? parseInt(batchLotId) : null},
          ${req.user?.id || 1},
          ${new Date(inspectionDate)},
          ${JSON.stringify({
        inspector_name: inspectorName,
        test_type: testType,
        test_result: testResult,
        quality_rating: qualityRating,
        defects_found: defectsFound,
        corrective_action,
        approved,
        comments
      })},
          NOW(),
          NOW()
        )
        RETURNING id
      `);
      inspectionId = result.rows[0]?.id;
    } else {
      if (batchLotId) {
        await db.execute(sql4`
          UPDATE batch_lots 
          SET notes = COALESCE(notes, '') || chr(10) || 'Quality Inspection: ' || ${inspectionNumber} || ' - ' || ${testResult} || ' (' || ${(/* @__PURE__ */ new Date()).toISOString()} || ')'
          WHERE id = ${parseInt(batchLotId)}
        `);
      }
      inspectionId = Date.now();
    }
    const newInspection = {
      id: inspectionId,
      inspection_number: inspectionNumber,
      inspector_name: inspectorName,
      inspection_date: inspectionDate,
      test_type: testType,
      test_result: testResult,
      quality_rating: qualityRating,
      defects_found: defectsFound,
      corrective_action,
      approved,
      comments,
      batch_lot_id: batchLotId ? parseInt(batchLotId) : null,
      status: "Completed",
      created_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    return res.status(201).json({
      success: true,
      message: "Quality inspection created successfully",
      inspection: newInspection
    });
  } catch (error) {
    console.error("Error creating quality inspection:", error);
    return res.status(500).json({ error: "Failed to create quality inspection" });
  }
});
router2.get("/maintenance-requests", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'maintenance_requests'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        mr.id,
        mr.request_number,
        mr.request_type,
        mr.priority,
        mr.status,
        mr.equipment_id,
        e.name as equipment_name,
        e.type as equipment_type,
        mr.work_center_id,
        wc.name as work_center_name,
        mr.description,
        mr.requested_by,
        u.username as requested_by_name,
        mr.assigned_to,
        u2.username as assigned_to_name,
        mr.request_date,
        mr.scheduled_date,
        mr.completion_date,
        0 as estimated_hours,
        mr.downtime as actual_hours,
        mr.notes,
        mr.parts_used
      FROM maintenance_requests mr
      LEFT JOIN equipment e ON mr.equipment_id = e.id
      LEFT JOIN work_centers wc ON mr.work_center_id = wc.id
      LEFT JOIN users u ON mr.requested_by = u.id
      LEFT JOIN users u2 ON mr.assigned_to = u2.id
      ORDER BY 
        CASE 
          WHEN mr.priority = 'Critical' THEN 1
          WHEN mr.priority = 'High' THEN 2
          WHEN mr.priority = 'Medium' THEN 3
          WHEN mr.priority = 'Low' THEN 4
          ELSE 5
        END,
        mr.request_date DESC
    `);
    const maintenanceRequests2 = result.rows || [];
    return res.json(maintenanceRequests2);
  } catch (error) {
    console.error("Error fetching maintenance requests:", error);
    return res.status(500).json({ error: "Failed to fetch maintenance requests" });
  }
});
router2.get("/dashboard", async (req, res) => {
  try {
    let productionStats = {
      total: 0,
      inProgress: 0,
      completed: 0,
      delayed: 0,
      onHold: 0
    };
    try {
      const productionStatsQuery = await db.execute(sql4`
        SELECT
          COUNT(*) as total,
          COUNT(CASE WHEN status = 'InProgress' THEN 1 END) as in_progress,
          COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed,
          COUNT(CASE WHEN status = 'OnHold' THEN 1 END) as on_hold,
          COUNT(CASE WHEN planned_end_date < CURRENT_DATE AND status NOT IN ('Completed', 'Cancelled') THEN 1 END) as delayed
        FROM production_orders
      `);
      if (productionStatsQuery.rows && productionStatsQuery.rows.length > 0) {
        productionStats = {
          total: Number(productionStatsQuery.rows[0].total) || 0,
          inProgress: Number(productionStatsQuery.rows[0].in_progress) || 0,
          completed: Number(productionStatsQuery.rows[0].completed) || 0,
          delayed: Number(productionStatsQuery.rows[0].delayed) || 0,
          onHold: Number(productionStatsQuery.rows[0].on_hold) || 0
        };
      }
    } catch (error) {
      console.error("Error fetching production statistics:", error);
    }
    let qualityStats = {
      inspections: 0,
      passed: 0,
      failed: 0,
      pending: 0
    };
    try {
      const qualityStatsQuery = await db.execute(sql4`
        SELECT
          COUNT(*) as total,
          COUNT(CASE WHEN result = 'Pass' THEN 1 END) as passed,
          COUNT(CASE WHEN result = 'Fail' THEN 1 END) as failed,
          COUNT(CASE WHEN status = 'Planned' OR status = 'In Progress' OR result IS NULL THEN 1 END) as pending
        FROM quality_checks
      `);
      if (qualityStatsQuery.rows && qualityStatsQuery.rows.length > 0) {
        qualityStats = {
          inspections: Number(qualityStatsQuery.rows[0].total) || 0,
          passed: Number(qualityStatsQuery.rows[0].passed) || 0,
          failed: Number(qualityStatsQuery.rows[0].failed) || 0,
          pending: Number(qualityStatsQuery.rows[0].pending) || 0
        };
      }
    } catch (error) {
      console.error("Error fetching quality statistics:", error);
    }
    let maintenanceStats = {
      total: 0,
      pending: 0,
      inProgress: 0,
      completed: 0,
      critical: 0
    };
    try {
      const maintenanceStatsQuery = await db.execute(sql4`
        SELECT
          COUNT(*) as total,
          COUNT(CASE WHEN status = 'Scheduled' THEN 1 END) as pending,
          COUNT(CASE WHEN status = 'InProgress' THEN 1 END) as in_progress,
          COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed,
          COUNT(CASE WHEN priority = 'Critical' AND status != 'Completed' THEN 1 END) as critical
        FROM maintenance_requests
      `);
      if (maintenanceStatsQuery.rows && maintenanceStatsQuery.rows.length > 0) {
        maintenanceStats = {
          total: Number(maintenanceStatsQuery.rows[0].total) || 0,
          pending: Number(maintenanceStatsQuery.rows[0].pending) || 0,
          inProgress: Number(maintenanceStatsQuery.rows[0].in_progress) || 0,
          completed: Number(maintenanceStatsQuery.rows[0].completed) || 0,
          critical: Number(maintenanceStatsQuery.rows[0].critical) || 0
        };
      }
    } catch (error) {
      console.error("Error fetching maintenance statistics:", error);
    }
    let recentOrders = [];
    try {
      const recentOrdersResult = await db.execute(sql4`
        SELECT 
          po.id,
          po.order_number,
          p.name as product_name,
          po.quantity,
          po.status,
          po.planned_start_date,
          po.planned_end_date,
          wc.name as work_center_name
        FROM production_orders po
        LEFT JOIN products p ON po.product_id = p.id
        LEFT JOIN work_centers wc ON po.routing_id = wc.id
        ORDER BY po.created_at DESC
        LIMIT 5
      `);
      recentOrders = recentOrdersResult.rows || [];
    } catch (error) {
      console.error("Error fetching recent production orders:", error);
    }
    let workCenterUtilization = [];
    try {
      const workCenterResult = await db.execute(sql4`
        SELECT 
          wc.id,
          wc.name,
          wc.capacity,
          COALESCE(
            (SELECT SUM(po.quantity) FROM production_orders po WHERE po.routing_id = wc.id AND po.status IN ('Scheduled', 'InProgress')),
            0
          ) as current_load
        FROM work_centers wc
        ORDER BY wc.name
        LIMIT 5
      `);
      const wcRows = workCenterResult.rows || [];
      workCenterUtilization = wcRows.map((wc) => {
        const capacity = Number(wc.capacity) || 0;
        const currentLoad = Number(wc.current_load) || 0;
        return {
          id: Number(wc.id),
          name: String(wc.name),
          capacity,
          current_load: currentLoad,
          utilization: capacity > 0 ? Math.round(currentLoad / capacity * 100) : 0
        };
      });
    } catch (error) {
      console.error("Error fetching work center utilization:", error);
    }
    return res.json({
      productionStats,
      qualityStats,
      maintenanceStats,
      recentOrders,
      workCenterUtilization
    });
  } catch (error) {
    console.error("Error fetching manufacturing dashboard data:", error);
    return res.status(500).json({ error: "Failed to fetch manufacturing dashboard data" });
  }
});
router2.get("/trade-compliance", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'trade_compliance_documents'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        tcd.id,
        tcd.document_type as "documentType",
        tcd.document_number as "documentNumber",
        tcd.country,
        tcd.status,
        tcd.issue_date as "issueDate",
        tcd.expiry_date as "expiryDate",
        tcd.notes,
        tcd.attachment_url as "attachmentUrl",
        tcd.created_at as "createdAt",
        tcd.updated_at as "updatedAt",
        u.username as "createdByName"
      FROM trade_compliance_documents tcd
      LEFT JOIN users u ON tcd.created_by = u.id
      ORDER BY tcd.updated_at DESC NULLS LAST
    `);
    const tradeComplianceRecords = result.rows || [];
    return res.json(tradeComplianceRecords);
  } catch (error) {
    console.error("Error fetching trade compliance records:", error);
    return res.status(500).json({ error: "Failed to fetch trade compliance records" });
  }
});
router2.post("/trade-compliance", async (req, res) => {
  try {
    const {
      document_type,
      document_number,
      country,
      status,
      issue_date,
      expiry_date,
      notes,
      attachment_url
    } = req.body;
    if (!document_type || !document_number || !country || !status) {
      return res.status(400).json({
        error: "Document type, document number, country, and status are required"
      });
    }
    const checkResult = await db.execute(sql4`
      SELECT id FROM trade_compliance_documents WHERE document_number = ${document_number}
    `);
    if (checkResult.rows.length > 0) {
      return res.status(409).json({
        error: "A document with this number already exists"
      });
    }
    const result = await db.execute(sql4`
      INSERT INTO trade_compliance_documents (
        document_type,
        document_number,
        country,
        status,
        issue_date,
        expiry_date,
        notes,
        attachment_url,
        created_at,
        updated_at,
        created_by
      )
      VALUES (
        ${document_type},
        ${document_number},
        ${country},
        ${status},
        ${issue_date ? new Date(issue_date) : null},
        ${expiry_date ? new Date(expiry_date) : null},
        ${notes || null},
        ${attachment_url || null},
        NOW(),
        NOW(),
        ${req.user?.id || null}
      )
      RETURNING *
    `);
    const newDocument = result.rows[0];
    return res.status(201).json({
      success: true,
      message: "Trade compliance document created successfully",
      document: newDocument
    });
  } catch (error) {
    console.error("Error creating trade compliance document:", error);
    return res.status(500).json({ error: "Failed to create trade compliance document" });
  }
});
router2.get("/columns/:table", async (req, res) => {
  try {
    const tableName = req.params.table;
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = ${tableName}
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json({ error: `Table '${tableName}' does not exist` });
    }
    const columnResult = await db.execute(sql4`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns
      WHERE table_name = ${tableName}
      ORDER BY ordinal_position
    `);
    const columns = (columnResult.rows || []).map((row) => ({
      column_name: String(row.column_name || ""),
      data_type: String(row.data_type || ""),
      is_nullable: String(row.is_nullable || "")
    }));
    return res.json(columns);
  } catch (error) {
    console.error(`Error fetching columns for table ${req.params.table}:`, error);
    return res.status(500).json({ error: `Failed to fetch columns for ${req.params.table}` });
  }
});
router2.get("/returns", async (req, res) => {
  try {
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'return_authorizations'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.json([]);
    }
    const result = await db.execute(sql4`
      SELECT 
        ra.id,
        ra.rma_number,
        ra.status,
        ra.customer_id,
        c.name as customer_name,
        ra.return_type,
        ra.return_reason,
        ra.created_at,
        ra.created_by,
        ra.approved_by,
        ra.approval_date,
        ra.expected_return_date,
        ra.actual_return_date,
        ra.source_document_type,
        ra.source_document_id,
        ra.notes,
        ra.shipping_method,
        ra.shipping_tracking,
        ra.quality_check_required,
        ra.resolution,
        ra.resolution_date,
        ra.return_address,
        (SELECT COUNT(*) FROM return_items WHERE return_id = ra.id) as item_count,
        (SELECT SUM(quantity) FROM return_items WHERE return_id = ra.id) as total_quantity
      FROM return_authorizations ra
      LEFT JOIN accounts c ON ra.customer_id = c.id
      ORDER BY ra.created_at DESC
    `);
    const returns = result.rows || [];
    const returnsWithItems = await Promise.all(returns.map(async (returnAuth) => {
      const itemsResult = await db.execute(sql4`
        SELECT 
          ri.id,
          ri.return_id,
          ri.product_id,
          p.name as product_name,
          p.sku as product_code,
          ri.quantity,
          ri.unit_of_measure,
          ri.return_reason,
          ri.batch_lot_id as lot_number,
          CAST(NULL as text) as serial_number,
          ri.condition,
          ri.disposition,
          ri.status,
          ri.notes
        FROM return_items ri
        LEFT JOIN products p ON ri.product_id = p.id
        WHERE ri.return_id = ${returnAuth.id}
      `);
      const returnItems = itemsResult.rows || [];
      return {
        ...returnAuth,
        items: returnItems
      };
    }));
    return res.json(returnsWithItems);
  } catch (error) {
    console.error("Error fetching returns:", error);
    return res.status(500).json({ error: "Failed to fetch returns" });
  }
});
router2.post("/returns", async (req, res) => {
  try {
    const {
      rma_number,
      customer_name,
      return_type,
      return_reason,
      product_id,
      quantity,
      condition,
      notes,
      expected_return_date,
      status = "Pending"
    } = req.body;
    if (!rma_number || !return_reason) {
      return res.status(400).json({ error: "Missing required fields: rma_number, return_reason" });
    }
    const tableExistsResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'return_authorizations'
      ) as exists
    `);
    if (!tableExistsResult.rows || !tableExistsResult.rows[0] || !tableExistsResult.rows[0].exists) {
      return res.status(500).json({ error: "Return authorizations table not found" });
    }
    const result = await db.execute(sql4`
      INSERT INTO return_authorizations (
        rma_number,
        return_type,
        return_reason,
        notes,
        expected_return_date,
        status,
        created_at
      ) VALUES (
        ${rma_number},
        ${return_type},
        ${return_reason},
        ${notes},
        ${expected_return_date},
        ${status},
        NOW()
      ) RETURNING *
    `);
    const newReturn = result.rows[0];
    return res.status(201).json(newReturn);
  } catch (error) {
    console.error("Error creating return authorization:", error);
    return res.status(500).json({ error: "Failed to create return authorization" });
  }
});
router2.get("/boms", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        b.id,
        b.product_id,
        p.name as product_name,
        p.sku as product_sku,
        b.version,
        b.name,
        b.description,
        b.is_active,
        b.created_at,
        b.created_by,
        u.username as created_by_name,
        b.approved_by,
        a.username as approved_by_name,
        b.approval_date as approved_at,
        b.manufacturing_type as industry_type,
        b.notes,
        (SELECT COUNT(*) FROM bom_items WHERE bom_id = b.id) as component_count
      FROM bill_of_materials b
      LEFT JOIN products p ON b.product_id = p.id
      LEFT JOIN users u ON b.created_by = u.id
      LEFT JOIN users a ON b.approved_by = a.id
      ORDER BY b.created_at DESC
    `);
    return res.json(result.rows || []);
  } catch (error) {
    console.error("Error fetching BOMs:", error);
    return res.status(500).json({ error: "Failed to fetch BOMs" });
  }
});
router2.get("/boms/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const bomResult = await db.execute(sql4`
      SELECT 
        b.id,
        b.product_id,
        p.name as product_name,
        p.sku as product_sku,
        b.version,
        b.name,
        b.description,
        b.is_active,
        b.created_at,
        b.created_by,
        u.username as created_by_name,
        b.approved_by,
        a.username as approved_by_name,
        b.approval_date as approved_at,
        b.manufacturing_type as industry_type,
        b.yield,
        b.total_cost,
        b.notes,
        b.revision_notes as revision
      FROM bill_of_materials b
      LEFT JOIN products p ON b.product_id = p.id
      LEFT JOIN users u ON b.created_by = u.id
      LEFT JOIN users a ON b.approved_by = a.id
      WHERE b.id = ${id}
    `);
    if (!bomResult.rows || bomResult.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const bomItemsResult = await db.execute(sql4`
      SELECT 
        bi.id,
        bi.component_id,
        p.name as component_name,
        p.sku as component_sku,
        bi.quantity,
        bi.unit_of_measure,
        bi.position,
        bi.is_optional,
        bi.is_sub_assembly,
        bi.scrap_rate,
        bi.operation,
        bi.notes,
        bi.work_center_id,
        w.name as work_center_name,
        p.price as unit_cost,
        (p.price * bi.quantity) as total_cost
      FROM bom_items bi
      LEFT JOIN products p ON bi.component_id = p.id
      LEFT JOIN work_centers w ON bi.work_center_id = w.id
      WHERE bi.bom_id = ${id}
      ORDER BY bi.position
    `);
    const bom = {
      ...bomResult.rows[0],
      items: bomItemsResult.rows || []
    };
    return res.json(bom);
  } catch (error) {
    console.error("Error fetching BOM:", error);
    return res.status(500).json({ error: "Failed to fetch BOM" });
  }
});
router2.post("/boms", async (req, res) => {
  try {
    const {
      product_id,
      version = "1.0",
      name,
      description = "",
      is_active = true,
      manufacturing_type = null,
      notes = "",
      revision_notes = "",
      yield_percentage = 100,
      total_cost = 0
    } = req.body;
    if (!product_id) {
      return res.status(400).json({ error: "Product ID is required" });
    }
    if (!name) {
      return res.status(400).json({ error: "BOM name is required" });
    }
    const productCheck = await db.execute(sql4`
      SELECT id, name FROM products WHERE id = ${product_id}
    `);
    if (!productCheck.rows || productCheck.rows.length === 0) {
      return res.status(400).json({ error: "Product not found" });
    }
    const existingBomCheck = await db.execute(sql4`
      SELECT id FROM bill_of_materials WHERE product_id = ${product_id} AND version = ${version}
    `);
    if (existingBomCheck.rows && existingBomCheck.rows.length > 0) {
      return res.status(400).json({
        error: "A BOM with this product and version already exists",
        existingBomId: existingBomCheck.rows[0].id
      });
    }
    const result = await db.execute(sql4`
      INSERT INTO bill_of_materials (
        product_id,
        version,
        name,
        description,
        is_active,
        created_at,
        created_by,
        manufacturing_type,
        notes,
        revision_notes,
        yield,
        total_cost,
        is_default
      )
      VALUES (
        ${product_id},
        ${version},
        ${name},
        ${description},
        ${is_active},
        ${(/* @__PURE__ */ new Date()).toISOString()},
        ${req.user?.id || 1},
        ${manufacturing_type || "Discrete"},
        ${notes},
        ${revision_notes},
        ${yield_percentage},
        ${total_cost},
        ${false}
      )
      RETURNING id
    `);
    const bomId = result.rows?.[0]?.id;
    return res.status(201).json({
      id: bomId,
      product_id,
      version,
      name,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      created_by: req.user?.id || 1,
      message: "BOM created successfully"
    });
  } catch (error) {
    console.error("Error creating BOM:", error);
    return res.status(500).json({ error: "Failed to create BOM" });
  }
});
router2.post("/boms/:id/items", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      component_id,
      quantity = 1,
      unit_of_measure = "Each",
      position = 1,
      is_optional = false,
      is_sub_assembly = false,
      scrap_rate = 0,
      operation = null,
      notes = null,
      work_center_id = null
    } = req.body;
    if (!component_id) {
      return res.status(400).json({ error: "Component ID is required" });
    }
    const bomCheck = await db.execute(sql4`
      SELECT id, product_id FROM boms WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const componentCheck = await db.execute(sql4`
      SELECT id, name FROM products WHERE id = ${component_id}
    `);
    if (!componentCheck.rows || componentCheck.rows.length === 0) {
      return res.status(400).json({ error: "Component product not found" });
    }
    if (bomCheck.rows[0].product_id === component_id) {
      return res.status(400).json({ error: "Cannot add the product itself as a component" });
    }
    let nextPosition = position;
    if (!position) {
      const positionResult = await db.execute(sql4`
        SELECT COALESCE(MAX(position), 0) + 1 as next_position
        FROM bom_items
        WHERE bom_id = ${id}
      `);
      nextPosition = positionResult.rows?.[0]?.next_position || 1;
    }
    const result = await db.execute(sql4`
      INSERT INTO bom_items (
        bom_id,
        component_id,
        quantity,
        unit_of_measure,
        position,
        is_optional,
        is_sub_assembly,
        scrap_rate,
        operation,
        notes,
        work_center_id
      )
      VALUES (
        ${id},
        ${component_id},
        ${quantity},
        ${unit_of_measure},
        ${nextPosition},
        ${is_optional},
        ${is_sub_assembly},
        ${scrap_rate},
        ${operation},
        ${notes},
        ${work_center_id}
      )
      RETURNING id
    `);
    const itemId = result.rows?.[0]?.id;
    const componentDetails = await db.execute(sql4`
      SELECT name, sku FROM products WHERE id = ${component_id}
    `);
    const componentName = componentDetails.rows?.[0]?.name || "";
    const componentSku = componentDetails.rows?.[0]?.sku || "";
    return res.status(201).json({
      id: itemId,
      bom_id: id,
      component_id,
      component_name: componentName,
      component_sku: componentSku,
      quantity,
      unit_of_measure,
      position: nextPosition,
      message: "BOM item added successfully"
    });
  } catch (error) {
    console.error("Error adding BOM item:", error);
    return res.status(500).json({ error: "Failed to add BOM item" });
  }
});
router2.patch("/boms/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      description,
      is_active,
      effective_date,
      expiration_date,
      revision,
      industry_type,
      approved_by,
      approved_at
    } = req.body;
    let updateFields = sql4``;
    let isFirstField = true;
    if (name !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}name = ${name}`;
      isFirstField = false;
    }
    if (description !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}description = ${description}`;
      isFirstField = false;
    }
    if (is_active !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}is_active = ${is_active}`;
      isFirstField = false;
    }
    if (effective_date !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}effective_date = ${effective_date}`;
      isFirstField = false;
    }
    if (expiration_date !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}expiration_date = ${expiration_date}`;
      isFirstField = false;
    }
    if (revision !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}revision = ${revision}`;
      isFirstField = false;
    }
    if (industry_type !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}industry_type = ${industry_type}`;
      isFirstField = false;
    }
    if (approved_by !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}approved_by = ${approved_by}`;
      isFirstField = false;
    }
    if (approved_at !== void 0) {
      updateFields = sql4`${updateFields}${isFirstField ? "" : ", "}approved_at = ${approved_at}`;
      isFirstField = false;
    }
    if (isFirstField) {
      return res.status(400).json({ error: "No fields provided for update" });
    }
    const bomCheck = await db.execute(sql4`
      SELECT id FROM boms WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const result = await db.execute(sql4`
      UPDATE boms
      SET ${updateFields}
      WHERE id = ${id}
      RETURNING id, name, is_active, revision
    `);
    return res.json({
      ...result.rows[0],
      message: "BOM updated successfully"
    });
  } catch (error) {
    console.error("Error updating BOM:", error);
    return res.status(500).json({ error: "Failed to update BOM" });
  }
});
router2.delete("/boms/:bomId/items/:itemId", async (req, res) => {
  try {
    const { bomId, itemId } = req.params;
    const bomCheck = await db.execute(sql4`
      SELECT id FROM boms WHERE id = ${bomId}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM not found" });
    }
    const itemCheck = await db.execute(sql4`
      SELECT id FROM bom_items WHERE id = ${itemId} AND bom_id = ${bomId}
    `);
    if (!itemCheck.rows || itemCheck.rows.length === 0) {
      return res.status(404).json({ error: "BOM item not found" });
    }
    await db.execute(sql4`
      DELETE FROM bom_items WHERE id = ${itemId}
    `);
    return res.json({
      id: itemId,
      bom_id: bomId,
      message: "BOM item deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting BOM item:", error);
    return res.status(500).json({ error: "Failed to delete BOM item" });
  }
});
router2.post("/boms/:id/copy", async (req, res) => {
  try {
    const { id } = req.params;
    const { new_version, new_name } = req.body;
    if (!new_version) {
      return res.status(400).json({ error: "New version is required" });
    }
    const bomCheck = await db.execute(sql4`
      SELECT product_id, name, description, industry_type FROM boms WHERE id = ${id}
    `);
    if (!bomCheck.rows || bomCheck.rows.length === 0) {
      return res.status(404).json({ error: "Source BOM not found" });
    }
    const sourceBom = bomCheck.rows[0];
    const versionCheck = await db.execute(sql4`
      SELECT id FROM boms WHERE product_id = ${sourceBom.product_id} AND version = ${new_version}
    `);
    if (versionCheck.rows && versionCheck.rows.length > 0) {
      return res.status(400).json({
        error: "A BOM with this product and version already exists",
        existingBomId: versionCheck.rows[0].id
      });
    }
    await db.execute(sql4`BEGIN`);
    try {
      const newBomResult = await db.execute(sql4`
        INSERT INTO boms (
          product_id,
          version,
          name,
          description,
          is_active,
          created_at,
          created_by,
          revision,
          industry_type
        )
        VALUES (
          ${sourceBom.product_id},
          ${new_version},
          ${new_name || `${sourceBom.name} (${new_version})`},
          ${sourceBom.description},
          true,
          ${(/* @__PURE__ */ new Date()).toISOString()},
          ${req.user?.id || 1},
          '1',
          ${sourceBom.industry_type}
        )
        RETURNING id
      `);
      const newBomId = newBomResult.rows?.[0]?.id;
      await db.execute(sql4`
        INSERT INTO bom_items (
          bom_id,
          component_id,
          quantity,
          unit_of_measure,
          position,
          is_optional,
          is_sub_assembly,
          scrap_rate,
          operation,
          notes,
          work_center_id
        )
        SELECT 
          ${newBomId},
          component_id,
          quantity,
          unit_of_measure,
          position,
          is_optional,
          is_sub_assembly,
          scrap_rate,
          operation,
          notes,
          work_center_id
        FROM bom_items
        WHERE bom_id = ${id}
      `);
      await db.execute(sql4`COMMIT`);
      return res.status(201).json({
        id: newBomId,
        product_id: sourceBom.product_id,
        version: new_version,
        name: new_name || `${sourceBom.name} (${new_version})`,
        copied_from: id,
        message: "BOM copied successfully"
      });
    } catch (error) {
      await db.execute(sql4`ROLLBACK`);
      throw error;
    }
  } catch (error) {
    console.error("Error copying BOM:", error);
    return res.status(500).json({ error: "Failed to copy BOM" });
  }
});
router2.post("/warehouse/transfers/add", async (req, res) => {
  try {
    const {
      product_id,
      source_bin_id,
      destination_bin_id,
      quantity,
      transfer_reason,
      reference_number,
      notes
    } = req.body;
    if (!product_id || !source_bin_id || !destination_bin_id || !quantity) {
      return res.status(400).json({
        error: "Product ID, source bin, destination bin, and quantity are required"
      });
    }
    await db.execute(sql4`BEGIN`);
    try {
      const productResult = await db.execute(sql4`
        SELECT id, name, sku FROM products WHERE id = ${product_id}
      `);
      if (productResult.rows.length === 0) {
        await db.execute(sql4`ROLLBACK`);
        return res.status(404).json({ error: "Product not found" });
      }
      const product = productResult.rows[0];
      const sourceBinResult = await db.execute(sql4`
        SELECT bin_code, available_capacity FROM storage_bins WHERE id = ${source_bin_id}
      `);
      if (sourceBinResult.rows.length === 0) {
        await db.execute(sql4`ROLLBACK`);
        return res.status(404).json({ error: "Source bin not found" });
      }
      const destBinResult = await db.execute(sql4`
        SELECT bin_code, available_capacity FROM storage_bins WHERE id = ${destination_bin_id}
      `);
      if (destBinResult.rows.length === 0) {
        await db.execute(sql4`ROLLBACK`);
        return res.status(404).json({ error: "Destination bin not found" });
      }
      await db.execute(sql4`
        UPDATE storage_bins 
        SET available_capacity = available_capacity - ${quantity}
        WHERE id = ${source_bin_id}
      `);
      await db.execute(sql4`
        UPDATE storage_bins 
        SET available_capacity = available_capacity + ${quantity}
        WHERE id = ${destination_bin_id}
      `);
      const transferOutResult = await db.execute(sql4`
        INSERT INTO inventory_transactions (
          product_id,
          type,
          quantity,
          reference_id,
          reference_type,
          notes,
          location,
          created_at
        )
        VALUES (
          ${product_id},
          'Transfer',
          ${-quantity}, -- negative for outbound
          ${reference_number || null},
          'Transfer',
          ${notes ? `Source bin: ${source_bin_id}, ${notes}` : `Source bin: ${source_bin_id}`},
          ${source_bin_id},
          NOW()
        )
        RETURNING id
      `);
      const transferInResult = await db.execute(sql4`
        INSERT INTO inventory_transactions (
          product_id,
          type,
          quantity,
          reference_id,
          reference_type,
          notes,
          location,
          created_at
        )
        VALUES (
          ${product_id},
          'Transfer',
          ${quantity}, -- positive for inbound
          ${reference_number || null},
          'Transfer',
          ${notes ? `Destination bin: ${destination_bin_id}, ${notes}` : `Destination bin: ${destination_bin_id}`},
          ${destination_bin_id},
          NOW()
        )
        RETURNING id
      `);
      const transferOutId = transferOutResult.rows[0].id;
      const transferInId = transferInResult.rows[0].id;
      await db.execute(sql4`COMMIT`);
      res.status(201).json({
        success: true,
        message: "Material transfer completed successfully",
        transfer: {
          ids: {
            outbound: transferOutId,
            inbound: transferInId
          },
          product: product.name,
          quantity,
          source_bin: sourceBinResult.rows[0].bin_code,
          destination_bin: destBinResult.rows[0].bin_code,
          date: /* @__PURE__ */ new Date()
        }
      });
    } catch (error) {
      await db.execute(sql4`ROLLBACK`);
      throw error;
    }
  } catch (error) {
    console.error("Error creating material transfer:", error);
    res.status(500).json({ error: "Failed to create material transfer" });
  }
});
router2.get("/warehouse/transfers", async (req, res) => {
  try {
    const result = await db.execute(sql4`
      SELECT 
        t.id,
        t.created_at as transaction_date,
        t.quantity,
        t.type as transaction_type,
        t.reference_id as reference_number,
        t.notes,
        p.name as product_name,
        p.sku as product_code,
        t.location as bin_location
      FROM inventory_transactions t
      LEFT JOIN products p ON t.product_id = p.id
      WHERE t.type = 'Transfer' OR t.reference_type = 'Transfer'
      ORDER BY t.created_at DESC
    `);
    const transfers = result.rows || [];
    return res.json(transfers);
  } catch (error) {
    console.error("Error fetching material transfers:", error);
    return res.status(500).json({ error: "Failed to fetch material transfers" });
  }
});
var manufacturing_routes_fixed_default = router2;

// server/telephony-routes.ts
import { Router as Router4 } from "express";

// server/telephony-service.ts
init_schema();
init_db();
import twilio from "twilio";
import { eq as eq11 } from "drizzle-orm";
async function getTwilioClient() {
  try {
    const [twilioKeys] = await db.select().from(apiKeys).where(eq11(apiKeys.provider, "Twilio")).where(eq11(apiKeys.isActive, true));
    if (!twilioKeys) {
      throw new Error("No active Twilio API key found");
    }
    const accountSid = twilioKeys.key;
    const authToken = twilioKeys.secret;
    if (!accountSid || !authToken) {
      throw new Error("Invalid Twilio credentials");
    }
    const additionalFields = twilioKeys.additionalFields || {};
    const defaultPhone = additionalFields.defaultPhone || "";
    await db.update(apiKeys).set({
      usageCount: (twilioKeys.usageCount || 0) + 1,
      lastUsed: /* @__PURE__ */ new Date()
    }).where(eq11(apiKeys.id, twilioKeys.id));
    const client2 = twilio(accountSid, authToken);
    return {
      client: client2,
      config: {
        defaultPhone,
        additionalFields
      }
    };
  } catch (error) {
    console.error("Error initializing Twilio client:", error);
    throw new Error("Could not initialize Twilio client");
  }
}
async function makeOutboundCall(to, from = "", callbackUrl, options = {}) {
  try {
    const twilioData = await getTwilioClient();
    const { client: client2, config: config2 } = twilioData;
    const fromNumber = from || config2.defaultPhone;
    if (!fromNumber) {
      throw new Error("No phone number provided and no default phone number configured");
    }
    const callParams = {
      to,
      from: fromNumber,
      url: callbackUrl,
      statusCallback: options.recordingStatusCallback,
      record: options.record ? "record-from-answer" : "do-not-record"
    };
    if (options.transcribe) {
      callParams.transcribe = true;
      callParams.transcribeCallback = `${callbackUrl}/transcription`;
    }
    if (options.customParameters) {
      Object.entries(options.customParameters).forEach(([key, value]) => {
        callParams[key] = value;
      });
    }
    const call = await client2.calls.create(callParams);
    return {
      success: true,
      callSid: call.sid,
      status: call.status,
      startTime: call.startTime,
      direction: call.direction
    };
  } catch (error) {
    console.error("Error making outbound call:", error);
    return {
      success: false,
      error: error.message || "Failed to make call"
    };
  }
}
async function sendSMS(to, from = "", body, options = {}) {
  try {
    const twilioData = await getTwilioClient();
    const { client: client2, config: config2 } = twilioData;
    const fromNumber = from || config2.defaultPhone;
    if (!fromNumber) {
      throw new Error("No phone number provided and no default phone number configured");
    }
    const messageParams = {
      to,
      from: fromNumber,
      body
    };
    if (options.mediaUrls && options.mediaUrls.length > 0) {
      messageParams.mediaUrl = options.mediaUrls;
    }
    if (options.statusCallback) {
      messageParams.statusCallback = options.statusCallback;
    }
    const message = await client2.messages.create(messageParams);
    return {
      success: true,
      messageSid: message.sid,
      status: message.status,
      dateCreated: message.dateCreated
    };
  } catch (error) {
    console.error("Error sending SMS:", error);
    return {
      success: false,
      error: error.message || "Failed to send SMS"
    };
  }
}
async function getCallRecordings(callSid) {
  try {
    const twilioData = await getTwilioClient();
    const { client: client2 } = twilioData;
    const recordings = await client2.recordings.list({ callSid });
    return {
      success: true,
      recordings: recordings.map((recording) => ({
        sid: recording.sid,
        duration: recording.duration,
        channels: recording.channels,
        status: recording.status,
        dateCreated: recording.dateCreated,
        url: `https://api.twilio.com/2010-04-01/Accounts/${client2.accountSid}/Recordings/${recording.sid}.mp3`
      }))
    };
  } catch (error) {
    console.error("Error getting call recordings:", error);
    return {
      success: false,
      error: error.message || "Failed to get call recordings"
    };
  }
}
async function getCallLogs(options = {}) {
  try {
    const twilioData = await getTwilioClient();
    const { client: client2 } = twilioData;
    const params = {};
    if (options.from) params.from = options.from;
    if (options.to) params.to = options.to;
    if (options.status) params.status = options.status;
    if (options.startTimeAfter) params.startTimeAfter = options.startTimeAfter;
    if (options.startTimeBefore) params.startTimeBefore = options.startTimeBefore;
    const calls = await client2.calls.list({
      ...params,
      limit: options.limit || 20
    });
    return {
      success: true,
      calls: calls.map((call) => ({
        sid: call.sid,
        from: call.from,
        to: call.to,
        status: call.status,
        direction: call.direction,
        duration: call.duration,
        startTime: call.startTime,
        endTime: call.endTime,
        price: call.price,
        priceUnit: call.priceUnit
      }))
    };
  } catch (error) {
    console.error("Error getting call logs:", error);
    return {
      success: false,
      error: error.message || "Failed to get call logs"
    };
  }
}
function generateVoiceResponse(options) {
  const { VoiceResponse } = __require("twilio").twiml;
  const response = new VoiceResponse();
  if (options.sayMessage) {
    response.say({ voice: "alice" }, options.sayMessage);
  }
  if (options.playUrl) {
    response.play(options.playUrl);
  }
  if (options.gatherDigits) {
    const gather = response.gather({
      numDigits: 1,
      action: options.redirectUrl || "/api/telephony/handle-digits",
      method: "POST"
    });
    gather.say({ voice: "alice" }, "Please press a key to continue");
  }
  if (options.recordCall) {
    response.record({
      action: options.redirectUrl || "/api/telephony/recording-complete",
      method: "POST",
      maxLength: 30,
      playBeep: true
    });
  }
  if (options.hangUp) {
    response.hangup();
  }
  return response.toString();
}
async function createConferenceCall(participants, from = "", options = {}) {
  try {
    const twilioData = await getTwilioClient();
    const { client: client2, config: config2 } = twilioData;
    const fromNumber = from || config2.defaultPhone;
    if (!fromNumber) {
      throw new Error("No phone number provided and no default phone number configured");
    }
    const friendlyName = options.friendlyName || `Conference_${Date.now()}`;
    const calls = await Promise.all(participants.map((participant) => {
      const { VoiceResponse } = __require("twilio").twiml;
      const twiml = new VoiceResponse();
      const dial = twiml.dial();
      dial.conference({
        startConferenceOnEnter: true,
        endConferenceOnExit: participants.indexOf(participant) === 0,
        // First participant controls the conference
        record: options.recordConference ? "record-from-start" : "do-not-record",
        statusCallback: options.statusCallback,
        statusCallbackEvent: ["join", "leave", "end", "start"],
        statusCallbackMethod: "POST"
      }, friendlyName);
      return client2.calls.create({
        twiml: twiml.toString(),
        to: participant,
        from: fromNumber
      });
    }));
    return {
      success: true,
      conferenceRoom: friendlyName,
      participants: calls.map((call) => ({
        sid: call.sid,
        to: call.to,
        status: call.status
      }))
    };
  } catch (error) {
    console.error("Error creating conference call:", error);
    return {
      success: false,
      error: error.message || "Failed to create conference call"
    };
  }
}

// server/telephony-routes.ts
init_db();
init_schema();

// server/middleware/auth.ts
var isAuthenticated2 = (req, res, next) => {
  if (!req.isAuthenticated()) {
    res.status(401).json({ error: "Not authenticated" });
    return;
  }
  next();
};
var isAdmin = (req, res, next) => {
  if (!req.isAuthenticated()) {
    res.status(401).json({ error: "Not authenticated" });
    return;
  }
  if (req.user?.role !== "Admin") {
    res.status(403).json({ error: "Insufficient permissions" });
    return;
  }
  next();
};

// server/telephony-routes.ts
var telephonyRouter = Router4();
telephonyRouter.use(isAuthenticated2);
telephonyRouter.post("/call", async (req, res) => {
  try {
    const { to, from, callbackUrl, options } = req.body;
    if (!to || !from || !callbackUrl) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await makeOutboundCall(to, from, callbackUrl, options);
    if (result.success) {
      await db.insert(communications).values({
        channel: "Phone",
        direction: "Outbound",
        content: `Call initiated to ${to}`,
        status: "Unread",
        sentAt: /* @__PURE__ */ new Date(),
        ownerId: req.user.id,
        contactType: req.body.contactType,
        contactId: req.body.contactId,
        leadId: req.body.leadId,
        metadata: {
          callSid: result.callSid,
          provider: "Twilio",
          status: result.status
        }
      });
    }
    res.json(result);
  } catch (error) {
    console.error("Error making outbound call:", error);
    res.status(500).json({ success: false, message: "Failed to make call", error: error.message });
  }
});
telephonyRouter.post("/sms", async (req, res) => {
  try {
    const { to, from, body, options } = req.body;
    if (!to || !from || !body) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await sendSMS(to, from, body, options);
    if (result.success) {
      await db.insert(communications).values({
        channel: "SMS",
        direction: "Outbound",
        content: body,
        status: "Unread",
        sentAt: /* @__PURE__ */ new Date(),
        ownerId: req.user.id,
        contactType: req.body.contactType,
        contactId: req.body.contactId,
        leadId: req.body.leadId,
        metadata: {
          messageSid: result.messageSid,
          provider: "Twilio",
          status: result.status
        }
      });
    }
    res.json(result);
  } catch (error) {
    console.error("Error sending SMS:", error);
    res.status(500).json({ success: false, message: "Failed to send SMS", error: error.message });
  }
});
telephonyRouter.post("/conference", async (req, res) => {
  try {
    const { participants, from, options } = req.body;
    if (!participants || !Array.isArray(participants) || participants.length < 2 || !from) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await createConferenceCall(participants, from, options);
    if (result.success) {
      await db.insert(communications).values({
        channel: "Phone",
        direction: "Outbound",
        content: `Conference call initiated with ${participants.length} participants`,
        status: "Unread",
        sentAt: /* @__PURE__ */ new Date(),
        ownerId: req.user.id,
        metadata: {
          conferenceRoom: result.conferenceRoom,
          provider: "Twilio",
          participants: result.participants
        }
      });
    }
    res.json(result);
  } catch (error) {
    console.error("Error creating conference call:", error);
    res.status(500).json({ success: false, message: "Failed to create conference call", error: error.message });
  }
});
telephonyRouter.get("/recordings/:callSid", async (req, res) => {
  try {
    const { callSid } = req.params;
    if (!callSid) {
      return res.status(400).json({ success: false, message: "Missing call SID" });
    }
    const result = await getCallRecordings(callSid);
    res.json(result);
  } catch (error) {
    console.error("Error getting call recordings:", error);
    res.status(500).json({ success: false, message: "Failed to get call recordings", error: error.message });
  }
});
telephonyRouter.get("/logs", async (req, res) => {
  try {
    const options = {
      from: req.query.from,
      to: req.query.to,
      status: req.query.status,
      startTimeAfter: req.query.startTimeAfter ? new Date(req.query.startTimeAfter) : void 0,
      startTimeBefore: req.query.startTimeBefore ? new Date(req.query.startTimeBefore) : void 0,
      limit: req.query.limit ? parseInt(req.query.limit) : void 0
    };
    const result = await getCallLogs(options);
    res.json(result);
  } catch (error) {
    console.error("Error getting call logs:", error);
    res.status(500).json({ success: false, message: "Failed to get call logs", error: error.message });
  }
});
telephonyRouter.post("/incoming/voice", (req, res) => {
  try {
    const response = generateVoiceResponse({
      sayMessage: "Thank you for calling. Your call is being recorded for quality and training purposes.",
      recordCall: true,
      redirectUrl: "/api/telephony/call-menu"
    });
    res.type("text/xml");
    res.send(response);
  } catch (error) {
    console.error("Error handling incoming voice call:", error);
    res.status(500).send("Error handling call");
  }
});
telephonyRouter.post("/call-menu", (req, res) => {
  try {
    const response = generateVoiceResponse({
      sayMessage: "Press 1 for sales, 2 for support, or 3 to speak with an operator.",
      gatherDigits: true,
      redirectUrl: "/api/telephony/handle-menu-selection"
    });
    res.type("text/xml");
    res.send(response);
  } catch (error) {
    console.error("Error handling call menu:", error);
    res.status(500).send("Error handling call");
  }
});
telephonyRouter.post("/handle-menu-selection", (req, res) => {
  try {
    const { Digits } = req.body;
    let response;
    switch (Digits) {
      case "1":
        response = generateVoiceResponse({
          sayMessage: "Connecting you to sales. Please wait.",
          redirectUrl: "/api/telephony/connect-to-sales"
        });
        break;
      case "2":
        response = generateVoiceResponse({
          sayMessage: "Connecting you to support. Please wait.",
          redirectUrl: "/api/telephony/connect-to-support"
        });
        break;
      case "3":
        response = generateVoiceResponse({
          sayMessage: "Connecting you to an operator. Please wait.",
          redirectUrl: "/api/telephony/connect-to-operator"
        });
        break;
      default:
        response = generateVoiceResponse({
          sayMessage: "Invalid selection. Please try again.",
          gatherDigits: true,
          redirectUrl: "/api/telephony/handle-menu-selection"
        });
    }
    res.type("text/xml");
    res.send(response);
  } catch (error) {
    console.error("Error handling menu selection:", error);
    res.status(500).send("Error handling call");
  }
});
telephonyRouter.post("/webhook/status", async (req, res) => {
  try {
    const { CallSid, CallStatus } = req.body;
    console.log(`Call ${CallSid} status updated to ${CallStatus}`);
    res.sendStatus(200);
  } catch (error) {
    console.error("Error handling call status webhook:", error);
    res.status(500).send("Error handling webhook");
  }
});
telephonyRouter.post("/incoming/sms", async (req, res) => {
  try {
    const { From, Body, MessageSid } = req.body;
    await db.insert(communications).values({
      channel: "SMS",
      direction: "Inbound",
      content: Body,
      status: "Unread",
      sentAt: /* @__PURE__ */ new Date(),
      receivedAt: /* @__PURE__ */ new Date(),
      metadata: {
        messageSid: MessageSid,
        provider: "Twilio",
        from: From
      }
    });
    const { VoiceResponse } = __require("twilio").twiml;
    const twiml = new VoiceResponse();
    res.type("text/xml");
    res.send(twiml.toString());
  } catch (error) {
    console.error("Error handling incoming SMS:", error);
    res.status(500).send("Error handling SMS");
  }
});
telephonyRouter.use(isAdmin);
telephonyRouter.get("/admin/logs", async (req, res) => {
  try {
    const result = await getCallLogs({
      limit: 100
      // Get more logs for admin view
    });
    res.json(result);
  } catch (error) {
    console.error("Error getting admin call logs:", error);
    res.status(500).json({ success: false, message: "Failed to get call logs", error: error.message });
  }
});
var telephony_routes_default = telephonyRouter;

// server/payment-routes.ts
import { Router as Router5 } from "express";

// server/payment-service.ts
init_schema();
init_db();
import Stripe from "stripe";
import { eq as eq12 } from "drizzle-orm";
async function getStripeClient() {
  try {
    const [stripeKey] = await db.select().from(apiKeys).where(eq12(apiKeys.provider, "Stripe")).where(eq12(apiKeys.isActive, true));
    if (!stripeKey) {
      throw new Error("No active Stripe API key found");
    }
    const apiKey = stripeKey.key;
    if (!apiKey) {
      throw new Error("Invalid Stripe credentials");
    }
    const additionalFields = stripeKey.additionalFields || {};
    await db.update(apiKeys).set({
      usageCount: (stripeKey.usageCount || 0) + 1,
      lastUsed: /* @__PURE__ */ new Date()
    }).where(eq12(apiKeys.id, stripeKey.id));
    const client2 = new Stripe(apiKey, {
      apiVersion: "2023-10-16"
      // Updated to a currently supported API version
    });
    return {
      client: client2,
      config: {
        additionalFields,
        webhookSecret: additionalFields.webhookSecret,
        allowedPaymentMethods: additionalFields.allowedPaymentMethods || ["card"]
      }
    };
  } catch (error) {
    console.error("Error initializing Stripe client:", error);
    throw new Error("Could not initialize Stripe client: " + (error.message || "Unknown error"));
  }
}
async function createStripePaymentIntent(data) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2, config: config2 } = stripeData;
    if (data.paymentMethodId && config2.allowedPaymentMethods && config2.allowedPaymentMethods.length > 0) {
      const paymentMethod = "card";
      if (!config2.allowedPaymentMethods.includes(paymentMethod)) {
        throw new Error(`Payment method ${paymentMethod} is not allowed. Allowed methods: ${config2.allowedPaymentMethods.join(", ")}`);
      }
    }
    const paymentIntent = await client2.paymentIntents.create({
      amount: Math.round(data.amount * 100),
      // Convert to cents
      currency: data.currency,
      description: data.description,
      metadata: data.metadata,
      receipt_email: data.receiptEmail,
      customer: data.customerId,
      payment_method: data.paymentMethodId,
      statement_descriptor: data.statementDescriptor?.substring(0, 22),
      // Max 22 chars
      setup_future_usage: data.setupFutureUsage
    });
    return {
      success: true,
      clientSecret: paymentIntent.client_secret,
      id: paymentIntent.id,
      status: paymentIntent.status
    };
  } catch (error) {
    console.error("Error creating Stripe payment intent:", error);
    return {
      success: false,
      error: error.message || "Failed to create payment intent"
    };
  }
}
async function createStripeCustomer(email, name, metadata) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const customer = await client2.customers.create({
      email,
      name,
      metadata
    });
    return {
      success: true,
      customerId: customer.id
    };
  } catch (error) {
    console.error("Error creating Stripe customer:", error);
    return {
      success: false,
      error: error.message || "Failed to create customer"
    };
  }
}
async function createStripeSubscription(data) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const subscription = await client2.subscriptions.create({
      customer: data.customerId,
      items: [
        {
          price: data.priceId,
          quantity: data.quantity || 1
        }
      ],
      trial_period_days: data.trialPeriodDays,
      metadata: data.metadata,
      billing_cycle_anchor: data.billingCycleAnchor ? Math.floor(data.billingCycleAnchor.getTime() / 1e3) : void 0,
      proration_behavior: data.prorationBehavior,
      payment_behavior: data.paymentBehavior,
      expand: ["latest_invoice.payment_intent"]
    });
    let clientSecret2 = null;
    if (subscription.latest_invoice) {
      const invoice = typeof subscription.latest_invoice === "string" ? await client2.invoices.retrieve(subscription.latest_invoice) : subscription.latest_invoice;
      const paymentIntentData = invoice.payment_intent;
      if (paymentIntentData) {
        const paymentIntentId = typeof paymentIntentData === "string" ? paymentIntentData : paymentIntentData.id;
        if (paymentIntentId) {
          const paymentIntent = await client2.paymentIntents.retrieve(paymentIntentId);
          clientSecret2 = paymentIntent.client_secret;
        }
      }
    }
    return {
      success: true,
      subscriptionId: subscription.id,
      status: subscription.status,
      clientSecret: clientSecret2
    };
  } catch (error) {
    console.error("Error creating Stripe subscription:", error);
    return {
      success: false,
      error: error.message || "Failed to create subscription"
    };
  }
}
async function cancelStripeSubscription(subscriptionId, immediateCancel = false) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    if (immediateCancel) {
      const canceled = await client2.subscriptions.cancel(subscriptionId);
      return {
        success: true,
        status: canceled.status
      };
    } else {
      const canceled = await client2.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true
      });
      const cancelAtDate = canceled.cancel_at ? new Date(canceled.cancel_at * 1e3) : void 0;
      return {
        success: true,
        status: canceled.status,
        cancelAt: cancelAtDate
      };
    }
  } catch (error) {
    console.error("Error canceling Stripe subscription:", error);
    return {
      success: false,
      error: error.message || "Failed to cancel subscription"
    };
  }
}
async function createStripeSetupIntent(customerId, paymentMethodTypes) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const setupIntent = await client2.setupIntents.create({
      customer: customerId,
      payment_method_types: paymentMethodTypes || ["card"]
    });
    return {
      success: true,
      clientSecret: setupIntent.client_secret,
      id: setupIntent.id
    };
  } catch (error) {
    console.error("Error creating Stripe setup intent:", error);
    return {
      success: false,
      error: error.message || "Failed to create setup intent"
    };
  }
}
async function listStripePaymentMethods(customerId, type = "card") {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const paymentMethods = await client2.paymentMethods.list({
      customer: customerId,
      type
    });
    return {
      success: true,
      paymentMethods: paymentMethods.data.map((pm) => ({
        id: pm.id,
        type: pm.type,
        card: pm.type === "card" ? {
          brand: pm.card?.brand,
          last4: pm.card?.last4,
          expMonth: pm.card?.exp_month,
          expYear: pm.card?.exp_year
        } : void 0,
        billingDetails: pm.billing_details,
        isDefault: pm.metadata?.is_default === "true"
      }))
    };
  } catch (error) {
    console.error("Error listing Stripe payment methods:", error);
    return {
      success: false,
      error: error.message || "Failed to list payment methods"
    };
  }
}
async function updateStripePaymentMethod(paymentMethodId, billingDetails) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const updated = await client2.paymentMethods.update(paymentMethodId, {
      billing_details: billingDetails
    });
    return {
      success: true,
      paymentMethod: {
        id: updated.id,
        type: updated.type,
        billingDetails: updated.billing_details
      }
    };
  } catch (error) {
    console.error("Error updating Stripe payment method:", error);
    return {
      success: false,
      error: error.message || "Failed to update payment method"
    };
  }
}
async function setDefaultStripePaymentMethod(customerId, paymentMethodId) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    await client2.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: paymentMethodId
      }
    });
    const paymentMethods = await client2.paymentMethods.list({
      customer: customerId,
      type: "card"
    });
    for (const pm of paymentMethods.data) {
      await client2.paymentMethods.update(pm.id, {
        metadata: {
          is_default: pm.id === paymentMethodId ? "true" : "false"
        }
      });
    }
    return {
      success: true
    };
  } catch (error) {
    console.error("Error setting default Stripe payment method:", error);
    return {
      success: false,
      error: error.message || "Failed to set default payment method"
    };
  }
}
async function deleteStripePaymentMethod(paymentMethodId) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    await client2.paymentMethods.detach(paymentMethodId);
    return {
      success: true
    };
  } catch (error) {
    console.error("Error deleting Stripe payment method:", error);
    return {
      success: false,
      error: error.message || "Failed to delete payment method"
    };
  }
}
async function createStripeRefund(paymentIntentId, amount) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const refund = await client2.refunds.create({
      payment_intent: paymentIntentId,
      amount: amount ? Math.round(amount * 100) : void 0
      // Convert to cents if partial refund
    });
    return {
      success: true,
      refundId: refund.id,
      amount: refund.amount / 100,
      // Convert from cents
      status: refund.status
    };
  } catch (error) {
    console.error("Error creating Stripe refund:", error);
    return {
      success: false,
      error: error.message || "Failed to process refund"
    };
  }
}
async function getStripePaymentIntent(paymentIntentId) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    const paymentIntent = await client2.paymentIntents.retrieve(paymentIntentId, {
      expand: ["latest_charge", "payment_method"]
    });
    return {
      success: true,
      id: paymentIntent.id,
      amount: paymentIntent.amount / 100,
      // Convert from cents
      currency: paymentIntent.currency,
      status: paymentIntent.status,
      customerId: paymentIntent.customer,
      paymentMethodId: paymentIntent.payment_method,
      created: new Date(paymentIntent.created * 1e3),
      metadata: paymentIntent.metadata
    };
  } catch (error) {
    console.error("Error retrieving Stripe payment intent:", error);
    return {
      success: false,
      error: error.message || "Failed to retrieve payment intent"
    };
  }
}
async function createStripeInvoice(customerId, items, description, daysUntilDue, autoAdvance = true) {
  try {
    const stripeData = await getStripeClient();
    const { client: client2 } = stripeData;
    for (const item of items) {
      const params = {
        customer: customerId,
        quantity: item.quantity
      };
      if (item.priceId.startsWith("price_")) {
        params.price = item.priceId;
      } else {
        params.unit_amount = 1e3;
        params.currency = "usd";
        params.description = `Invoice item (${item.priceId})`;
      }
      await client2.invoiceItems.create(params);
    }
    const invoice = await client2.invoices.create({
      customer: customerId,
      description,
      days_until_due: daysUntilDue,
      auto_advance: autoAdvance
    });
    let finalInvoice = invoice;
    if (!autoAdvance && invoice.id) {
      finalInvoice = await client2.invoices.finalizeInvoice(invoice.id);
    }
    return {
      success: true,
      invoiceId: finalInvoice.id,
      amount: finalInvoice.total / 100,
      // Convert from cents
      status: finalInvoice.status,
      hosted_invoice_url: finalInvoice.hosted_invoice_url
    };
  } catch (error) {
    console.error("Error creating Stripe invoice:", error);
    return {
      success: false,
      error: error.message || "Failed to create invoice"
    };
  }
}

// server/payment-routes.ts
init_db();
init_schema();
import { eq as eq13 } from "drizzle-orm";
var paymentRouter = Router5();
paymentRouter.use(isAuthenticated2);
paymentRouter.post("/intent", async (req, res) => {
  try {
    const { amount, currency, description, metadata, customerId, paymentMethodId, receiptEmail } = req.body;
    if (!amount || !currency) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await createStripePaymentIntent({
      amount,
      currency,
      description,
      metadata,
      customerId,
      paymentMethodId,
      receiptEmail
    });
    res.json(result);
  } catch (error) {
    console.error("Error creating payment intent:", error);
    res.status(500).json({ success: false, message: "Failed to create payment intent", error: error.message });
  }
});
paymentRouter.post("/customer", async (req, res) => {
  try {
    const { email, name, metadata } = req.body;
    if (!email) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await createStripeCustomer(email, name, metadata);
    if (result.success && req.user) {
      await db.update(users).set({ stripeCustomerId: result.customerId }).where(eq13(users.id, req.user.id));
    }
    res.json(result);
  } catch (error) {
    console.error("Error creating customer:", error);
    res.status(500).json({ success: false, message: "Failed to create customer", error: error.message });
  }
});
paymentRouter.post("/subscription", async (req, res) => {
  try {
    const { customerId, priceId, quantity, trialPeriodDays, metadata } = req.body;
    if (!customerId || !priceId) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await createStripeSubscription({
      customerId,
      priceId,
      quantity,
      trialPeriodDays,
      metadata,
      paymentBehavior: "default_incomplete"
    });
    if (result.success && req.user && result.subscriptionId) {
      await db.update(users).set({ stripeSubscriptionId: result.subscriptionId }).where(eq13(users.id, req.user.id));
    }
    res.json(result);
  } catch (error) {
    console.error("Error creating subscription:", error);
    res.status(500).json({ success: false, message: "Failed to create subscription", error: error.message });
  }
});
paymentRouter.post("/subscription/:subscriptionId/cancel", async (req, res) => {
  try {
    const { subscriptionId } = req.params;
    const { immediate } = req.body;
    if (!subscriptionId) {
      return res.status(400).json({ success: false, message: "Missing subscription ID" });
    }
    if (req.user.stripeSubscriptionId !== subscriptionId && req.user.role !== "Admin") {
      return res.status(403).json({ success: false, message: "Not authorized to cancel this subscription" });
    }
    const result = await cancelStripeSubscription(subscriptionId, immediate);
    if (result.success && req.user && req.user.stripeSubscriptionId === subscriptionId) {
      if (immediate) {
        await db.update(users).set({ stripeSubscriptionId: null }).where(eq13(users.id, req.user.id));
      }
    }
    res.json(result);
  } catch (error) {
    console.error("Error canceling subscription:", error);
    res.status(500).json({ success: false, message: "Failed to cancel subscription", error: error.message });
  }
});
paymentRouter.post("/setup-intent", async (req, res) => {
  try {
    const { customerId } = req.body;
    if (!customerId) {
      return res.status(400).json({ success: false, message: "Missing customer ID" });
    }
    const result = await createStripeSetupIntent(customerId);
    res.json(result);
  } catch (error) {
    console.error("Error creating setup intent:", error);
    res.status(500).json({ success: false, message: "Failed to create setup intent", error: error.message });
  }
});
paymentRouter.get("/payment-methods/:customerId", async (req, res) => {
  try {
    const { customerId } = req.params;
    const { type } = req.query;
    if (!customerId) {
      return res.status(400).json({ success: false, message: "Missing customer ID" });
    }
    if (req.user.stripeCustomerId !== customerId && req.user.role !== "Admin") {
      return res.status(403).json({ success: false, message: "Not authorized to view payment methods for this customer" });
    }
    const result = await listStripePaymentMethods(customerId, type);
    res.json(result);
  } catch (error) {
    console.error("Error listing payment methods:", error);
    res.status(500).json({ success: false, message: "Failed to list payment methods", error: error.message });
  }
});
paymentRouter.patch("/payment-method/:paymentMethodId", async (req, res) => {
  try {
    const { paymentMethodId } = req.params;
    const { billingDetails } = req.body;
    if (!paymentMethodId || !billingDetails) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await updateStripePaymentMethod(paymentMethodId, billingDetails);
    res.json(result);
  } catch (error) {
    console.error("Error updating payment method:", error);
    res.status(500).json({ success: false, message: "Failed to update payment method", error: error.message });
  }
});
paymentRouter.post("/payment-method/:paymentMethodId/default", async (req, res) => {
  try {
    const { paymentMethodId } = req.params;
    const { customerId } = req.body;
    if (!paymentMethodId || !customerId) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    if (req.user.stripeCustomerId !== customerId && req.user.role !== "Admin") {
      return res.status(403).json({ success: false, message: "Not authorized to modify payment methods for this customer" });
    }
    const result = await setDefaultStripePaymentMethod(customerId, paymentMethodId);
    res.json(result);
  } catch (error) {
    console.error("Error setting default payment method:", error);
    res.status(500).json({ success: false, message: "Failed to set default payment method", error: error.message });
  }
});
paymentRouter.delete("/payment-method/:paymentMethodId", async (req, res) => {
  try {
    const { paymentMethodId } = req.params;
    if (!paymentMethodId) {
      return res.status(400).json({ success: false, message: "Missing payment method ID" });
    }
    const result = await deleteStripePaymentMethod(paymentMethodId);
    res.json(result);
  } catch (error) {
    console.error("Error deleting payment method:", error);
    res.status(500).json({ success: false, message: "Failed to delete payment method", error: error.message });
  }
});
paymentRouter.post("/refund", async (req, res) => {
  try {
    const { paymentIntentId, amount } = req.body;
    if (!paymentIntentId) {
      return res.status(400).json({ success: false, message: "Missing payment intent ID" });
    }
    const result = await createStripeRefund(paymentIntentId, amount);
    res.json(result);
  } catch (error) {
    console.error("Error creating refund:", error);
    res.status(500).json({ success: false, message: "Failed to process refund", error: error.message });
  }
});
paymentRouter.get("/intent/:paymentIntentId", async (req, res) => {
  try {
    const { paymentIntentId } = req.params;
    if (!paymentIntentId) {
      return res.status(400).json({ success: false, message: "Missing payment intent ID" });
    }
    const result = await getStripePaymentIntent(paymentIntentId);
    res.json(result);
  } catch (error) {
    console.error("Error retrieving payment intent:", error);
    res.status(500).json({ success: false, message: "Failed to retrieve payment intent", error: error.message });
  }
});
paymentRouter.post("/invoice", async (req, res) => {
  try {
    const { customerId, items, description, daysUntilDue, autoAdvance } = req.body;
    if (!customerId || !items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ success: false, message: "Missing required parameters" });
    }
    const result = await createStripeInvoice(customerId, items, description, daysUntilDue, autoAdvance);
    res.json(result);
  } catch (error) {
    console.error("Error creating invoice:", error);
    res.status(500).json({ success: false, message: "Failed to create invoice", error: error.message });
  }
});
paymentRouter.use(isAdmin);
paymentRouter.post("/admin/customer-for-user/:userId", async (req, res) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      return res.status(400).json({ success: false, message: "Missing user ID" });
    }
    const [user] = await db.select().from(users).where(eq13(users.id, parseInt(userId)));
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    if (user.stripeCustomerId) {
      return res.json({
        success: true,
        customerId: user.stripeCustomerId,
        existing: true
      });
    }
    const result = await createStripeCustomer(
      user.email || `user-${user.id}@example.com`,
      `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.username,
      { userId: user.id.toString() }
    );
    if (result.success && result.customerId) {
      await db.update(users).set({ stripeCustomerId: result.customerId }).where(eq13(users.id, user.id));
    }
    res.json({
      ...result,
      existing: false
    });
  } catch (error) {
    console.error("Error creating customer for user:", error);
    res.status(500).json({ success: false, message: "Failed to create customer for user", error: error.message });
  }
});
var payment_routes_default = paymentRouter;

// server/routes.ts
init_db();
import { eq as eq14, sql as sql5, desc as desc4, and as and6 } from "drizzle-orm";

// server/middleware/encryption-middleware.ts
init_encryption();
var SENSITIVE_ROUTES = [
  {
    path: /^\/api\/accounts/,
    fields: ["billing_address", "notes", "email", "phone", "address", "billingAddress"]
  },
  {
    path: /^\/api\/contacts/,
    fields: ["email", "phone", "address", "notes", "first_name", "last_name"]
  },
  {
    path: /^\/api\/leads/,
    fields: ["email", "phone", "address", "notes", "first_name", "last_name"]
  },
  {
    path: /^\/api\/opportunities/,
    fields: ["notes", "description"]
  },
  {
    path: /^\/api\/users/,
    fields: ["email", "firstName", "lastName", "first_name", "last_name"]
  },
  {
    path: /^\/api\/invoices/,
    fields: ["billingAddress", "shippingAddress", "billing_address", "shipping_address", "notes"]
  },
  {
    path: /^\/api\/proposals/,
    fields: ["content", "notes", "description"]
  }
];
function encryptSensitiveData(req, res, next) {
  if (!req.body || req.method === "GET") {
    return next();
  }
  try {
    if (process.env.ENCRYPTION_ENABLED !== "true") {
      return next();
    }
    const routeConfig = SENSITIVE_ROUTES.find((route) => route.path.test(req.path));
    if (routeConfig) {
      const encryptionPromises = [];
      for (const field of routeConfig.fields) {
        if (req.body[field] && typeof req.body[field] === "string") {
          const encryptPromise = async () => {
            try {
              const encryptedData = await encrypt(req.body[field]);
              req.body[field] = JSON.stringify(encryptedData);
            } catch (err) {
              console.error(`Error encrypting field ${field}:`, err);
            }
          };
          encryptionPromises.push(encryptPromise());
        }
      }
      Promise.all(encryptionPromises).then(() => next()).catch((err) => {
        console.error("Error during batch encryption:", err);
        next();
      });
    } else {
      next();
    }
  } catch (error) {
    console.error("Error encrypting request data:", error);
    next();
  }
}
function decryptSensitiveData(req, res, next) {
  const originalSend = res.send;
  res.send = function(body) {
    if (body && typeof body === "object" && req.method !== "DELETE") {
      try {
        if (process.env.ENCRYPTION_ENABLED !== "true") {
          return originalSend.call(this, body);
        }
        const routeConfig = SENSITIVE_ROUTES.find((route) => route.path.test(req.path));
        if (routeConfig) {
          const processDecryption = async () => {
            try {
              if (Array.isArray(body)) {
                const decryptedItems = await Promise.all(body.map(async (item) => {
                  const decryptedItem = { ...item };
                  for (const field of routeConfig.fields) {
                    if (item[field] && typeof item[field] === "string") {
                      try {
                        try {
                          const encryptedData = JSON.parse(item[field]);
                          if (encryptedData.encrypted && encryptedData.iv) {
                            const decrypted = await decrypt(encryptedData.encrypted, encryptedData.iv, encryptedData.keyId);
                            decryptedItem[field] = decrypted;
                          }
                        } catch (parseError) {
                        }
                      } catch (decryptError) {
                        console.error(`Error decrypting field ${field} in array item:`, decryptError);
                      }
                    }
                  }
                  return decryptedItem;
                }));
                return originalSend.call(this, decryptedItems);
              } else {
                const decryptedBody = { ...body };
                for (const field of routeConfig.fields) {
                  if (body[field] && typeof body[field] === "string") {
                    try {
                      try {
                        const encryptedData = JSON.parse(body[field]);
                        if (encryptedData.encrypted && encryptedData.iv) {
                          const decrypted = await decrypt(encryptedData.encrypted, encryptedData.iv, encryptedData.keyId);
                          decryptedBody[field] = decrypted;
                        }
                      } catch (parseError) {
                      }
                    } catch (decryptError) {
                      console.error(`Error decrypting field ${field}:`, decryptError);
                    }
                  }
                }
                return originalSend.call(this, decryptedBody);
              }
            } catch (error) {
              console.error("Error during decryption process:", error);
              return originalSend.call(this, body);
            }
          };
          processDecryption().catch((error) => {
            console.error("Unhandled decryption error:", error);
            return originalSend.call(this, body);
          });
          return void 0;
        }
      } catch (error) {
        console.error("Error in decryption middleware:", error);
      }
    }
    return originalSend.call(this, body);
  };
  next();
}

// server/routes.ts
init_schema();
import { z as z4 } from "zod";

// server/openai.ts
import OpenAI2 from "openai";
var openai2 = new OpenAI2({ apiKey: process.env.OPENAI_API_KEY });
function isOpenAIQuotaError(errorMessage) {
  return errorMessage.includes("quota") || errorMessage.includes("insufficient_quota") || errorMessage.includes("rate_limit");
}
async function generateAnalysis(options) {
  try {
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024
      messages: [
        {
          role: "system",
          content: `You are an AI assistant for a CRM system. Analyze the data and answer the user's question with detailed insights. 
            For context, you're analyzing ${options.type || "general"} data. ${options.context || ""}`
        },
        {
          role: "user",
          content: options.prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 800
    });
    return {
      content: response.choices[0].message.content,
      type: options.type || "general",
      model: "gpt-4o"
    };
  } catch (error) {
    console.error("OpenAI Analysis Error:", error);
    throw error;
  }
}
async function generateInsights(options) {
  try {
    const systemPrompt = `You are an AI assistant for a CRM system. Analyze the provided ${options.type} data and generate 3-5 actionable insights. 
      Format your response as a JSON object with the following structure:
      {
        "insights": [
          {
            "title": "Brief insight title",
            "description": "Detailed explanation with data points and recommendations",
            "category": "trend|customer|prediction",
            "importance": "high|medium|low"
          },
          ...
        ]
      }`;
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024
      messages: [
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: `Here is the ${options.type} data to analyze: ${JSON.stringify(options.data, null, 2)}`
        }
      ],
      temperature: 0.7,
      max_tokens: 1e3,
      response_format: { type: "json_object" }
    });
    return {
      content: response.choices[0].message.content,
      type: options.type,
      model: "gpt-4o"
    };
  } catch (error) {
    console.error("OpenAI Insights Error:", error);
    throw error;
  }
}
async function generateRecommendations(options) {
  try {
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024
      messages: [
        {
          role: "system",
          content: `You are a CRM assistant that provides actionable recommendations. 
            Analyze the ${options.entityType} data and suggest 3-5 specific actions to improve outcomes. 
            Format your response in markdown with bullet points.`
        },
        {
          role: "user",
          content: `Here is the ${options.entityType} data: ${JSON.stringify(options.entityData, null, 2)}`
        }
      ],
      temperature: 0.7,
      max_tokens: 800
    });
    return {
      content: response.choices[0].message.content,
      type: options.entityType,
      model: "gpt-4o"
    };
  } catch (error) {
    console.error("OpenAI Recommendations Error:", error);
    throw error;
  }
}
async function generateEmailTemplate(emailType, contactInfo, dealInfo, additionalContext) {
  try {
    const systemPrompt = `You are an AI assistant that creates professional email templates for sales teams. 
      Create a concise, effective email template for a "${emailType}" email.`;
    const contextPrompt = `Create a ${emailType} email template for ${contactInfo.firstName} ${contactInfo.lastName} 
      ${dealInfo ? `regarding ${dealInfo.name || "their opportunity"}` : ""}. 
      ${additionalContext || ""}`;
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024
      messages: [
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: contextPrompt
        }
      ],
      temperature: 0.7,
      max_tokens: 800
    });
    return {
      content: response.choices[0].message.content,
      type: "email_template",
      model: "gpt-4o"
    };
  } catch (error) {
    console.error("OpenAI Email Template Error:", error);
    throw error;
  }
}
async function summarizeMeeting(transcript, meetingContext) {
  try {
    const systemPrompt = `You are an AI assistant that summarizes meetings for sales teams. 
      Create a concise summary with these sections:
      1. Key Points
      2. Action Items
      3. Follow-up Tasks`;
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024
      messages: [
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: `Here's the meeting transcript to summarize: ${transcript}
          ${meetingContext ? `
Meeting context: ${meetingContext}` : ""}`
        }
      ],
      temperature: 0.5,
      max_tokens: 1e3
    });
    return {
      content: response.choices[0].message.content,
      type: "meeting_summary",
      model: "gpt-4o"
    };
  } catch (error) {
    console.error("OpenAI Meeting Summary Error:", error);
    throw error;
  }
}

// server/routes.ts
function handleOpenAIError(res, errorData) {
  const errorMessage = errorData.error?.message || "Unknown error";
  const isQuotaError = isOpenAIQuotaError(errorMessage);
  return res.status(429).json({
    error: "OpenAI API Error",
    details: isQuotaError ? "OpenAI API quota exceeded. Please contact your administrator or try again later." : errorMessage,
    isQuotaError
  });
}
async function registerRoutes(app2) {
  setupAuth(app2);
  app2.use(encryptSensitiveData);
  app2.use(decryptSensitiveData);
  console.log("[Encryption] Averox CryptoSphere encryption middleware applied");
  console.log("[Encryption Debug] Environment variables:", {
    ENCRYPTION_ENABLED: process.env.ENCRYPTION_ENABLED,
    ENABLE_ENCRYPTION: process.env.ENABLE_ENCRYPTION,
    encryption_status: process.env.ENCRYPTION_ENABLED === "true"
  });
  app2.get("/api/auth-test", (req, res) => {
    if (req.isAuthenticated()) {
      return res.json({
        authenticated: true,
        user: req.user,
        sessionID: req.sessionID
      });
    } else {
      return res.status(401).json({
        authenticated: false,
        sessionID: req.sessionID
      });
    }
  });
  app2.post("/api/encryption-test", async (req, res) => {
    try {
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({
          success: false,
          message: "Request body is required for testing encryption"
        });
      }
      console.log("[Encryption Test] Debug info:", {
        ENCRYPTION_ENABLED_VALUE: process.env.ENCRYPTION_ENABLED,
        ENCRYPTION_ENABLED_CHECK: process.env.ENCRYPTION_ENABLED === "true",
        NODE_ENV: process.env.NODE_ENV,
        ENV_KEYS: Object.keys(process.env).filter((key) => key.includes("ENCRYPT"))
      });
      return res.json({
        success: true,
        message: "Encryption test completed",
        data: req.body,
        encryption_enabled: process.env.ENCRYPTION_ENABLED === "true",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        // Debug info to help with troubleshooting
        debug: {
          encryptionSettings: {
            ENCRYPTION_ENABLED: process.env.ENCRYPTION_ENABLED,
            ENABLE_ENCRYPTION: process.env.ENABLE_ENCRYPTION,
            effective: process.env.ENCRYPTION_ENABLED === "true"
          }
        }
      });
    } catch (error) {
      console.error("Error in encryption test:", error);
      return res.status(500).json({
        success: false,
        message: "Encryption test failed",
        error: error.message
      });
    }
  });
  app2.post("/api/database-encryption-test", async (req, res) => {
    try {
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({
          success: false,
          message: "Request body is required for testing database encryption"
        });
      }
      const entityType = req.query.entityType || "test";
      console.log(`[Database Encryption Test] Testing encryption for entity type: ${entityType}`);
      const encryptedData = await encryptForDatabase(req.body, entityType);
      const decryptedData = await decryptFromDatabase(encryptedData, entityType);
      return res.json({
        success: true,
        message: "Database encryption test completed",
        original: req.body,
        encrypted: encryptedData,
        decrypted: decryptedData,
        encryption_enabled: process.env.ENCRYPTION_ENABLED === "true",
        metadata: {
          entityType,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          environment: process.env.NODE_ENV || "development"
        }
      });
    } catch (error) {
      console.error("Error in database encryption test:", error);
      return res.status(500).json({
        success: false,
        message: "Database encryption test failed",
        error: error.message
      });
    }
  });
  app2.get("/api/dashboard/stats", async (req, res) => {
    try {
      const { leads: leadsTable, opportunities: opportunitiesTable, invoices: invoicesTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const thirtyDaysAgo = /* @__PURE__ */ new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const leadsData = await db.select().from(leadsTable);
      const newLeads = leadsData.filter((lead) => {
        if (!lead.createdAt) return false;
        return new Date(lead.createdAt) >= thirtyDaysAgo;
      }).length;
      const opportunitiesData = await db.select().from(opportunitiesTable);
      const totalLeads = leadsData.length;
      const convertedLeads = leadsData.filter((lead) => lead.isConverted).length;
      const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads * 100).toFixed(1) + "%" : "0%";
      const invoicesData = await db.select().from(invoicesTable);
      const paidInvoices = invoicesData.filter((invoice) => invoice.status === "Paid");
      const totalRevenue = paidInvoices.reduce((sum, invoice) => {
        const amount = Number(invoice.totalAmount || 0);
        return sum + amount;
      }, 0);
      const formattedRevenue = "$" + totalRevenue.toLocaleString();
      const openDeals = opportunitiesData.filter((opp) => !opp.isClosed).length;
      res.json({
        newLeads,
        conversionRate,
        revenue: formattedRevenue,
        openDeals
      });
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ error: "Failed to fetch dashboard statistics" });
    }
  });
  app2.get("/api/dashboard/pipeline", async (req, res) => {
    try {
      const { opportunities: opportunitiesTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const opportunitiesData = await db.select().from(opportunitiesTable);
      const stageMap = /* @__PURE__ */ new Map();
      opportunitiesData.forEach((opp) => {
        if (!opp.isClosed) {
          const stage = opp.stage || "Unknown";
          const amount = Number(opp.amount || 0);
          if (!stageMap.has(stage)) {
            stageMap.set(stage, { count: 0, value: 0 });
          }
          const data = stageMap.get(stage);
          data.count += 1;
          data.value += amount;
          stageMap.set(stage, data);
        }
      });
      const totalValue = Array.from(stageMap.values()).reduce((sum, data) => sum + data.value, 0);
      const stages = Array.from(stageMap.entries()).map(([name, data]) => {
        const percentage = totalValue > 0 ? Math.round(data.value / totalValue * 100) : 0;
        const formattedValue = "$" + data.value.toLocaleString();
        return {
          name,
          value: formattedValue,
          percentage
        };
      });
      res.json({ stages });
    } catch (error) {
      console.error("Error fetching pipeline data:", error);
      res.status(500).json({ error: "Failed to fetch pipeline data" });
    }
  });
  app2.get("/api/dashboard/activities", async (req, res) => {
    try {
      const { activities: activitiesTable, users: usersTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const activitiesData = await db.select().from(activitiesTable).orderBy(desc4(activitiesTable.createdAt)).limit(5);
      const usersData = await db.select().from(usersTable);
      const formattedActivities = activitiesData.map((activity) => {
        const user = usersData.find((u) => u.id === activity.userId) || {
          firstName: "Unknown",
          lastName: "User",
          avatar: ""
        };
        const createdAt = activity.createdAt ? new Date(activity.createdAt) : /* @__PURE__ */ new Date();
        let timeAgo = "";
        const now = /* @__PURE__ */ new Date();
        const diffInSeconds = Math.floor((now.getTime() - createdAt.getTime()) / 1e3);
        if (diffInSeconds < 60) {
          timeAgo = `${diffInSeconds} sec ago`;
        } else if (diffInSeconds < 3600) {
          timeAgo = `${Math.floor(diffInSeconds / 60)} min ago`;
        } else if (diffInSeconds < 86400) {
          timeAgo = `${Math.floor(diffInSeconds / 3600)} hour${Math.floor(diffInSeconds / 3600) !== 1 ? "s" : ""} ago`;
        } else if (diffInSeconds < 172800) {
          timeAgo = "Yesterday";
        } else {
          timeAgo = `${Math.floor(diffInSeconds / 86400)} days ago`;
        }
        const firstName = user.firstName || "";
        const lastName = user.lastName || "";
        const fullName = [firstName, lastName].filter(Boolean).join(" ") || "System User";
        const initials = [firstName?.[0], lastName?.[0]].filter(Boolean).join("").toUpperCase() || "SU";
        return {
          id: activity.id,
          action: activity.action,
          detail: activity.detail,
          relatedToType: activity.relatedToType,
          relatedToId: activity.relatedToId,
          createdAt: activity.createdAt,
          icon: activity.icon,
          time: timeAgo,
          user: {
            name: fullName,
            avatar: user.avatar || "",
            initials
          }
        };
      });
      res.json(formattedActivities);
    } catch (error) {
      console.error("Error fetching dashboard activities:", error);
      res.status(500).json({ error: "Failed to fetch activities" });
    }
  });
  app2.get("/api/dashboard/marketing-campaigns", async (req, res) => {
    try {
      const { socialCampaigns: campaignsTable, workflows: workflowsTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const campaignsData = await db.select().from(campaignsTable).limit(3);
      const workflowsData = await db.select().from(workflowsTable).where(
        and6(
          eq14(workflowsTable.entityType, "lead"),
          eq14(workflowsTable.isActive, true)
        )
      );
      const formattedCampaigns = campaignsData.map((campaign) => {
        const workflow = workflowsData.find((w) => {
          try {
            if (w.entityFilter) {
              const filter = typeof w.entityFilter === "string" ? JSON.parse(w.entityFilter) : w.entityFilter;
              return filter?.campaignId === campaign.id;
            }
            return false;
          } catch (e) {
            return false;
          }
        });
        let metricsData = {};
        if (campaign.metrics) {
          try {
            metricsData = typeof campaign.metrics === "string" ? JSON.parse(campaign.metrics) : campaign.metrics;
          } catch (e) {
            console.warn("Error parsing campaign metrics:", e);
            metricsData = {};
          }
        }
        const reach = metricsData?.reach || 0;
        const conversions = metricsData?.conversions || 0;
        const conversionRate = reach > 0 ? Math.round(conversions / reach * 100) : 0;
        const stats = {
          Reach: reach.toString(),
          Clicks: (metricsData?.clicks || 0).toString(),
          Conversions: conversions.toString()
        };
        return {
          id: campaign.id,
          name: campaign.name,
          platform: campaign.platform,
          status: campaign.status || "Draft",
          stats,
          reach,
          conversion: conversionRate,
          budget: metricsData.budget ? `$${metricsData.budget}` : "$0",
          workflow: workflow ? {
            id: workflow.id,
            name: workflow.name,
            count: metricsData.leadCount || 0,
            nextAction: workflow.actions ? "Follow-up emails" : "No actions configured"
          } : null
        };
      });
      res.json(formattedCampaigns);
    } catch (error) {
      console.error("Error fetching marketing campaigns:", error);
      res.status(500).json({ error: "Failed to fetch marketing campaigns" });
    }
  });
  app2.get("/api/dashboard/performance-metrics", async (req, res) => {
    try {
      const {
        opportunities: opportunitiesTable,
        leads: leadsTable,
        proposals: proposalsTable
      } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const thirtyDaysAgo = /* @__PURE__ */ new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const opportunitiesData = await db.select().from(opportunitiesTable);
      const leadsData = await db.select().from(leadsTable);
      const recentLeads = leadsData.filter((lead) => {
        return lead.createdAt && new Date(lead.createdAt) >= thirtyDaysAgo;
      });
      const proposalsData = await db.select().from(proposalsTable);
      const closedOpportunities = opportunitiesData.filter((opp) => opp.isClosed);
      const wonOpportunities = closedOpportunities.filter((opp) => opp.isWon);
      const winRate = closedOpportunities.length > 0 ? Math.round(wonOpportunities.length / closedOpportunities.length * 100) : 0;
      let avgResponseTime = "N/A";
      let responsePercentage = 0;
      if (recentLeads.length > 0) {
        const responseTimes = recentLeads.filter((lead) => lead.lastActivityDate && lead.createdAt).map((lead) => {
          const created = new Date(lead.createdAt);
          const activity = new Date(lead.lastActivityDate);
          return (activity.getTime() - created.getTime()) / (1e3 * 60 * 60);
        });
        if (responseTimes.length > 0) {
          const avgHours = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
          avgResponseTime = avgHours < 1 ? `${Math.round(avgHours * 60)} min` : `${Math.round(avgHours)} hrs`;
          const targetResponseHours = 2;
          responsePercentage = Math.min(100, Math.round(targetResponseHours / Math.max(avgHours, 0.1) * 100));
        }
      }
      const sentProposals = proposalsData.filter((prop) => prop.sentAt);
      const acceptedProposals = sentProposals.filter((prop) => prop.acceptedAt);
      const proposalAcceptanceRate = sentProposals.length > 0 ? Math.round(acceptedProposals.length / sentProposals.length * 100) : 0;
      const metrics = [
        {
          id: 1,
          name: "Win Rate",
          value: `${winRate}%`,
          percentage: winRate,
          change: winRate > 50 ? 5 : -2,
          trend: winRate > 50 ? "up" : "down",
          color: "bg-green-500"
        },
        {
          id: 2,
          name: "Lead Response Time",
          value: avgResponseTime,
          percentage: responsePercentage,
          change: responsePercentage > 70 ? 10 : -10,
          trend: responsePercentage > 70 ? "up" : "down",
          color: "bg-blue-500"
        },
        {
          id: 3,
          name: "Proposal Acceptance",
          value: `${proposalAcceptanceRate}%`,
          percentage: proposalAcceptanceRate,
          change: proposalAcceptanceRate > 30 ? 2 : -3,
          trend: proposalAcceptanceRate > 30 ? "up" : "down",
          color: "bg-amber-500"
        }
      ];
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching performance metrics:", error);
      res.status(500).json({ error: "Failed to fetch performance metrics" });
    }
  });
  app2.get("/api/dashboard/migrations", async (req, res) => {
    try {
      const { systemSettings: systemSettings2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const settingsData = await db.select().from(systemSettings2);
      const hasMigratedContacts = settingsData.some(
        (s) => s.settingKey === "hasMigratedContacts" && s.settingValue === "true"
      );
      const hasMigratedOpportunities = settingsData.some(
        (s) => s.settingKey === "hasMigratedOpportunities" && s.settingValue === "true"
      );
      const migrationInProgress = settingsData.some(
        (s) => s.settingKey === "migrationInProgress" && s.settingValue === "true"
      );
      const migrations = [
        {
          id: 1,
          name: "Contact Data Migration",
          status: hasMigratedContacts ? "Complete" : migrationInProgress ? "In Progress" : "Pending",
          progress: hasMigratedContacts ? 100 : migrationInProgress ? 65 : 0,
          progressText: hasMigratedContacts ? "All contacts migrated" : "Migrating contact records"
        },
        {
          id: 2,
          name: "Opportunity Migration",
          status: hasMigratedOpportunities ? "Complete" : "Pending",
          progress: hasMigratedOpportunities ? 100 : 0,
          progressText: hasMigratedOpportunities ? "All opportunities migrated" : "Waiting to start"
        }
      ];
      res.json(migrations);
    } catch (error) {
      console.error("Error fetching migration status:", error);
      res.status(500).json({ error: "Failed to fetch migration status" });
    }
  });
  registerPermissionRoutes(app2);
  setupMarketingRoutes(app2);
  setupRoutes(app2);
  app2.use("/api/manufacturing", manufacturing_routes_fixed_default);
  if ("initializePermissions" in storage) {
    await storage.initializePermissions();
  }
  app2.get("/api/system-settings", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const settings = await storage.getSystemSettings(userId);
      if (!settings.dashboardPreferences) {
        settings.dashboardPreferences = {
          showSalesPipeline: true,
          showRecentActivities: true,
          showTasks: true,
          showEvents: true,
          showLeadsStats: true,
          showConversionStats: true,
          showRevenueStats: true,
          showOpportunitiesStats: true,
          pipelineChartType: "pie",
          revenueChartType: "line",
          leadsChartType: "line",
          defaultTimeRange: "month",
          showAIInsights: true,
          aiInsightTypes: ["leads", "opportunities", "revenue"],
          aiInsightsCount: 3
        };
      }
      res.json(settings);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/system-settings", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const settings = req.body;
      const updatedSettings = await storage.saveSystemSettings(userId, settings);
      res.json(updatedSettings);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/menu-items", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const userSettings = await storage.getSystemSettings(userId);
      const menuItemsQuery = await db.select().from(systemSettings).where(eq14(systemSettings.settingKey, "menuItems")).where(eq14(systemSettings.scope, "global"));
      let menuItems = [];
      if (menuItemsQuery.length > 0) {
        menuItems = menuItemsQuery[0].settingValue;
        menuItems = menuItems.map((item) => ({
          ...item,
          isVisible: item.key ? userSettings.menuVisibility[item.key] ?? true : true
          // Items without a key are always visible
        }));
      } else {
        const defaultMenuItems = [
          { name: "Dashboard", path: "/", icon: "LayoutDashboard", key: null, isVisible: true },
          { name: "Contacts", path: "/contacts", icon: "Users", key: "contacts", isVisible: userSettings.menuVisibility.contacts },
          { name: "Accounts", path: "/accounts", icon: "Briefcase", key: "accounts", isVisible: userSettings.menuVisibility.accounts },
          { name: "Leads", path: "/leads", icon: "UserPlus", key: "leads", isVisible: userSettings.menuVisibility.leads },
          { name: "Opportunities", path: "/opportunities", icon: "TrendingUp", key: "opportunities", isVisible: userSettings.menuVisibility.opportunities },
          { name: "Calendar", path: "/calendar", icon: "Calendar", key: "calendar", isVisible: userSettings.menuVisibility.calendar },
          { name: "Tasks", path: "/tasks", icon: "CheckSquare", key: "tasks", isVisible: userSettings.menuVisibility.tasks },
          { name: "Marketing", path: "/marketing", icon: "Megaphone", key: null, isVisible: true },
          { name: "Communication Center", path: "/communication-center", icon: "MessageSquare", key: "communicationCenter", isVisible: userSettings.menuVisibility.communicationCenter },
          { name: "Accounting", path: "/accounting", icon: "Calculator", key: "accounting", isVisible: userSettings.menuVisibility.accounting },
          { name: "Manufacturing", path: "/manufacturing", icon: "Factory", key: "Manufacturing", isVisible: true },
          { name: "Inventory", path: "/inventory", icon: "PackageOpen", key: "inventory", isVisible: userSettings.menuVisibility.inventory },
          { name: "Support Tickets", path: "/support-tickets", icon: "TicketCheck", key: "supportTickets", isVisible: userSettings.menuVisibility.supportTickets },
          { name: "E-commerce", path: "/ecommerce", icon: "ShoppingCart", key: "ecommerce", isVisible: userSettings.menuVisibility.ecommerce },
          { name: "Store", path: "/ecommerce-store", icon: "Store", key: "ecommerceStore", isVisible: userSettings.menuVisibility.ecommerceStore },
          { name: "Reports", path: "/reports", icon: "BarChart2", key: "reports", isVisible: userSettings.menuVisibility.reports },
          { name: "Intelligence", path: "/intelligence", icon: "BrainCircuit", key: "intelligence", isVisible: userSettings.menuVisibility.intelligence },
          { name: "Workflows", path: "/workflows", icon: "Workflow", key: "workflows", isVisible: userSettings.menuVisibility.workflows },
          { name: "Subscriptions", path: "/subscriptions", icon: "CreditCard", key: "subscriptions", isVisible: userSettings.menuVisibility.subscriptions },
          { name: "Training", path: "/training-help", icon: "HelpCircle", key: "training", isVisible: userSettings.menuVisibility.training },
          { name: "Settings", path: "/settings", icon: "Settings", key: null, isVisible: true }
        ];
        await db.insert(systemSettings).values({
          userId: null,
          // Global setting
          settingKey: "menuItems",
          settingValue: defaultMenuItems,
          scope: "global"
        });
        menuItems = defaultMenuItems;
      }
      res.json(menuItems);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/ai-assistant/business-insights", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const insights = await generateBusinessInsights();
      const insightsWithIds = insights.map((insight, index) => ({
        ...insight,
        id: index + 1,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
      res.json(insightsWithIds);
    } catch (error) {
      console.error("Error generating business insights:", error);
      if (error instanceof Error && error.message.includes("OpenAI")) {
        return handleOpenAIError(res, error);
      }
      handleError(res, error);
    }
  });
  app2.get("/api/ai-assistant/entity-advice/:entityType/:entityId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const { entityType, entityId } = req.params;
      const idNumber = parseInt(entityId);
      if (isNaN(idNumber)) {
        return res.status(400).json({ error: "Invalid entity ID" });
      }
      const validEntityTypes = ["lead", "opportunity", "contact", "task", "event"];
      if (!validEntityTypes.includes(entityType)) {
        return res.status(400).json({ error: "Invalid entity type" });
      }
      const advice = await getPersonalizedAdvice(entityType, idNumber);
      res.json(advice);
    } catch (error) {
      console.error("Error generating personalized advice:", error);
      if (error instanceof Error && error.message.includes("OpenAI")) {
        return handleOpenAIError(res, error);
      }
      handleError(res, error);
    }
  });
  const stripe = new Stripe2(process.env.STRIPE_SECRET_KEY || "");
  const apiRouter = app2.route("/api");
  const handleError = (res, error) => {
    console.error("API Error:", error);
    if (error instanceof Error) {
      console.error("Error stack trace:", error.stack);
    }
    try {
      console.error("Error details:", JSON.stringify(error, null, 2));
    } catch (jsonError) {
      console.error("Error cannot be stringified:", error);
    }
    if (error instanceof z4.ZodError) {
      return res.status(400).json({
        success: false,
        error: "Validation Error",
        message: "The provided data does not meet validation requirements",
        details: error.errors
      });
    }
    if (error && typeof error === "object" && "code" in error) {
      const pgError = error;
      console.error("Database error code:", pgError.code);
      if (pgError.code === "42P01") {
        return res.status(500).json({
          success: false,
          error: "Database Error",
          message: "Table not found. Database schema may be outdated or incomplete.",
          details: pgError.detail || pgError.message
        });
      }
      if (pgError.code.startsWith("23")) {
        return res.status(400).json({
          success: false,
          error: "Database Constraint Error",
          message: pgError.message || "Data violates database constraints",
          details: pgError.detail
        });
      }
    }
    return res.status(500).json({
      success: false,
      error: "Server Error",
      message: error instanceof Error ? error.message : "Unknown error",
      ...process.env.NODE_ENV !== "production" && error instanceof Error && {
        stack: error.stack
      }
    });
  };
  app2.get("/api/notifications", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      try {
        const tableExistsResult = await db.execute(sql5`
          SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'notifications'
          ) as exists
        `);
        if (!tableExistsResult.rows?.[0]?.exists) {
          console.log("Notifications table does not exist");
          return res.json([]);
        }
        const result = await db.execute(sql5`
          SELECT 
            id, 
            user_id as "userId",
            type,
            title,
            description,
            link,
            read::boolean as read,
            created_at as "createdAt"
          FROM notifications
          WHERE user_id = ${userId}
          ORDER BY created_at DESC
        `);
        const rows = result.rows || [];
        const userNotifications = rows.map((notification) => ({
          ...notification,
          read: notification.read === true
        }));
        res.json(userNotifications);
      } catch (error) {
        console.error("Error fetching notifications:", error);
        return res.json([]);
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/notifications/:id/read", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const userId = req.user.id;
      await db.execute(sql5`
        UPDATE notifications 
        SET read = TRUE 
        WHERE id = ${id} AND user_id = ${userId}
      `);
      res.json({ success: true, message: `Notification ${id} marked as read` });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/notifications/read-all", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      await db.execute(sql5`
        UPDATE notifications 
        SET read = TRUE 
        WHERE user_id = ${userId}
      `);
      res.json({ success: true, message: "All notifications marked as read" });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/messages", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      try {
        const tableExistsResult = await db.execute(sql5`
          SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'messages'
          ) as exists
        `);
        if (!tableExistsResult.rows?.[0]?.exists) {
          console.log("Messages table does not exist");
          return res.json([]);
        }
        const result = await db.execute(sql5`
          SELECT 
            m.id, 
            m.content, 
            m.read::boolean as read, 
            m.created_at as "createdAt", 
            m.urgent::boolean as urgent,
            u.id as "senderId", 
            u.first_name as "senderFirstName", 
            u.last_name as "senderLastName", 
            u.avatar as "senderAvatar"
          FROM messages m
          INNER JOIN users u ON m.sender_id = u.id
          WHERE m.recipient_id = ${userId}
          ORDER BY m.created_at DESC
        `);
        const rows = result.rows || [];
        const formattedMessages = rows.map((message) => {
          return {
            id: message.id,
            sender: {
              id: message.senderId,
              name: `${message.senderFirstName || ""} ${message.senderLastName || ""}`.trim(),
              avatar: message.senderAvatar
            },
            content: message.content,
            read: message.read === true,
            // Strict boolean comparison
            createdAt: message.createdAt ? new Date(String(message.createdAt)).toISOString() : null,
            urgent: message.urgent === true
          };
        });
        res.json(formattedMessages);
      } catch (error) {
        console.error("Error fetching messages:", error);
        return res.json([]);
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/messages/:id/read", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const userId = req.user.id;
      try {
        const tableExistsResult = await db.execute(sql5`
          SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'messages'
          ) as exists
        `);
        if (!tableExistsResult.rows?.[0]?.exists) {
          console.log("Messages table does not exist");
          return res.json({ success: true, message: `Message ${id} marked as read` });
        }
        await db.execute(sql5`
          UPDATE messages 
          SET read = TRUE 
          WHERE id = ${id} AND recipient_id = ${userId}
        `);
        res.json({ success: true, message: `Message ${id} marked as read` });
      } catch (error) {
        console.error("Error marking message as read:", error);
        return res.json({ success: true, message: `Message ${id} marked as read` });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/messages/read-all", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      try {
        const tableExistsResult = await db.execute(sql5`
          SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_name = 'messages'
          ) as exists
        `);
        if (!tableExistsResult.rows?.[0]?.exists) {
          console.log("Messages table does not exist");
          return res.json({ success: true, message: "All messages marked as read" });
        }
        await db.execute(sql5`
          UPDATE messages 
          SET read = TRUE 
          WHERE recipient_id = ${userId}
        `);
        res.json({ success: true, message: "All messages marked as read" });
      } catch (error) {
        console.error("Error marking all messages as read:", error);
        return res.json({ success: true, message: "All messages marked as read" });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/messages", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const { recipientId, content, urgent = false } = req.body;
      if (!recipientId || !content) {
        return res.status(400).json({ error: "Recipient and content are required" });
      }
      const recipient = await db.query.users.findFirst({
        where: eq14(users.id, recipientId)
      });
      if (!recipient) {
        return res.status(404).json({ error: "Recipient not found" });
      }
      const [newMessage] = await db.insert(messages).values({
        senderId: userId,
        recipientId,
        content,
        urgent: urgent || false,
        read: false
      }).returning();
      await db.insert(notifications).values({
        userId: recipientId,
        type: "message",
        title: "New Message",
        description: `You have a new message from ${req.user.firstName || ""} ${req.user.lastName || ""}`.trim(),
        read: false,
        link: "/communication-center"
      });
      res.status(201).json(newMessage);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/confirm-payment", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const { paymentIntentId } = req.body;
      if (!paymentIntentId) {
        return res.status(400).json({ error: "Payment intent ID required" });
      }
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      if (paymentIntent.status === "succeeded") {
        const subscriptions = await storage.getUserSubscriptions(req.user.id);
        const pendingSubscription = subscriptions.find(
          (sub) => sub.stripeSubscriptionId === paymentIntentId && sub.status === "Pending"
        );
        if (pendingSubscription) {
          await storage.updateUserSubscription(pendingSubscription.id, {
            status: "Active",
            stripeSubscriptionId: paymentIntentId
          });
          res.json({
            success: true,
            message: "Payment confirmed and subscription activated",
            status: "Active"
          });
        } else {
          res.status(404).json({ error: "Subscription not found" });
        }
      } else {
        res.status(400).json({
          error: "Payment not completed",
          status: paymentIntent.status
        });
      }
    } catch (error) {
      res.status(500).json({
        error: "Payment confirmation failed",
        message: error.message
      });
    }
  });
  app2.post("/api/make-admin", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const updatedUser = await storage.updateUser(userId, { role: "Admin" });
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/profile", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const { firstName, lastName, email, company, avatar } = req.body;
      const updateData = {};
      if (firstName !== void 0) updateData.firstName = firstName;
      if (lastName !== void 0) updateData.lastName = lastName;
      if (email !== void 0) updateData.email = email;
      if (company !== void 0) updateData.company = company;
      if (avatar !== void 0) updateData.avatar = avatar;
      console.log(`Processing profile update for user ${userId}`);
      const updatedUser = await storage.updateUser(userId, updateData);
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/users", async (req, res) => {
    try {
      const users2 = await storage.listUsers();
      res.json(users2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/users", async (req, res) => {
    try {
      if (req.user?.role !== "Admin") {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      const { username, password, email, firstName, lastName, role, isActive, avatar } = req.body;
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Username already exists" });
      }
      const hashedPassword = await hashPassword(password);
      const user = await storage.createUser({
        username,
        password: hashedPassword,
        email,
        firstName: firstName || null,
        lastName: lastName || null,
        role: role || "User",
        isActive: isActive !== void 0 ? isActive : true,
        avatar: avatar || null
      });
      res.status(200).json(user);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/users/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      if (req.user.id !== id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const userData = insertUserSchema.partial().parse(req.body);
      if (userData.role && req.user.role !== "Admin") {
        delete userData.role;
      }
      const updatedUser = await storage.updateUser(id, userData);
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/users/:id/password", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      if (req.user.id !== id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      if (!req.body.newPassword) {
        return res.status(400).json({ error: "New password is required" });
      }
      const password = await hashPassword(req.body.newPassword);
      const updatedUser = await storage.updateUser(id, { password });
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({ success: true, message: "Password updated successfully" });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/contacts", async (req, res) => {
    try {
      const contacts2 = await storage.listContacts();
      res.json(contacts2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/contacts", async (req, res) => {
    try {
      const contactData = insertContactSchema.parse(req.body);
      const contact = await storage.createContact(contactData);
      res.status(201).json(contact);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/contacts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const contact = await storage.getContact(id);
      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }
      res.json(contact);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/contacts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const contactData = insertContactSchema.partial().parse(req.body);
      const updatedContact = await storage.updateContact(id, contactData);
      if (!updatedContact) {
        return res.status(404).json({ error: "Contact not found" });
      }
      res.json(updatedContact);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/contacts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteContact(id);
      if (!success) {
        return res.status(404).json({ error: "Contact not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/accounts", async (req, res) => {
    try {
      const accounts2 = await storage.listAccounts();
      const decryptedAccounts = await decryptArrayFromDatabase(accounts2, "accounts");
      res.json(decryptedAccounts);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/accounts", async (req, res) => {
    try {
      const accountData = insertAccountSchema.parse(req.body);
      const encryptedAccountData = await encryptForDatabase(accountData, "accounts");
      console.log("[Encryption] Account data fields encrypted for database insertion");
      const account = await storage.createAccount(encryptedAccountData);
      const decryptedAccount = await decryptFromDatabase(account, "accounts");
      res.status(201).json(decryptedAccount);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/accounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const account = await storage.getAccount(id);
      if (!account) {
        return res.status(404).json({ error: "Account not found" });
      }
      const decryptedAccount = await decryptFromDatabase(account, "accounts");
      res.json(decryptedAccount);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/accounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Account Update] Updating account ${id} with data:`, req.body);
      const accountData = insertAccountSchema.partial().parse(req.body);
      const encryptedAccountData = await encryptForDatabase(accountData, "accounts");
      console.log("[Encryption] Account data fields encrypted for database update");
      const updatedAccount = await storage.updateAccount(id, encryptedAccountData);
      if (!updatedAccount) {
        console.error(`[Account Update] Account not found with id ${id}`);
        return res.status(404).json({ error: "Account not found" });
      }
      const decryptedAccount = await decryptFromDatabase(updatedAccount, "accounts");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Updated Account",
          detail: `Updated account: ${decryptedAccount.name}`,
          relatedToType: "account",
          relatedToId: id,
          icon: "edit"
        });
      }
      res.json(decryptedAccount);
    } catch (error) {
      console.error("[Account Update] Error updating account:", error);
      handleError(res, error);
    }
  });
  app2.delete("/api/accounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Account Delete] Deleting account ${id}`);
      const account = await storage.getAccount(id);
      if (!account) {
        console.error(`[Account Delete] Account not found with id ${id}`);
        return res.status(404).json({ error: "Account not found" });
      }
      const decryptedAccount = await decryptFromDatabase(account, "accounts");
      const success = await storage.deleteAccount(id);
      if (!success) {
        return res.status(404).json({ error: "Account could not be deleted" });
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Deleted Account",
          detail: `Deleted account: ${decryptedAccount.name}`,
          relatedToType: "account",
          relatedToId: id,
          icon: "trash"
        });
      }
      res.status(204).end();
    } catch (error) {
      console.error("[Account Delete] Error deleting account:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/leads", async (req, res) => {
    try {
      console.log("[Leads] Fetching all leads");
      const leads2 = await storage.listLeads();
      const decryptedLeads = await decryptArrayFromDatabase(leads2, "leads");
      console.log(`[Leads] Successfully decrypted ${decryptedLeads.length} leads`);
      res.json(decryptedLeads);
    } catch (error) {
      console.error("[Leads] Error fetching leads:", error);
      handleError(res, error);
    }
  });
  app2.post("/api/leads", async (req, res) => {
    try {
      console.log("[Lead Create] Creating new lead with data:", req.body);
      const leadData = insertLeadSchema.parse(req.body);
      const encryptedData = await encryptForDatabase(leadData, "leads");
      console.log("[Encryption] Lead data fields encrypted for database storage");
      const lead = await storage.createLead(encryptedData);
      const decryptedLead = await decryptFromDatabase(lead, "leads");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Created Lead",
          detail: `Created new lead: ${decryptedLead.firstName} ${decryptedLead.lastName}`,
          relatedToType: "lead",
          relatedToId: decryptedLead.id,
          icon: "plus"
        });
      }
      res.status(201).json(decryptedLead);
    } catch (error) {
      console.error("[Lead Create] Error creating lead:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/leads/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Lead Get] Fetching lead with id ${id}`);
      const lead = await storage.getLead(id);
      if (!lead) {
        console.error(`[Lead Get] Lead not found with id ${id}`);
        return res.status(404).json({ error: "Lead not found" });
      }
      const decryptedLead = await decryptFromDatabase(lead, "leads");
      console.log("[Lead Get] Successfully decrypted lead data");
      res.json(decryptedLead);
    } catch (error) {
      console.error("[Lead Get] Error fetching lead:", error);
      handleError(res, error);
    }
  });
  app2.patch("/api/leads/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Lead Update] Updating lead ${id} with data:`, req.body);
      const currentLead = await storage.getLead(id);
      if (!currentLead) {
        console.error(`[Lead Update] Lead not found with id ${id}`);
        return res.status(404).json({ error: "Lead not found" });
      }
      const leadData = insertLeadSchema.partial().parse(req.body);
      const encryptedData = await encryptForDatabase(leadData, "leads");
      console.log("[Encryption] Lead data fields encrypted for database update");
      const updatedLead = await storage.updateLead(id, encryptedData);
      if (!updatedLead) {
        return res.status(404).json({ error: "Lead not found after update" });
      }
      const decryptedLead = await decryptFromDatabase(updatedLead, "leads");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Updated Lead",
          detail: `Updated lead: ${decryptedLead.firstName} ${decryptedLead.lastName}`,
          relatedToType: "lead",
          relatedToId: id,
          icon: "edit"
        });
      }
      res.json(decryptedLead);
    } catch (error) {
      console.error("[Lead Update] Error updating lead:", error);
      handleError(res, error);
    }
  });
  app2.delete("/api/leads/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Lead Delete] Deleting lead ${id}`);
      const lead = await storage.getLead(id);
      if (!lead) {
        console.error(`[Lead Delete] Lead not found with id ${id}`);
        return res.status(404).json({ error: "Lead not found" });
      }
      const decryptedLead = await decryptFromDatabase(lead, "leads");
      const success = await storage.deleteLead(id);
      if (!success) {
        return res.status(404).json({ error: "Lead could not be deleted" });
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Deleted Lead",
          detail: `Deleted lead: ${decryptedLead.firstName} ${decryptedLead.lastName}`,
          relatedToType: "lead",
          relatedToId: id,
          icon: "trash"
        });
      }
      res.status(204).end();
    } catch (error) {
      console.error("[Lead Delete] Error deleting lead:", error);
      handleError(res, error);
    }
  });
  app2.post("/api/leads/:id/convert", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Lead Convert] Converting lead ${id} with data:`, req.body);
      const { contact, account, opportunity } = req.body;
      const validatedData = {};
      if (contact) {
        const validatedContact = insertContactSchema.parse(contact);
        validatedData.contact = await encryptForDatabase(validatedContact, "contacts");
        console.log("[Encryption] Contact data fields encrypted for database storage");
      }
      if (account) {
        const validatedAccount = insertAccountSchema.parse(account);
        validatedData.account = await encryptForDatabase(validatedAccount, "accounts");
        console.log("[Encryption] Account data fields encrypted for database storage");
      }
      if (opportunity) {
        const validatedOpportunity = insertOpportunitySchema.parse(opportunity);
        validatedData.opportunity = await encryptForDatabase(validatedOpportunity, "opportunities");
        console.log("[Encryption] Opportunity data fields encrypted for database storage");
      }
      const leadBeforeConversion = await storage.getLead(id);
      if (!leadBeforeConversion) {
        console.error(`[Lead Convert] Lead not found with id ${id}`);
        return res.status(404).json({ error: "Lead not found" });
      }
      const decryptedLead = await decryptFromDatabase(leadBeforeConversion, "leads");
      const result = await storage.convertLead(id, validatedData);
      let decryptedResult = { ...result };
      if (result.contact) {
        decryptedResult.contact = await decryptFromDatabase(result.contact, "contacts");
      }
      if (result.account) {
        decryptedResult.account = await decryptFromDatabase(result.account, "accounts");
      }
      if (result.opportunity) {
        decryptedResult.opportunity = await decryptFromDatabase(result.opportunity, "opportunities");
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Converted Lead",
          detail: `Converted lead: ${decryptedLead.firstName} ${decryptedLead.lastName}`,
          relatedToType: "lead",
          relatedToId: id,
          icon: "refresh-cw"
        });
      }
      res.json(decryptedResult);
    } catch (error) {
      console.error("[Lead Convert] Error converting lead:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/opportunities", async (req, res) => {
    try {
      const opportunities2 = await storage.listOpportunities();
      res.json(opportunities2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/opportunities", async (req, res) => {
    try {
      console.log("[Opportunity Create] Creating new opportunity with data:", req.body);
      const opportunityData = insertOpportunitySchema.parse(req.body);
      const encryptedData = await encryptForDatabase(opportunityData, "opportunities");
      console.log("[Encryption] Opportunity data fields encrypted for database storage");
      const opportunity = await storage.createOpportunity(encryptedData);
      const decryptedOpportunity = await decryptFromDatabase(opportunity, "opportunities");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Created Opportunity",
          detail: `Created new opportunity: ${decryptedOpportunity.name}`,
          relatedToType: "opportunity",
          relatedToId: decryptedOpportunity.id,
          icon: "plus"
        });
      }
      res.status(201).json(decryptedOpportunity);
    } catch (error) {
      console.error("[Opportunity Create] Error creating opportunity:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/opportunities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const opportunity = await storage.getOpportunity(id);
      if (!opportunity) {
        return res.status(404).json({ error: "Opportunity not found" });
      }
      res.json(opportunity);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/opportunities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Opportunity Update] Updating opportunity ${id} with data:`, req.body);
      const currentOpportunity = await storage.getOpportunity(id);
      if (!currentOpportunity) {
        console.error(`[Opportunity Update] Opportunity not found with id ${id}`);
        return res.status(404).json({ error: "Opportunity not found" });
      }
      const opportunityData = insertOpportunitySchema.partial().parse(req.body);
      const encryptedData = await encryptForDatabase(opportunityData, "opportunities");
      console.log("[Encryption] Opportunity data fields encrypted for database update");
      const updatedOpportunity = await storage.updateOpportunity(id, encryptedData);
      if (!updatedOpportunity) {
        return res.status(404).json({ error: "Opportunity not found after update" });
      }
      const decryptedOpportunity = await decryptFromDatabase(updatedOpportunity, "opportunities");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Updated Opportunity",
          detail: `Updated opportunity: ${decryptedOpportunity.name}`,
          relatedToType: "opportunity",
          relatedToId: id,
          icon: "edit"
        });
      }
      res.json(decryptedOpportunity);
    } catch (error) {
      console.error("[Opportunity Update] Error updating opportunity:", error);
      handleError(res, error);
    }
  });
  app2.delete("/api/opportunities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Opportunity Delete] Deleting opportunity ${id}`);
      const opportunity = await storage.getOpportunity(id);
      if (!opportunity) {
        console.error(`[Opportunity Delete] Opportunity not found with id ${id}`);
        return res.status(404).json({ error: "Opportunity not found" });
      }
      const decryptedOpportunity = await decryptFromDatabase(opportunity, "opportunities");
      const success = await storage.deleteOpportunity(id);
      if (!success) {
        return res.status(404).json({ error: "Opportunity could not be deleted" });
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Deleted Opportunity",
          detail: `Deleted opportunity: ${decryptedOpportunity.name}`,
          relatedToType: "opportunity",
          relatedToId: id,
          icon: "trash"
        });
      }
      res.status(204).end();
    } catch (error) {
      console.error("[Opportunity Delete] Error deleting opportunity:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/tasks", async (req, res) => {
    try {
      const tasks2 = await storage.listTasks();
      res.json(tasks2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/tasks/reminders", async (req, res) => {
    try {
      const { relatedToType, relatedToId } = req.query;
      if (!relatedToType || !relatedToId) {
        return res.status(400).json({ error: "Missing relatedToType or relatedToId parameters" });
      }
      const entityId = parseInt(relatedToId);
      if (isNaN(entityId)) {
        return res.status(400).json({ error: "Invalid relatedToId parameter" });
      }
      const tasks2 = await storage.listTasks();
      const reminders = tasks2.filter(
        (task) => task.isReminder && task.relatedToType === relatedToType && task.relatedToId === entityId
      );
      res.json(reminders);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/tasks", async (req, res) => {
    try {
      console.log("[Task Create] Creating new task with data:", req.body);
      const taskData = insertTaskSchema.parse(req.body);
      const encryptedData = await encryptForDatabase(taskData, "tasks");
      console.log("[Encryption] Task data fields encrypted for database storage");
      if (typeof encryptedData.dueDate === "string" && encryptedData.dueDate) {
        encryptedData.dueDate = new Date(encryptedData.dueDate);
      }
      if (typeof encryptedData.reminderDate === "string" && encryptedData.reminderDate) {
        encryptedData.reminderDate = new Date(encryptedData.reminderDate);
      }
      const task = await storage.createTask(encryptedData);
      const decryptedTask = await decryptFromDatabase(task, "tasks");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Created Task",
          detail: `Created new task: ${decryptedTask.title}`,
          relatedToType: "task",
          relatedToId: decryptedTask.id,
          icon: "plus"
        });
      }
      res.status(201).json(decryptedTask);
    } catch (error) {
      console.error("[Task Create] Error creating task:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/tasks/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const task = await storage.getTask(id);
      if (!task) {
        return res.status(404).json({ error: "Task not found" });
      }
      res.json(task);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/tasks/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Task Update] Updating task ${id} with data:`, req.body);
      const currentTask = await storage.getTask(id);
      if (!currentTask) {
        console.error(`[Task Update] Task not found with id ${id}`);
        return res.status(404).json({ error: "Task not found" });
      }
      const taskData = insertTaskSchema.partial().parse(req.body);
      const encryptedData = await encryptForDatabase(taskData, "tasks");
      console.log("[Encryption] Task data fields encrypted for database update");
      if (typeof encryptedData.dueDate === "string" && encryptedData.dueDate) {
        encryptedData.dueDate = new Date(encryptedData.dueDate);
      }
      if (typeof encryptedData.reminderDate === "string" && encryptedData.reminderDate) {
        encryptedData.reminderDate = new Date(encryptedData.reminderDate);
      }
      const updatedTask = await storage.updateTask(id, encryptedData);
      if (!updatedTask) {
        return res.status(404).json({ error: "Task not found after update" });
      }
      const decryptedTask = await decryptFromDatabase(updatedTask, "tasks");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Updated Task",
          detail: `Updated task: ${decryptedTask.title}`,
          relatedToType: "task",
          relatedToId: id,
          icon: "edit"
        });
      }
      res.json(decryptedTask);
    } catch (error) {
      console.error("[Task Update] Error updating task:", error);
      handleError(res, error);
    }
  });
  app2.delete("/api/tasks/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Task Delete] Deleting task ${id}`);
      const task = await storage.getTask(id);
      if (!task) {
        console.error(`[Task Delete] Task not found with id ${id}`);
        return res.status(404).json({ error: "Task not found" });
      }
      const decryptedTask = await decryptFromDatabase(task, "tasks");
      const success = await storage.deleteTask(id);
      if (!success) {
        return res.status(404).json({ error: "Task could not be deleted" });
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Deleted Task",
          detail: `Deleted task: ${decryptedTask.title}`,
          relatedToType: "task",
          relatedToId: id,
          icon: "trash"
        });
      }
      res.status(204).end();
    } catch (error) {
      console.error("[Task Delete] Error deleting task:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/events", async (req, res) => {
    try {
      console.log("[Events] Fetching all events");
      const events2 = await storage.listEvents();
      const decryptedEvents = await decryptArrayFromDatabase(events2, "events");
      console.log(`[Events] Successfully decrypted ${decryptedEvents.length} events`);
      res.json(decryptedEvents);
    } catch (error) {
      console.error("[Events] Error fetching events:", error);
      handleError(res, error);
    }
  });
  app2.post("/api/events", async (req, res) => {
    try {
      console.log("[Event Create] Creating new event with data:", req.body);
      const eventData = insertEventSchema.parse(req.body);
      const encryptedData = await encryptForDatabase(eventData, "events");
      console.log("[Encryption] Event data fields encrypted for database storage");
      if (typeof encryptedData.startDate === "string" && encryptedData.startDate) {
        encryptedData.startDate = new Date(encryptedData.startDate);
      }
      if (typeof encryptedData.endDate === "string" && encryptedData.endDate) {
        encryptedData.endDate = new Date(encryptedData.endDate);
      }
      const event = await storage.createEvent(encryptedData);
      const decryptedEvent = await decryptFromDatabase(event, "events");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Created Event",
          detail: `Created new event: ${decryptedEvent.title}`,
          relatedToType: "event",
          relatedToId: decryptedEvent.id,
          icon: "calendar-plus"
        });
      }
      res.status(201).json(decryptedEvent);
    } catch (error) {
      console.error("[Event Create] Error creating event:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Event Get] Fetching event with id ${id}`);
      const event = await storage.getEvent(id);
      if (!event) {
        console.error(`[Event Get] Event not found with id ${id}`);
        return res.status(404).json({ error: "Event not found" });
      }
      const decryptedEvent = await decryptFromDatabase(event, "events");
      console.log("[Event Get] Successfully decrypted event data");
      res.json(decryptedEvent);
    } catch (error) {
      console.error("[Event Get] Error fetching event:", error);
      handleError(res, error);
    }
  });
  app2.patch("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Event Update] Updating event ${id} with data:`, req.body);
      const currentEvent = await storage.getEvent(id);
      if (!currentEvent) {
        console.error(`[Event Update] Event not found with id ${id}`);
        return res.status(404).json({ error: "Event not found" });
      }
      const eventData = insertEventSchema.partial().parse(req.body);
      const encryptedData = await encryptForDatabase(eventData, "events");
      console.log("[Encryption] Event data fields encrypted for database update");
      if (typeof encryptedData.startDate === "string" && encryptedData.startDate) {
        encryptedData.startDate = new Date(encryptedData.startDate);
      }
      if (typeof encryptedData.endDate === "string" && encryptedData.endDate) {
        encryptedData.endDate = new Date(encryptedData.endDate);
      }
      const updatedEvent = await storage.updateEvent(id, encryptedData);
      if (!updatedEvent) {
        return res.status(404).json({ error: "Event not found after update" });
      }
      const decryptedEvent = await decryptFromDatabase(updatedEvent, "events");
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Updated Event",
          detail: `Updated event: ${decryptedEvent.title}`,
          relatedToType: "event",
          relatedToId: id,
          icon: "edit-calendar"
        });
      }
      res.json(decryptedEvent);
    } catch (error) {
      console.error("[Event Update] Error updating event:", error);
      handleError(res, error);
    }
  });
  app2.delete("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`[Event Delete] Deleting event ${id}`);
      const event = await storage.getEvent(id);
      if (!event) {
        console.error(`[Event Delete] Event not found with id ${id}`);
        return res.status(404).json({ error: "Event not found" });
      }
      const decryptedEvent = await decryptFromDatabase(event, "events");
      const success = await storage.deleteEvent(id);
      if (!success) {
        return res.status(404).json({ error: "Event could not be deleted" });
      }
      if (req.user) {
        await storage.createActivity({
          userId: req.user.id,
          action: "Deleted Event",
          detail: `Deleted event: ${decryptedEvent.title}`,
          relatedToType: "event",
          relatedToId: id,
          icon: "calendar-x"
        });
      }
      res.status(204).end();
    } catch (error) {
      console.error("[Event Delete] Error deleting event:", error);
      handleError(res, error);
    }
  });
  app2.get("/api/activities", async (req, res) => {
    try {
      const activities2 = await storage.listActivities();
      res.json(activities2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/activities", async (req, res) => {
    try {
      const activityData = insertActivitySchema.parse(req.body);
      const activity = await storage.createActivity(activityData);
      res.status(201).json(activity);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/activities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const activity = await storage.getActivity(id);
      if (!activity) {
        return res.status(404).json({ error: "Activity not found" });
      }
      res.json(activity);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/dashboard/stats", async (req, res) => {
    try {
      const stats = await storage.getDashboardStats();
      res.json(stats);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/dashboard/pipeline", async (req, res) => {
    try {
      const pipeline = await storage.getSalesPipeline();
      res.json(pipeline);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/reports/sales", async (req, res) => {
    try {
      const timeRange = req.query.timeRange || "month";
      const report = await storage.getSalesReport(timeRange);
      const responseData = {
        ...report,
        _requestTime: (/* @__PURE__ */ new Date()).toISOString(),
        _timeRange: timeRange
      };
      res.json(responseData);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/reports/leads", async (req, res) => {
    try {
      const timeRange = req.query.timeRange || "month";
      const report = await storage.getLeadsReport(timeRange);
      const responseData = {
        ...report,
        _requestTime: (/* @__PURE__ */ new Date()).toISOString(),
        _timeRange: timeRange
      };
      res.json(responseData);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/reports/conversion", async (req, res) => {
    try {
      const timeRange = req.query.timeRange || "month";
      const report = await storage.getConversionReport(timeRange);
      const responseData = {
        ...report,
        _requestTime: (/* @__PURE__ */ new Date()).toISOString(),
        _timeRange: timeRange
      };
      res.json(responseData);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/reports/performance", async (req, res) => {
    try {
      const timeRange = req.query.timeRange || "month";
      const report = await storage.getTeamPerformanceReport(timeRange);
      const responseData = {
        ...report,
        _requestTime: (/* @__PURE__ */ new Date()).toISOString(),
        _timeRange: timeRange
      };
      res.json(responseData);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/ai/analyze", async (req, res) => {
    try {
      const { prompt, context, type } = req.body;
      if (!prompt) {
        return res.status(400).json({ error: "Missing required field: prompt" });
      }
      const result = await generateAnalysis({
        prompt,
        context,
        type
      });
      return res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/ai/insights", async (req, res) => {
    try {
      const { data, type } = req.body;
      if (!data) {
        return res.status(400).json({ error: "Missing required field: data" });
      }
      const result = await generateInsights({
        data,
        type: type || "all"
      });
      return res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/ai/recommendations", async (req, res) => {
    try {
      const { entityType, entityData } = req.body;
      if (!entityType) {
        return res.status(400).json({ error: "Missing required field: entityType" });
      }
      let contextData = entityData;
      if (!contextData) {
        try {
          const entityId = req.body.entityId;
          switch (entityType) {
            case "lead":
              if (entityId) {
                contextData = await storage.getLead(parseInt(entityId));
              } else {
                contextData = await storage.listLeads();
              }
              break;
            case "opportunity":
              if (entityId) {
                contextData = await storage.getOpportunity(parseInt(entityId));
              } else {
                contextData = await storage.listOpportunities();
              }
              break;
            case "contact":
              if (entityId) {
                contextData = await storage.getContact(parseInt(entityId));
              } else {
                contextData = await storage.listContacts();
              }
              break;
            default:
              contextData = {
                message: "No specific entity requested."
              };
          }
        } catch (dataError) {
          console.error("Error fetching data for AI recommendations:", dataError);
          contextData = { error: "Failed to fetch context data" };
        }
      }
      const result = await generateRecommendations({
        entityType,
        entityData: contextData
      });
      return res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/ai/email-template", async (req, res) => {
    try {
      const { emailType, contactInfo, dealInfo, additionalContext } = req.body;
      if (!emailType || !contactInfo) {
        return res.status(400).json({
          error: "Missing required fields",
          details: "Both emailType and contactInfo are required"
        });
      }
      const result = await generateEmailTemplate(
        emailType,
        contactInfo,
        dealInfo,
        additionalContext
      );
      return res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/ai/summarize-meeting", async (req, res) => {
    try {
      const { transcript, meetingContext } = req.body;
      if (!transcript) {
        return res.status(400).json({
          error: "Missing required field",
          details: "Transcript is required"
        });
      }
      const result = await summarizeMeeting(transcript, meetingContext);
      return res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/subscription-packages", async (req, res) => {
    try {
      const packages = await storage.listSubscriptionPackages();
      res.json(packages);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/subscription-packages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const package_ = await storage.getSubscriptionPackage(id);
      if (!package_) {
        return res.status(404).json({ error: "Subscription package not found" });
      }
      res.json(package_);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/subscription-packages", async (req, res) => {
    try {
      const packageData = insertSubscriptionPackageSchema.parse(req.body);
      const package_ = await storage.createSubscriptionPackage(packageData);
      res.status(201).json(package_);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/subscription-packages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const packageData = insertSubscriptionPackageSchema.partial().parse(req.body);
      const updatedPackage = await storage.updateSubscriptionPackage(id, packageData);
      if (!updatedPackage) {
        return res.status(404).json({ error: "Subscription package not found" });
      }
      res.json(updatedPackage);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/subscription-packages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteSubscriptionPackage(id);
      if (!success) {
        return res.status(404).json({ error: "Subscription package not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/user-subscriptions", async (req, res) => {
    try {
      const subscriptions = await storage.listUserSubscriptions();
      res.json(subscriptions);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/user-subscriptions/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const subscription = await storage.getUserSubscription(id);
      if (!subscription) {
        return res.status(404).json({ error: "User subscription not found" });
      }
      res.json(subscription);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/users/:userId/active-subscription", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const subscription = await storage.getUserActiveSubscription(userId);
      if (!subscription) {
        return res.status(404).json({ error: "No active subscription found for this user" });
      }
      res.json(subscription);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/cancel-subscription/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const subscriptionId = parseInt(req.params.id);
      const subscription = await storage.getUserSubscription(subscriptionId);
      if (!subscription) {
        return res.status(404).json({ error: "Subscription not found" });
      }
      if (subscription.userId !== req.user?.id) {
        return res.status(403).json({ error: "Unauthorized to cancel this subscription" });
      }
      const updatedSubscription = await storage.updateUserSubscription(subscriptionId, {
        status: "Canceled",
        canceledAt: /* @__PURE__ */ new Date()
      });
      if (!updatedSubscription) {
        return res.status(500).json({ error: "Failed to cancel subscription" });
      }
      res.json({
        success: true,
        message: "Subscription canceled successfully",
        subscription: updatedSubscription
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/user-subscriptions", async (req, res) => {
    try {
      const subscriptionData = insertUserSubscriptionSchema.parse(req.body);
      const subscription = await storage.createUserSubscription(subscriptionData);
      res.status(201).json(subscription);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/user-subscriptions/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const subscriptionData = insertUserSubscriptionSchema.partial().parse(req.body);
      const updatedSubscription = await storage.updateUserSubscription(id, subscriptionData);
      if (!updatedSubscription) {
        return res.status(404).json({ error: "User subscription not found" });
      }
      res.json(updatedSubscription);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/user-subscriptions/:id/cancel", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const subscription = await storage.getUserSubscription(id);
      if (!subscription) {
        return res.status(404).json({ error: "User subscription not found" });
      }
      if (subscription.stripeSubscriptionId) {
        try {
          await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);
        } catch (stripeError) {
          console.error("Error canceling Stripe subscription:", stripeError);
        }
      }
      const canceledSubscription = await storage.cancelUserSubscription(id);
      if (!canceledSubscription) {
        return res.status(404).json({ error: "User subscription not found" });
      }
      res.json(canceledSubscription);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/create-payment-intent", async (req, res) => {
    try {
      const { amount, planId, planName } = req.body;
      const numericAmount = parseFloat(amount);
      if (numericAmount === 0) {
        return res.json({
          clientSecret: null,
          requiresPayment: false,
          message: "No payment required for zero amount"
        });
      }
      if (!amount || isNaN(numericAmount) || numericAmount < 0) {
        return res.status(400).json({
          error: "Invalid amount",
          details: "Amount must be a non-negative number. Current amount: " + amount
        });
      }
      const metadata = {
        amount: numericAmount.toString(),
        type: "subscription"
      };
      if (planId) {
        metadata.planId = planId.toString();
      }
      if (planName) {
        metadata.planName = planName;
      }
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(numericAmount * 100),
        // Convert to cents
        currency: "usd",
        metadata,
        description: planName ? `Subscription to ${planName} Plan` : "Subscription Payment"
      });
      res.json({
        clientSecret: paymentIntent.client_secret,
        requiresPayment: true
      });
    } catch (error) {
      res.status(500).json({
        error: "Stripe Error",
        message: error.message
      });
    }
  });
  app2.post("/api/create-subscription", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const { packageId, paymentMethod } = req.body;
      const userId = req.user.id;
      if (!packageId) {
        return res.status(400).json({
          error: "Invalid input",
          details: "Package ID is required"
        });
      }
      const user = req.user;
      const package_ = await storage.getSubscriptionPackage(packageId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      if (!package_) {
        return res.status(404).json({ error: "Subscription package not found" });
      }
      if (paymentMethod === "stripe") {
        console.log("=== Creating Stripe Payment Intent ===");
        console.log("Package:", package_);
        console.log("User ID:", userId);
        console.log("Package ID:", packageId);
        const amount = parseFloat(package_.price);
        console.log("Parsed amount:", amount);
        if (isNaN(amount) || amount <= 0) {
          console.error("Invalid amount:", amount);
          return res.status(400).json({
            error: "Invalid package price",
            details: "Package price must be a positive number"
          });
        }
        console.log("Creating Stripe payment intent with amount:", Math.round(amount * 100), "cents");
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(amount * 100),
          // Convert to cents
          currency: "usd",
          metadata: {
            packageId: packageId.toString(),
            userId: userId.toString(),
            packageName: package_.name
          }
        });
        console.log("Payment intent created:", paymentIntent.id);
        console.log("Client secret:", paymentIntent.client_secret);
        const currentDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setMonth(endDate.getMonth() + 1);
        const userSubscription = await storage.createUserSubscription({
          userId,
          packageId,
          stripeSubscriptionId: paymentIntent.id,
          // Store payment intent ID temporarily
          status: "Pending",
          startDate: currentDate,
          endDate,
          currentPeriodStart: currentDate,
          currentPeriodEnd: endDate,
          canceledAt: null,
          trialEndsAt: null
        });
        res.json({
          clientSecret: paymentIntent.client_secret,
          paymentIntentId: paymentIntent.id,
          userSubscriptionId: userSubscription.id,
          requiresPayment: true
        });
      } else if (paymentMethod === "paypal") {
        const currentDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setMonth(endDate.getMonth() + 1);
        const userSubscription = await storage.createUserSubscription({
          userId,
          packageId,
          stripeSubscriptionId: null,
          status: "Active",
          startDate: currentDate,
          endDate,
          currentPeriodStart: currentDate,
          currentPeriodEnd: endDate,
          canceledAt: null,
          trialEndsAt: null
        });
        res.json({
          success: true,
          message: "Subscription created successfully with PayPal",
          userSubscriptionId: userSubscription.id,
          status: "Active",
          paymentMethod: "paypal"
        });
      } else if (paymentMethod === "google-pay") {
        const currentDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setMonth(endDate.getMonth() + 1);
        const userSubscription = await storage.createUserSubscription({
          userId,
          packageId,
          stripeSubscriptionId: null,
          status: "Active",
          startDate: currentDate,
          endDate,
          currentPeriodStart: currentDate,
          currentPeriodEnd: endDate,
          canceledAt: null,
          trialEndsAt: null
        });
        res.json({
          success: true,
          message: "Subscription created successfully with Google Pay",
          userSubscriptionId: userSubscription.id,
          status: "Active",
          paymentMethod: "google-pay"
        });
      } else {
        const currentDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setMonth(endDate.getMonth() + 1);
        const userSubscription = await storage.createUserSubscription({
          userId,
          packageId,
          stripeSubscriptionId: null,
          status: "Active",
          startDate: currentDate,
          endDate,
          currentPeriodStart: currentDate,
          currentPeriodEnd: endDate,
          canceledAt: null,
          trialEndsAt: null
        });
        res.json({
          success: true,
          message: "Subscription created successfully",
          userSubscriptionId: userSubscription.id,
          status: "Active"
        });
      }
    } catch (error) {
      res.status(500).json({
        error: "Subscription Error",
        message: error.message
      });
    }
  });
  app2.post("/api/confirm-payment", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const { paymentIntentId } = req.body;
      if (!paymentIntentId) {
        return res.status(400).json({
          error: "Invalid input",
          details: "Payment Intent ID is required"
        });
      }
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      if (paymentIntent.status !== "succeeded") {
        return res.status(400).json({
          error: "Payment not completed",
          details: "Payment must be successful before confirming subscription"
        });
      }
      const packageId = parseInt(paymentIntent.metadata.packageId);
      const userId = parseInt(paymentIntent.metadata.userId);
      if (!packageId || !userId || userId !== req.user.id) {
        return res.status(400).json({
          error: "Invalid payment",
          details: "Payment metadata does not match current user"
        });
      }
      const userSubscriptions3 = await storage.listUserSubscriptions();
      const pendingSubscription = userSubscriptions3.find(
        (sub) => sub.userId === userId && sub.packageId === packageId && sub.status === "Pending" && sub.stripeSubscriptionId === paymentIntentId
      );
      if (!pendingSubscription) {
        return res.status(404).json({
          error: "Subscription not found",
          details: "No pending subscription found for this payment"
        });
      }
      const updatedSubscription = await storage.updateUserSubscription(pendingSubscription.id, {
        status: "Active",
        stripeSubscriptionId: paymentIntentId,
        currentPeriodStart: /* @__PURE__ */ new Date(),
        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3)
        // 30 days from now
      });
      res.json({
        success: true,
        message: "Subscription activated successfully",
        subscription: updatedSubscription
      });
    } catch (error) {
      console.error("Payment confirmation error:", error);
      res.status(500).json({
        error: "Payment Confirmation Error",
        message: error.message || "Failed to confirm payment"
      });
    }
  });
  app2.post("/api/webhook", async (req, res) => {
    const signature = req.headers["stripe-signature"];
    try {
      if (!process.env.STRIPE_WEBHOOK_SECRET) {
        console.warn("Missing Stripe webhook secret, skipping signature verification");
        return res.status(200).end();
      }
      const event = stripe.webhooks.constructEvent(
        req.body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET
      );
      switch (event.type) {
        case "invoice.payment_succeeded":
          const invoice = event.data.object;
          const subscriptionId = invoice.subscription;
          const userSubscription = await storage.listUserSubscriptions({
            stripeSubscriptionId: subscriptionId
          });
          if (userSubscription.length > 0) {
            await storage.updateUserSubscription(userSubscription[0].id, {
              status: "Active",
              currentPeriodStart: /* @__PURE__ */ new Date(),
              currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3)
              // 30 days
            });
          }
          break;
        case "customer.subscription.updated":
          const subscription = event.data.object;
          const userSubs = await storage.listUserSubscriptions({
            stripeSubscriptionId: subscription.id
          });
          if (userSubs.length > 0) {
            let status = null;
            switch (subscription.status) {
              case "active":
                status = "Active";
                break;
              case "canceled":
                status = "Canceled";
                break;
              case "past_due":
              case "unpaid":
                status = "Expired";
                break;
              case "trialing":
                status = "Trial";
                break;
              default:
                status = "Pending";
            }
            if (status) {
              await storage.updateUserSubscription(userSubs[0].id, { status });
            }
          }
          break;
      }
      res.status(200).end();
    } catch (error) {
      console.error("Webhook error:", error.message);
      res.status(400).json({ error: error.message });
    }
  });
  app2.get("/api/paypal/setup", async (req, res) => {
    await loadPaypalDefault(req, res);
  });
  app2.post("/api/paypal/order", async (req, res) => {
    await createPaypalOrder(req, res);
  });
  app2.post("/api/paypal/order/:orderID/capture", async (req, res) => {
    await capturePaypalOrder(req, res);
  });
  app2.get("/paypal/setup", async (req, res) => {
    await loadPaypalDefault(req, res);
  });
  app2.post("/paypal/order", async (req, res) => {
    await createPaypalOrder(req, res);
  });
  app2.post("/paypal/order/:orderID/capture", async (req, res) => {
    await capturePaypalOrder(req, res);
  });
  app2.get("/paypal/return", async (req, res) => {
    const { token, PayerID } = req.query;
    if (token && PayerID) {
      try {
        const captureResponse = await fetch(`${req.protocol}://${req.get("host")}/paypal/order/${token}/capture`, {
          method: "POST",
          headers: { "Content-Type": "application/json" }
        });
        const captureData = await captureResponse.json();
        if (captureData.status === "COMPLETED") {
          res.redirect("/?payment=success&provider=paypal");
        } else {
          res.redirect("/?payment=error&provider=paypal");
        }
      } catch (error) {
        console.error("PayPal capture error:", error);
        res.redirect("/?payment=error&provider=paypal");
      }
    } else {
      res.redirect("/?payment=cancelled&provider=paypal");
    }
  });
  app2.get("/paypal/cancel", async (req, res) => {
    res.redirect("/?payment=cancelled&provider=paypal");
  });
  app2.get("/api/social-integrations", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const integrations = await storage.getUserSocialIntegrations(userId);
      res.json(integrations);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/social-integrations", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userId = req.user.id;
      const integrationData = {
        ...req.body,
        userId
      };
      const integration = await storage.createSocialIntegration(integrationData);
      res.status(201).json(integration);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/social-integrations/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const integration = await storage.getSocialIntegration(id);
      if (!integration) {
        return res.status(404).json({ error: "Social integration not found" });
      }
      if (integration.userId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to access this integration" });
      }
      res.json(integration);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/social-integrations/:id/test", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const integration = await storage.getSocialIntegration(id);
      if (!integration) {
        return res.status(404).json({ error: "Social integration not found" });
      }
      if (integration.userId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to test this integration" });
      }
      try {
        switch (integration.platform) {
          case "Facebook":
          case "Instagram":
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing Facebook access token" });
            }
            const fbResponse = await fetch(`https://graph.facebook.com/v18.0/me?fields=id,name&access_token=${integration.accessToken}`, {
              method: "GET",
              headers: { "Content-Type": "application/json" }
            });
            if (!fbResponse.ok) {
              const fbError = await fbResponse.json();
              return res.status(400).json({
                error: "Facebook API test failed",
                details: fbError.error?.message || "Unknown error"
              });
            }
            const fbData = await fbResponse.json();
            return res.json({
              success: true,
              message: `Successfully connected to Facebook as ${fbData.name}`,
              data: fbData
            });
          case "Twitter":
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing Twitter API credentials" });
            }
            const twitterSettings = typeof integration.settings === "string" ? JSON.parse(integration.settings) : integration.settings || {};
            if (!twitterSettings.accessSecret) {
              return res.status(400).json({ error: "Missing Twitter API secret" });
            }
            return res.json({
              success: true,
              message: "Successfully verified Twitter API credentials",
              note: "Twitter API access requires proper OAuth 1.0a implementation"
            });
          case "LinkedIn":
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing LinkedIn access token" });
            }
            const liResponse = await fetch("https://api.linkedin.com/v2/me", {
              method: "GET",
              headers: {
                "Authorization": `Bearer ${integration.accessToken}`,
                "Content-Type": "application/json"
              }
            });
            if (!liResponse.ok) {
              const liError = await liResponse.json();
              return res.status(400).json({
                error: "LinkedIn API test failed",
                details: liError.message || "Unknown error"
              });
            }
            const liData = await liResponse.json();
            return res.json({
              success: true,
              message: `Successfully connected to LinkedIn`,
              data: liData
            });
          case "WhatsApp":
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing WhatsApp API credentials" });
            }
            const integrationSettings = typeof integration.settings === "string" ? JSON.parse(integration.settings) : integration.settings || {};
            const phoneNumberId = integrationSettings.phoneNumberId;
            if (!phoneNumberId) {
              return res.status(400).json({ error: "Missing WhatsApp phone number ID" });
            }
            const waResponse = await fetch(`https://graph.facebook.com/v18.0/${phoneNumberId}?fields=verified_name,quality_rating&access_token=${integration.accessToken}`, {
              method: "GET",
              headers: { "Content-Type": "application/json" }
            });
            if (!waResponse.ok) {
              const waError = await waResponse.json();
              return res.status(400).json({
                error: "WhatsApp Business API test failed",
                details: waError.error?.message || "Unknown error"
              });
            }
            const waData = await waResponse.json();
            return res.json({
              success: true,
              message: `Successfully connected to WhatsApp Business API for ${waData.verified_name || "your account"}`,
              data: waData
            });
          case "Email":
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing email service API credentials" });
            }
            const emailFields = typeof integration.settings === "string" ? JSON.parse(integration.settings) : integration.settings || {};
            const emailService = emailFields.service || "unknown";
            return res.json({
              success: true,
              message: `Successfully verified ${emailService} email service credentials`,
              note: "A test email was not sent to avoid unnecessary notifications"
            });
          default:
            if (!integration.accessToken) {
              return res.status(400).json({ error: "Missing API credentials" });
            }
            return res.json({
              success: true,
              message: `API credentials for ${integration.platform} verified`,
              note: "No specific API test is implemented for this platform"
            });
        }
      } catch (error) {
        console.error(`API integration test error for ${integration.platform}:`, error);
        return res.status(500).json({
          error: `Failed to test ${integration.platform} integration`,
          details: error.message || "Unknown error"
        });
      }
      if (!integration.isActive) {
        return res.status(400).json({ error: "Integration is not active" });
      }
      res.json({
        success: true,
        message: "Integration test successful",
        platform: integration.platform
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/social-integrations/:id/refresh-token", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const integration = await storage.getSocialIntegration(id);
      if (!integration) {
        return res.status(404).json({ error: "Social integration not found" });
      }
      if (integration.userId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to refresh this integration token" });
      }
      if (!integration.refreshToken) {
        return res.status(400).json({ error: "No refresh token available for this integration" });
      }
      const updatedIntegration = await storage.updateSocialIntegration(id, {
        accessToken: `refreshed_${Date.now()}`,
        tokenExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString()
        // 30 days from now
      });
      res.json({
        success: true,
        message: "Token refreshed successfully",
        tokenExpiry: updatedIntegration?.tokenExpiry
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/social-integrations/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const integration = await storage.getSocialIntegration(id);
      if (!integration) {
        return res.status(404).json({ error: "Social integration not found" });
      }
      if (integration.userId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to update this integration" });
      }
      const updatedIntegration = await storage.updateSocialIntegration(id, req.body);
      res.json(updatedIntegration);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/social-integrations/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const integration = await storage.getSocialIntegration(id);
      if (!integration) {
        return res.status(404).json({ error: "Social integration not found" });
      }
      if (integration.userId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to delete this integration" });
      }
      const success = await storage.deleteSocialIntegration(id);
      if (!success) {
        return res.status(500).json({ error: "Failed to delete integration" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/social-messages", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const leadId = req.query.leadId ? parseInt(req.query.leadId) : void 0;
      const contactId = req.query.contactId ? parseInt(req.query.contactId) : void 0;
      let messages2 = [];
      if (leadId) {
        messages2 = await storage.getLeadSocialMessages(leadId);
      } else if (contactId) {
        messages2 = await storage.getContactSocialMessages(contactId);
      } else {
        messages2 = await storage.listSocialMessages();
      }
      res.json(messages2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/social-messages", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const message = await storage.createSocialMessage(req.body);
      res.status(201).json(message);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/social-messages/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const updatedMessage = await storage.updateSocialMessage(id, req.body);
      if (!updatedMessage) {
        return res.status(404).json({ error: "Social message not found" });
      }
      res.json(updatedMessage);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/lead-sources", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const sources = await storage.listLeadSources();
      res.json(sources);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/lead-sources", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Only administrators can create lead sources" });
      }
      const source = await storage.createLeadSource(req.body);
      res.status(201).json(source);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/lead-sources/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Only administrators can update lead sources" });
      }
      const id = parseInt(req.params.id);
      const updatedSource = await storage.updateLeadSource(id, req.body);
      if (!updatedSource) {
        return res.status(404).json({ error: "Lead source not found" });
      }
      res.json(updatedSource);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/lead-sources/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Only administrators can delete lead sources" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteLeadSource(id);
      if (!success) {
        return res.status(404).json({ error: "Lead source not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/social-campaigns", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const campaigns = await storage.listSocialCampaigns();
      res.json(campaigns);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/social-campaigns", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const campaignData = {
        ...req.body,
        ownerId: req.body.ownerId || req.user.id
      };
      const campaign = await storage.createSocialCampaign(campaignData);
      res.status(201).json(campaign);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/social-campaigns/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const campaign = await storage.getSocialCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Social campaign not found" });
      }
      res.json(campaign);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/social-campaigns/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const campaign = await storage.getSocialCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Social campaign not found" });
      }
      if (campaign.ownerId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to update this campaign" });
      }
      const updatedCampaign = await storage.updateSocialCampaign(id, req.body);
      res.json(updatedCampaign);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/social-campaigns/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const id = parseInt(req.params.id);
      const campaign = await storage.getSocialCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Social campaign not found" });
      }
      if (campaign.ownerId !== req.user.id && req.user.role !== "Admin") {
        return res.status(403).json({ error: "You don't have permission to delete this campaign" });
      }
      const success = await storage.deleteSocialCampaign(id);
      if (!success) {
        return res.status(500).json({ error: "Failed to delete campaign" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/settings/api-keys", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const apiKeys4 = await storage.listApiKeys();
      res.json(apiKeys4);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/settings/api-keys", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const apiKeyData = insertApiKeySchema.parse({
        ...req.body,
        ownerId: req.user.id
      });
      const apiKey = await storage.createApiKey(apiKeyData);
      res.status(201).json(apiKey);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/settings/api-keys/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const id = parseInt(req.params.id);
      const apiKey = await storage.getApiKey(id);
      if (!apiKey) {
        return res.status(404).json({ error: "API key not found" });
      }
      res.json(apiKey);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/settings/api-keys/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const id = parseInt(req.params.id);
      const apiKeyData = insertApiKeySchema.partial().parse(req.body);
      const updatedApiKey = await storage.updateApiKey(id, apiKeyData);
      if (!updatedApiKey) {
        return res.status(404).json({ error: "API key not found" });
      }
      res.json(updatedApiKey);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/settings/api-keys/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteApiKey(id);
      if (!success) {
        return res.status(404).json({ error: "API key not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/settings/api-keys/:id/stats", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "Admin") {
        return res.status(403).json({ error: "Permission denied" });
      }
      const id = parseInt(req.params.id);
      const apiKey = await storage.getApiKey(id);
      if (!apiKey) {
        return res.status(404).json({ error: "API key not found" });
      }
      const stats = {
        totalRequests: apiKey.usageCount || 0,
        successRate: "95%",
        lastUsed: apiKey.lastUsed,
        usageByDay: [
          { date: "2025-03-28", count: 12 },
          { date: "2025-03-29", count: 15 },
          { date: "2025-03-30", count: 8 },
          { date: "2025-03-31", count: 20 },
          { date: "2025-04-01", count: 18 },
          { date: "2025-04-02", count: 25 },
          { date: "2025-04-03", count: 22 }
        ]
      };
      res.json(stats);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/communications", async (req, res) => {
    try {
      const communications2 = await storage.getAllCommunications();
      res.status(200).json(communications2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/communications/contact/:id", async (req, res) => {
    try {
      const contactId = parseInt(req.params.id);
      const contactType = req.query.type;
      if (!contactType || contactType !== "lead" && contactType !== "customer") {
        return res.status(400).json({ error: "Invalid contact type. Must be 'lead' or 'customer'." });
      }
      const communications2 = await storage.getContactCommunications(contactId, contactType);
      res.status(200).json(communications2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.put("/api/communications/:id/status", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = req.body;
      if (!status || !["unread", "read", "replied", "archived"].includes(status)) {
        return res.status(400).json({ error: "Invalid status. Must be 'unread', 'read', 'replied', or 'archived'." });
      }
      const communication = await storage.updateCommunicationStatus(id, status);
      if (!communication) {
        return res.status(404).json({ error: "Communication not found" });
      }
      res.status(200).json(communication);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/communications/send", async (req, res) => {
    try {
      console.log("Communication send request:", req.body);
      const { recipientId, channel, content, contactType, relatedToType, relatedToId } = req.body;
      let platformChannel = channel;
      if (channel.toLowerCase() === "phone" || channel.toLowerCase() === "sms") {
        platformChannel = "Other";
      } else if (channel.toLowerCase() === "whatsapp") {
        platformChannel = "WhatsApp";
      } else if (channel.toLowerCase() === "email") {
        platformChannel = "Email";
      } else if (channel.toLowerCase() === "messenger") {
        platformChannel = "Messenger";
      } else if (channel.toLowerCase() === "linkedin") {
        platformChannel = "LinkedIn";
      } else if (channel.toLowerCase() === "twitter" || channel.toLowerCase() === "x") {
        platformChannel = "Twitter";
      } else if (channel.toLowerCase() === "instagram") {
        platformChannel = "Instagram";
      } else if (channel.toLowerCase() === "facebook") {
        platformChannel = "Facebook";
      }
      const isDirectCommunication = recipientId && contactType;
      const isEntityCommunication = relatedToType && relatedToId;
      if (!channel || !content) {
        return res.status(400).json({ error: "Required fields missing: channel, content" });
      }
      if (!isDirectCommunication && !isEntityCommunication) {
        return res.status(400).json({
          error: "Either (recipientId and contactType) or (relatedToType and relatedToId) must be provided"
        });
      }
      if (isDirectCommunication && contactType !== "lead" && contactType !== "customer") {
        return res.status(400).json({ error: "Invalid contactType. Must be 'lead' or 'customer'." });
      }
      let contactId = recipientId;
      let contactTypeValue = contactType;
      if (!isDirectCommunication && isEntityCommunication) {
        if (relatedToType === "account") {
          const account = await storage.getAccount(relatedToId);
          if (!account) {
            return res.status(404).json({ error: `${relatedToType} with ID ${relatedToId} not found` });
          }
          contactId = -1;
          contactTypeValue = "customer";
        }
      }
      const communication = await storage.createCommunication({
        contactId,
        contactType: contactTypeValue,
        channel: platformChannel,
        // Use the mapped channel that matches the database enum
        direction: "outbound",
        content,
        status: "read",
        sentAt: /* @__PURE__ */ new Date(),
        relatedToType,
        relatedToId
      });
      if (req.user) {
        let activityDetail = "";
        if (isDirectCommunication) {
          activityDetail = `Sent ${channel} to ${contactType} ${recipientId}`;
        } else {
          activityDetail = `Sent ${channel} related to ${relatedToType} ${relatedToId}`;
        }
        await storage.createActivity({
          userId: req.user.id,
          action: `Sent ${channel} message`,
          detail: activityDetail,
          relatedToType: relatedToType || contactType,
          relatedToId: relatedToId || recipientId,
          icon: "sent"
        });
      }
      res.status(201).json(communication);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/communications/related/:type/:id", async (req, res) => {
    try {
      const relatedToType = req.params.type;
      const relatedToId = parseInt(req.params.id);
      if (!relatedToType || !relatedToId) {
        return res.status(400).json({ error: "Invalid entity type or ID" });
      }
      const communications2 = await storage.getRelatedCommunications(relatedToType, relatedToId);
      res.status(200).json(communications2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/product-categories", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const categories = await storage.listProductCategories();
      res.json(categories);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/product-categories", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const categoryData = insertProductCategorySchema.parse(req.body);
      const category = await storage.createProductCategory(categoryData);
      res.status(201).json(category);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/product-categories/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const category = await storage.getProductCategory(id);
      if (!category) {
        return res.status(404).json({ error: "Product category not found" });
      }
      res.json(category);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/product-categories/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const categoryData = insertProductCategorySchema.partial().parse(req.body);
      const updatedCategory = await storage.updateProductCategory(id, categoryData);
      if (!updatedCategory) {
        return res.status(404).json({ error: "Product category not found" });
      }
      res.json(updatedCategory);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/product-categories/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteProductCategory(id);
      if (!success) {
        return res.status(404).json({ error: "Product category not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/products", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      console.log("Fetching products from storage...");
      const products2 = await storage.listProducts();
      console.log("Products fetched:", products2);
      res.json(products2);
    } catch (error) {
      console.error("Detailed error when fetching products:", error);
      handleError(res, error);
    }
  });
  app2.post("/api/products", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const productData = insertProductSchema.parse(req.body);
      const product = await storage.createProduct(productData);
      res.status(201).json(product);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/products/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const product = await storage.getProduct(id);
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/products/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const productData = insertProductSchema.partial().parse(req.body);
      const updatedProduct = await storage.updateProduct(id, productData);
      if (!updatedProduct) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.json(updatedProduct);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/products/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteProduct(id);
      if (!success) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/inventory-transactions", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const transactions = await storage.listInventoryTransactions();
      res.json(transactions);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/inventory-transactions", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const transactionData = insertInventoryTransactionSchema.parse(req.body);
      const transaction = await storage.createInventoryTransaction(transactionData);
      res.status(201).json(transaction);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/inventory-transactions/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const transaction = await storage.getInventoryTransaction(id);
      if (!transaction) {
        return res.status(404).json({ error: "Inventory transaction not found" });
      }
      res.json(transaction);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/products/:id/inventory-history", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const productId = parseInt(req.params.id);
      const history = await storage.getProductInventoryHistory(productId);
      res.json(history);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/inventory-summary", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const summary = await storage.getInventorySummary();
      res.json(summary);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/invoices", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      console.log("Fetching invoices from storage...");
      const invoices2 = await storage.listInvoices();
      console.log("Invoices fetched:", invoices2);
      res.json(invoices2);
    } catch (error) {
      console.error("Detailed error when fetching invoices:", error);
      handleError(res, error);
    }
  });
  app2.post("/api/invoices", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const invoiceData = insertInvoiceSchema.parse(req.body);
      const invoice = await storage.createInvoice(invoiceData);
      res.status(201).json(invoice);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/invoices/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const invoice = await storage.getInvoice(id);
      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/invoices/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const invoiceData = insertInvoiceSchema.partial().parse(req.body);
      const updatedInvoice = await storage.updateInvoice(id, invoiceData);
      if (!updatedInvoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }
      res.json(updatedInvoice);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.put("/api/invoices/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const invoiceData = insertInvoiceSchema.partial().parse(req.body);
      const updatedInvoice = await storage.updateInvoice(id, invoiceData);
      if (!updatedInvoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }
      res.json(updatedInvoice);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/invoices/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteInvoice(id);
      if (!success) {
        return res.status(404).json({ error: "Invoice not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/invoices/:invoiceId/items", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const invoiceId = parseInt(req.params.invoiceId);
      const items = await storage.getInvoiceItems(invoiceId);
      res.json(items);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/invoice-items", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const itemData = insertInvoiceItemSchema.parse(req.body);
      const item = await storage.createInvoiceItem(itemData);
      res.status(201).json(item);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/invoice-items/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const itemData = insertInvoiceItemSchema.partial().parse(req.body);
      const updatedItem = await storage.updateInvoiceItem(id, itemData);
      if (!updatedItem) {
        return res.status(404).json({ error: "Invoice item not found" });
      }
      res.json(updatedItem);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/invoice-items/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteInvoiceItem(id);
      if (!success) {
        return res.status(404).json({ error: "Invoice item not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/purchase-orders", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const purchaseOrders2 = await storage.listPurchaseOrders();
      res.json(purchaseOrders2);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/purchase-orders", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const purchaseOrderData = insertPurchaseOrderSchema.parse(req.body);
      const purchaseOrder = await storage.createPurchaseOrder(purchaseOrderData);
      res.status(201).json(purchaseOrder);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/purchase-orders/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const purchaseOrder = await storage.getPurchaseOrder(id);
      if (!purchaseOrder) {
        return res.status(404).json({ error: "Purchase order not found" });
      }
      res.json(purchaseOrder);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/purchase-orders/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const purchaseOrderData = insertPurchaseOrderSchema.partial().parse(req.body);
      const updatedPurchaseOrder = await storage.updatePurchaseOrder(id, purchaseOrderData);
      if (!updatedPurchaseOrder) {
        return res.status(404).json({ error: "Purchase order not found" });
      }
      res.json(updatedPurchaseOrder);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/purchase-orders/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deletePurchaseOrder(id);
      if (!success) {
        return res.status(404).json({ error: "Purchase order not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/purchase-orders/:purchaseOrderId/items", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const purchaseOrderId = parseInt(req.params.purchaseOrderId);
      const items = await storage.getPurchaseOrderItems(purchaseOrderId);
      res.json(items);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/purchase-order-items", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const itemData = insertPurchaseOrderItemSchema.parse(req.body);
      const item = await storage.createPurchaseOrderItem(itemData);
      res.status(201).json(item);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/purchase-order-items/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const itemData = insertPurchaseOrderItemSchema.partial().parse(req.body);
      const updatedItem = await storage.updatePurchaseOrderItem(id, itemData);
      if (!updatedItem) {
        return res.status(404).json({ error: "Purchase order item not found" });
      }
      res.json(updatedItem);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/purchase-order-items/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deletePurchaseOrderItem(id);
      if (!success) {
        return res.status(404).json({ error: "Purchase order item not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/purchase-orders/:id/receive", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const { items } = req.body;
      if (!Array.isArray(items)) {
        return res.status(400).json({ error: "Items must be an array" });
      }
      const result = await storage.receivePurchaseOrderItems(id, items);
      res.json(result);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposal-templates", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const templates = await storage.listProposalTemplates();
      res.json(templates);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposal-templates/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const template = await storage.getProposalTemplate(id);
      if (!template) {
        return res.status(404).json({ error: "Proposal template not found" });
      }
      res.json(template);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/proposal-templates", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const templateData = insertProposalTemplateSchema.parse(req.body);
      if (!templateData.createdBy) {
        templateData.createdBy = req.user.id;
      }
      const template = await storage.createProposalTemplate(templateData);
      res.status(201).json(template);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/proposal-templates/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const templateData = insertProposalTemplateSchema.partial().parse(req.body);
      if (!templateData.updatedBy) {
        templateData.updatedBy = req.user.id;
      }
      const template = await storage.updateProposalTemplate(id, templateData);
      if (!template) {
        return res.status(404).json({ error: "Proposal template not found" });
      }
      res.json(template);
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposal-templates/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteProposalTemplate(id);
      if (!success) {
        return res.status(404).json({ error: "Proposal template not found" });
      }
      res.status(204).end();
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposals", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Unauthorized",
          message: "You must be logged in to view proposals"
        });
      }
      try {
        const filter = {};
        const queryParams = {};
        const parsedErrors = {};
        const parseNumericParam = (name, value) => {
          const parsed = parseInt(value);
          if (isNaN(parsed)) {
            parsedErrors[name] = `Invalid ${name}: ${value} is not a number`;
            return null;
          }
          return parsed;
        };
        if (req.query.accountId) {
          const accountId = parseNumericParam("accountId", req.query.accountId);
          if (accountId !== null) {
            filter.accountId = accountId;
            queryParams.accountId = accountId;
          }
        }
        if (req.query.opportunityId) {
          const opportunityId = parseNumericParam("opportunityId", req.query.opportunityId);
          if (opportunityId !== null) {
            filter.opportunityId = opportunityId;
            queryParams.opportunityId = opportunityId;
          }
        }
        if (req.query.status) {
          const status = req.query.status;
          const validStatuses = ["Draft", "Sent", "Accepted", "Rejected", "Expired", "Revoked"];
          if (validStatuses.includes(status)) {
            filter.status = status;
            queryParams.status = status;
          } else {
            parsedErrors.status = `Invalid status: ${status}. Must be one of: ${validStatuses.join(", ")}`;
          }
        }
        if (req.query.createdBy) {
          const createdBy = parseNumericParam("createdBy", req.query.createdBy);
          if (createdBy !== null) {
            filter.createdBy = createdBy;
            queryParams.createdBy = createdBy;
          }
        }
        if (Object.keys(parsedErrors).length > 0) {
          return res.status(400).json({
            error: "Validation Error",
            message: "Invalid filter parameters",
            details: parsedErrors
          });
        }
        const proposals2 = await storage.listProposals(filter);
        console.log(`Sending proposals list with ${proposals2.length} items`);
        return res.status(200).json({
          success: true,
          data: proposals2,
          metadata: {
            count: proposals2.length,
            filters: queryParams,
            timestamp: /* @__PURE__ */ new Date()
          },
          message: "Proposals retrieved successfully"
        });
      } catch (databaseError) {
        console.error("Database error retrieving proposals:", databaseError);
        return res.status(500).json({
          error: "Database Error",
          message: databaseError?.message || "Failed to retrieve proposals from database",
          // Include the stack trace in development for debugging
          ...process.env.NODE_ENV !== "production" && {
            stack: databaseError?.stack,
            details: databaseError
          }
        });
      }
    } catch (error) {
      console.error("Unexpected error retrieving proposals:", error);
      return res.status(500).json({
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while retrieving proposals",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.get("/api/proposals/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Unauthorized",
          message: "You must be logged in to view proposal details"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.id }
        });
      }
      try {
        const proposal = await storage.getProposal(id);
        if (!proposal) {
          return res.status(404).json({
            error: "Not Found",
            message: "Proposal not found",
            details: { id }
          });
        }
        try {
          const elements = await storage.listProposalElements(id);
          const comments = await storage.getProposalComments(id);
          const collaborators = await storage.getProposalCollaborators(id);
          const activities2 = await storage.getProposalActivities(id);
          try {
            if (req.user) {
              await storage.createProposalActivity({
                proposalId: id,
                userId: req.user.id,
                activityType: "view",
                description: `Proposal viewed by ${req.user.username || "user"}`
              });
            }
          } catch (activityError) {
            console.warn("Failed to log proposal view activity:", activityError);
          }
          console.log(`Sending proposal ${id} response:`, proposal.name);
          return res.status(200).json({
            success: true,
            data: {
              ...proposal,
              _metadata: {
                elementsCount: elements.length,
                commentsCount: comments.length,
                collaboratorsCount: collaborators.length,
                activitiesCount: activities2.length
              }
            },
            message: "Proposal details retrieved successfully"
          });
        } catch (relatedDataError) {
          console.error("Error fetching related proposal data:", relatedDataError);
          return res.status(200).json({
            success: true,
            data: proposal,
            message: "Proposal details retrieved successfully (without related data)"
          });
        }
      } catch (databaseError) {
        console.error("Database error retrieving proposal:", databaseError);
        return res.status(500).json({
          error: "Database Error",
          message: databaseError?.message || "Failed to retrieve proposal from database",
          // Include the stack trace in development for debugging
          ...process.env.NODE_ENV !== "production" && {
            stack: databaseError?.stack,
            details: databaseError
          }
        });
      }
    } catch (error) {
      console.error("Unexpected error retrieving proposal:", error);
      return res.status(500).json({
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while retrieving the proposal",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.post("/api/test-proposal", async (req, res) => {
    try {
      console.log("Test proposal endpoint called with body:", JSON.stringify(req.body, null, 2));
      const proposalData = {
        name: "Test Proposal",
        opportunityId: 91,
        accountId: 102,
        createdBy: 2,
        status: "Draft",
        content: {},
        metadata: {}
      };
      console.log("Creating test proposal with data:", JSON.stringify(proposalData, null, 2));
      const proposal = await storage.createProposal(proposalData);
      console.log("Test proposal created:", JSON.stringify(proposal, null, 2));
      return res.status(201).json({
        success: true,
        data: proposal,
        message: "Test proposal created successfully"
      });
    } catch (error) {
      console.error("Error in test proposal creation:", error);
      return res.status(500).json({
        success: false,
        message: error.message || "Failed to create test proposal"
      });
    }
  });
  app2.post("/api/proposals", async (req, res) => {
    try {
      console.log("POST /api/proposals received with body:", JSON.stringify(req.body, null, 2));
      try {
        const proposalToCreate = {
          name: req.body.name || "New Proposal",
          opportunityId: Number(req.body.opportunityId),
          accountId: Number(req.body.accountId),
          createdBy: req.body.createdBy || (req.user ? req.user.id : 2),
          // Default to user ID 2 if no user in session
          status: req.body.status || "Draft",
          content: req.body.content || {},
          metadata: req.body.metadata || {},
          templateId: req.body.templateId ? Number(req.body.templateId) : void 0,
          expiresAt: req.body.expiresAt
        };
        console.log("Processed proposal data:", JSON.stringify(proposalToCreate, null, 2));
        if (!proposalToCreate.name) {
          return res.status(400).json({
            error: "Validation Error",
            message: "Proposal name is required"
          });
        }
        if (isNaN(proposalToCreate.opportunityId)) {
          return res.status(400).json({
            error: "Validation Error",
            message: "Valid opportunity ID is required",
            field: "opportunityId",
            value: req.body.opportunityId
          });
        }
        if (isNaN(proposalToCreate.accountId)) {
          return res.status(400).json({
            error: "Validation Error",
            message: "Valid account ID is required",
            field: "accountId",
            value: req.body.accountId
          });
        }
        const opportunity = await storage.getOpportunity(proposalToCreate.opportunityId);
        if (!opportunity) {
          return res.status(400).json({
            error: "Validation Error",
            message: "The specified opportunity does not exist",
            field: "opportunityId"
          });
        }
        const account = await storage.getAccount(proposalToCreate.accountId);
        if (!account) {
          return res.status(400).json({
            error: "Validation Error",
            message: "The specified account does not exist",
            field: "accountId"
          });
        }
        if (proposalToCreate.templateId) {
          const template = await storage.getProposalTemplate(proposalToCreate.templateId);
          if (!template) {
            return res.status(400).json({
              error: "Validation Error",
              message: "The specified template does not exist",
              field: "templateId"
            });
          }
          proposalToCreate.content = template.content;
        }
        console.log("Creating proposal with data:", JSON.stringify(proposalToCreate, null, 2));
        const proposal = await storage.createProposal(proposalToCreate);
        console.log("Proposal created successfully:", JSON.stringify(proposal, null, 2));
        try {
          await storage.createProposalActivity({
            proposalId: proposal.id,
            userId: proposalToCreate.createdBy,
            activityType: "create",
            description: `Proposal "${proposal.name}" created`,
            metadata: {
              fromTemplate: !!proposalToCreate.templateId,
              opportunityName: opportunity.name,
              accountName: account.name
            }
          });
        } catch (activityError) {
          console.warn("Failed to log proposal creation activity:", activityError);
        }
        const response = {
          success: true,
          data: proposal,
          message: "Proposal created successfully"
        };
        console.log("Sending successful response:", JSON.stringify(response, null, 2));
        return res.status(201).json(response);
      } catch (databaseError) {
        console.error("Database error creating proposal:", databaseError);
        const errorMessage = databaseError?.message || "Failed to create proposal in database";
        const statusCode = errorMessage.includes("does not exist") ? 400 : 500;
        return res.status(statusCode).json({
          error: statusCode === 400 ? "Validation Error" : "Database Error",
          message: errorMessage,
          // Include the stack trace in development for debugging
          ...process.env.NODE_ENV !== "production" && {
            stack: databaseError?.stack,
            details: databaseError
          }
        });
      }
    } catch (error) {
      console.error("Unexpected error creating proposal:", error);
      return res.status(500).json({
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while creating the proposal",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.patch("/api/proposals/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Unauthorized",
          message: "You must be logged in to update a proposal"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.id }
        });
      }
      try {
        const existingProposal = await storage.getProposal(id);
        if (!existingProposal) {
          return res.status(404).json({
            error: "Not Found",
            message: "Proposal not found",
            details: { id }
          });
        }
        try {
          const proposalData = insertProposalSchema.partial().parse(req.body);
          if (!proposalData.updatedBy) {
            proposalData.updatedBy = req.user.id;
          }
          if (proposalData.status && proposalData.status !== existingProposal.status) {
            if (!proposalData.metadata) {
              proposalData.metadata = existingProposal.metadata || {};
            }
            const now = /* @__PURE__ */ new Date();
            const metadataObj = proposalData.metadata;
            if (proposalData.status === "Sent") {
              metadataObj.sentAt = now;
            } else if (proposalData.status === "Accepted") {
              metadataObj.acceptedAt = now;
            } else if (proposalData.status === "Rejected") {
              metadataObj.rejectedAt = now;
            }
            proposalData.metadata = metadataObj;
            try {
              await storage.createProposalActivity({
                proposalId: id,
                userId: req.user.id,
                activityType: "status_change",
                description: `Proposal status changed from "${existingProposal.status}" to "${proposalData.status}" by ${req.user.username || "user"}`,
                metadata: {
                  previousStatus: existingProposal.status,
                  newStatus: proposalData.status,
                  changedAt: now
                }
              });
            } catch (activityError) {
              console.warn("Failed to log proposal status change activity:", activityError);
            }
          }
          const proposal = await storage.updateProposal(id, proposalData);
          if (!proposal) {
            return res.status(500).json({
              error: "Database Error",
              message: "Failed to update proposal"
            });
          }
          return res.status(200).json({
            success: true,
            data: proposal,
            message: "Proposal updated successfully"
          });
        } catch (validationError) {
          if (validationError.name === "ZodError") {
            return res.status(400).json({
              error: "Validation Error",
              message: "Invalid proposal data provided",
              details: validationError.errors
            });
          }
          throw validationError;
        }
      } catch (databaseError) {
        console.error("Database error updating proposal:", databaseError);
        const errorMessage = databaseError?.message || "Failed to update proposal in database";
        const statusCode = errorMessage.includes("does not exist") ? 400 : 500;
        return res.status(statusCode).json({
          error: statusCode === 400 ? "Validation Error" : "Database Error",
          message: errorMessage,
          // Include the stack trace in development for debugging
          ...process.env.NODE_ENV !== "production" && {
            stack: databaseError?.stack,
            details: databaseError
          }
        });
      }
    } catch (error) {
      console.error("Unexpected error updating proposal:", error);
      return res.status(500).json({
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while updating the proposal",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.delete("/api/proposals/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Unauthorized",
          message: "You must be logged in to delete a proposal"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.id }
        });
      }
      try {
        const existingProposal = await storage.getProposal(id);
        if (!existingProposal) {
          return res.status(404).json({
            error: "Not Found",
            message: "Proposal not found",
            details: { id }
          });
        }
        if (existingProposal.status === "Accepted") {
          return res.status(400).json({
            error: "Validation Error",
            message: "Cannot delete an accepted proposal",
            details: {
              id,
              status: existingProposal.status,
              note: "Proposals that have been accepted cannot be deleted for record-keeping purposes"
            }
          });
        }
        try {
          const elements = await storage.listProposalElements(id);
          const comments = await storage.getProposalComments(id);
          const collaborators = await storage.getProposalCollaborators(id);
          try {
            await storage.createProposalActivity({
              proposalId: id,
              userId: req.user.id,
              activityType: "delete",
              description: `Proposal "${existingProposal.name}" deleted by ${req.user.username || "user"}`,
              metadata: {
                deletedAt: /* @__PURE__ */ new Date(),
                hadElements: elements.length > 0,
                hadComments: comments.length > 0,
                hadCollaborators: collaborators.length > 0,
                opportunityId: existingProposal.opportunityId,
                accountId: existingProposal.accountId,
                status: existingProposal.status
              }
            });
          } catch (activityError) {
            console.warn("Failed to log proposal deletion activity:", activityError);
          }
          const success = await storage.deleteProposal(id);
          if (!success) {
            return res.status(500).json({
              error: "Database Error",
              message: "Failed to delete proposal"
            });
          }
          return res.status(200).json({
            success: true,
            message: "Proposal deleted successfully",
            data: {
              id,
              name: existingProposal.name
            }
          });
        } catch (databaseError) {
          console.error("Database error deleting proposal:", databaseError);
          if (databaseError.message && databaseError.message.includes("foreign key constraint")) {
            return res.status(400).json({
              error: "Constraint Error",
              message: "Cannot delete this proposal because it has related records in other tables",
              details: {
                id,
                suggestion: "Make sure all related elements, comments, and collaborators are removed first"
              }
            });
          }
          return res.status(500).json({
            error: "Database Error",
            message: databaseError?.message || "Failed to delete proposal from database",
            // Include the stack trace in development for debugging
            ...process.env.NODE_ENV !== "production" && {
              stack: databaseError?.stack,
              details: databaseError
            }
          });
        }
      } catch (error) {
        console.error("Error processing proposal deletion:", error);
        return res.status(500).json({
          error: "Processing Error",
          message: error?.message || "Failed to process proposal deletion request"
        });
      }
    } catch (error) {
      console.error("Unexpected error deleting proposal:", error);
      return res.status(500).json({
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while deleting the proposal",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.get("/api/proposals/:proposalId/elements", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      let elements = await storage.listProposalElements(proposalId);
      try {
        const { cryptoSphere: cryptoSphere2 } = await Promise.resolve().then(() => (init_cryptosphere(), cryptosphere_exports)).catch(() => Promise.resolve().then(() => (init_cryptosphere(), cryptosphere_exports)));
        elements = await Promise.all(elements.map(async (element) => {
          const clonedElement = {
            ...element,
            content: void 0
            // Start with empty content that we'll replace
          };
          try {
            if (element.content && typeof element.content === "object" && element.content.iv && element.content.encrypted && element.content.keyId) {
              console.log(`Decrypting content for element ${element.id}`);
              try {
                const decrypted = await cryptoSphere2.decrypt({
                  encrypted: element.content.encrypted,
                  iv: element.content.iv,
                  keyId: element.content.keyId
                });
                let parsedContent;
                if (typeof decrypted.decrypted === "string") {
                  try {
                    parsedContent = JSON.parse(decrypted.decrypted);
                  } catch (parseError) {
                    if (element.elementType === "Text") {
                      parsedContent = { text: decrypted.decrypted };
                    } else {
                      parsedContent = { text: "Content format error. Please contact support." };
                    }
                  }
                } else if (typeof decrypted.decrypted === "object") {
                  parsedContent = decrypted.decrypted;
                } else {
                  parsedContent = { text: "Unknown content format. Please contact support." };
                }
                clonedElement.content = parsedContent;
                console.log(`Successfully decrypted content for element ${element.id}`);
              } catch (decryptError) {
                console.error(`Failed to decrypt content for element ${element.id}:`, decryptError);
                clonedElement.content = {
                  text: "Content could not be decrypted. Please contact support."
                };
              }
            } else if (element.content && typeof element.content === "string" && element.content.trim()) {
              try {
                clonedElement.content = JSON.parse(element.content);
                console.log(`Successfully parsed string content for element ${element.id}`);
              } catch (parseError) {
                if (element.elementType === "Text") {
                  clonedElement.content = { text: element.content };
                  console.log(`Used string content as text for element ${element.id}`);
                } else {
                  console.warn(`Failed to parse string content for element ${element.id}:`, parseError);
                  clonedElement.content = { text: "Invalid content format. Please contact support." };
                }
              }
            } else if (element.content && typeof element.content === "object") {
              const { iv, encrypted, keyId, ...actualContent } = element.content;
              if (Object.keys(actualContent).length > 0) {
                clonedElement.content = actualContent;
              } else {
                switch (element.elementType) {
                  case "Text":
                    clonedElement.content = { text: "" };
                    break;
                  case "Header":
                    clonedElement.content = { text: "Header", level: 2 };
                    break;
                  case "Image":
                    clonedElement.content = { url: "", caption: "" };
                    break;
                  case "Table":
                    clonedElement.content = { rows: [[""]] };
                    break;
                  case "List":
                    clonedElement.content = { items: [""], style: "bullet" };
                    break;
                  default:
                    clonedElement.content = {};
                }
              }
            }
            if (!clonedElement.content) {
              clonedElement.content = {};
              console.warn(`No content found for element ${element.id}, using empty object`);
            }
          } catch (processError) {
            console.error(`Error processing element ${element.id}:`, processError);
            clonedElement.content = { text: "Error processing content." };
          }
          return clonedElement;
        }));
      } catch (decryptionError) {
        console.error("Error during content decryption:", decryptionError);
      }
      res.status(200).json({
        success: true,
        data: elements,
        metadata: {
          count: elements.length,
          proposalId,
          timestamp: /* @__PURE__ */ new Date()
        }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/proposals/:proposalId/elements", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      const proposal = await storage.getProposal(proposalId);
      if (!proposal) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal not found",
          details: { proposalId }
        });
      }
      const requestBody = { ...req.body };
      if (requestBody.content !== void 0) {
        try {
          if (typeof requestBody.content === "string") {
            JSON.parse(requestBody.content);
          } else {
            requestBody.content = JSON.stringify(requestBody.content);
          }
        } catch (jsonError) {
          return res.status(400).json({
            success: false,
            error: "Validation Error",
            message: "Element content must be valid JSON",
            details: { contentError: jsonError.message }
          });
        }
      }
      const elementData = insertProposalElementSchema.parse({
        ...requestBody,
        proposalId,
        createdBy: requestBody.createdBy || 2
        // Default to user ID 2 if not provided
      });
      const element = await storage.createProposalElement(elementData);
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "ELEMENT_ADDED",
          description: `Element "${element.name}" added`,
          userId: elementData.createdBy,
          metadata: {
            elementId: element.id,
            elementType: element.elementType
          }
        });
      } catch (logError) {
        console.error("Error logging proposal activity:", logError);
      }
      res.status(201).json({
        success: true,
        data: element,
        message: "Proposal element created successfully"
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposal-elements/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid element ID is required",
          details: { id: req.params.id }
        });
      }
      let element = await storage.getProposalElement(id);
      if (!element) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id }
        });
      }
      try {
        const { cryptoSphere: cryptoSphere2 } = await Promise.resolve().then(() => (init_cryptosphere(), cryptosphere_exports)).catch(() => Promise.resolve().then(() => (init_cryptosphere(), cryptosphere_exports)));
        const clonedElement = {
          ...element,
          content: void 0
          // Start with empty content that we'll replace
        };
        try {
          if (element.content && typeof element.content === "object" && element.content.iv && element.content.encrypted && element.content.keyId) {
            console.log(`Decrypting content for element ${element.id}`);
            try {
              const decrypted = await cryptoSphere2.decrypt({
                encrypted: element.content.encrypted,
                iv: element.content.iv,
                keyId: element.content.keyId
              });
              let parsedContent;
              if (typeof decrypted.decrypted === "string") {
                try {
                  parsedContent = JSON.parse(decrypted.decrypted);
                } catch (parseError) {
                  if (element.elementType === "Text") {
                    parsedContent = { text: decrypted.decrypted };
                  } else {
                    parsedContent = { text: "Content format error. Please contact support." };
                  }
                }
              } else if (typeof decrypted.decrypted === "object") {
                parsedContent = decrypted.decrypted;
              } else {
                parsedContent = { text: "Unknown content format. Please contact support." };
              }
              clonedElement.content = parsedContent;
              console.log(`Successfully decrypted content for element ${element.id}`);
            } catch (decryptError) {
              console.error(`Failed to decrypt content for element ${element.id}:`, decryptError);
              clonedElement.content = {
                text: "Content could not be decrypted. Please contact support."
              };
            }
          } else if (element.content && typeof element.content === "string" && element.content.trim()) {
            try {
              clonedElement.content = JSON.parse(element.content);
              console.log(`Successfully parsed string content for element ${element.id}`);
            } catch (parseError) {
              if (element.elementType === "Text") {
                clonedElement.content = { text: element.content };
                console.log(`Used string content as text for element ${element.id}`);
              } else {
                console.warn(`Failed to parse string content for element ${element.id}:`, parseError);
                clonedElement.content = { text: "Invalid content format. Please contact support." };
              }
            }
          } else if (element.content && typeof element.content === "object") {
            const { iv, encrypted, keyId, ...actualContent } = element.content;
            if (Object.keys(actualContent).length > 0) {
              clonedElement.content = actualContent;
            } else {
              switch (element.elementType) {
                case "Text":
                  clonedElement.content = { text: "" };
                  break;
                case "Header":
                  clonedElement.content = { text: "Header", level: 2 };
                  break;
                case "Image":
                  clonedElement.content = { url: "", caption: "" };
                  break;
                case "Table":
                  clonedElement.content = { rows: [[""]] };
                  break;
                case "List":
                  clonedElement.content = { items: [""], style: "bullet" };
                  break;
                default:
                  clonedElement.content = {};
              }
            }
          }
          if (!clonedElement.content) {
            clonedElement.content = {};
            console.warn(`No content found for element ${element.id}, using empty object`);
          }
          element = clonedElement;
        } catch (processError) {
          console.error(`Error processing element ${element.id}:`, processError);
          element.content = { text: "Error processing content." };
        }
      } catch (decryptionError) {
        console.error("Error during content decryption:", decryptionError);
      }
      return res.status(200).json({
        success: true,
        data: element
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/proposals/:proposalId/elements/:id", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      const elementId = parseInt(req.params.id);
      console.log(`PATCH request for element ${elementId} in proposal ${proposalId}`);
      if (isNaN(proposalId) || isNaN(elementId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID and element ID are required",
          details: {
            proposalId: req.params.proposalId,
            elementId: req.params.id
          }
        });
      }
      const currentElement = await storage.getProposalElement(elementId);
      if (!currentElement) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id: elementId }
        });
      }
      if (currentElement.proposalId !== proposalId) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Element does not belong to the specified proposal",
          details: {
            elementId,
            elementProposalId: currentElement.proposalId,
            requestedProposalId: proposalId
          }
        });
      }
      req.params.id = elementId.toString();
      try {
        if (req.body.content && typeof req.body.content === "object" && req.body.content._updateData) {
          console.log("Detected _updateData field in content, handling special update");
          const updateData = req.body.content._updateData;
          const modifiedBody = {
            ...req.body,
            content: updateData
          };
          const updatedElement = await storage.updateProposalElement(elementId, modifiedBody);
          return res.status(200).json({
            success: true,
            data: updatedElement,
            message: "Element updated successfully with extracted content"
          });
        } else {
          const updatedElement = await storage.updateProposalElement(elementId, req.body);
          return res.status(200).json({
            success: true,
            data: updatedElement,
            message: "Element updated successfully"
          });
        }
      } catch (error) {
        console.error("Error updating proposal element:", error);
        return res.status(500).json({
          success: false,
          error: "Server Error",
          message: error.message || "Failed to update element"
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/proposals/:proposalId/elements/:id/move", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      const elementId = parseInt(req.params.id);
      const { direction } = req.body;
      console.log(`Moving element ${elementId} in proposal ${proposalId} ${direction}`);
      if (isNaN(proposalId) || isNaN(elementId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID and element ID are required",
          details: {
            proposalId: req.params.proposalId,
            elementId: req.params.id
          }
        });
      }
      if (direction !== "up" && direction !== "down") {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Direction must be 'up' or 'down'",
          details: { direction }
        });
      }
      const currentElement = await storage.getProposalElement(elementId);
      if (!currentElement) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id: elementId }
        });
      }
      if (currentElement.proposalId !== proposalId) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Element does not belong to the specified proposal",
          details: {
            elementId,
            elementProposalId: currentElement.proposalId,
            requestedProposalId: proposalId
          }
        });
      }
      const allElements = await storage.listProposalElements(proposalId);
      const sortedElements = allElements.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
      const currentIndex = sortedElements.findIndex((e) => e.id === elementId);
      if (currentIndex === -1) {
        return res.status(404).json({
          success: false,
          error: "Logic Error",
          message: "Element not found in sorted list"
        });
      }
      let newIndex = direction === "up" ? currentIndex - 1 : currentIndex + 1;
      if (newIndex < 0 || newIndex >= sortedElements.length) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: `Cannot move element ${direction}`,
          details: {
            currentIndex,
            maxIndex: sortedElements.length - 1
          }
        });
      }
      const targetElement = sortedElements[newIndex];
      const tempSortOrder = targetElement.sortOrder;
      await storage.updateProposalElement(currentElement.id, {
        ...currentElement,
        sortOrder: tempSortOrder
      });
      await storage.updateProposalElement(targetElement.id, {
        ...targetElement,
        sortOrder: currentElement.sortOrder
      });
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "ELEMENT_MOVED",
          description: `Element "${currentElement.name}" moved ${direction}`,
          userId: req.user?.id || 2,
          metadata: {
            elementId,
            direction,
            oldIndex: currentIndex,
            newIndex
          }
        });
      } catch (logError) {
        console.error("Failed to log element move activity:", logError);
      }
      return res.status(200).json({
        success: true,
        message: `Element moved ${direction} successfully`,
        data: {
          id: elementId,
          newIndex
        }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposals/:proposalId/elements/:id", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      const elementId = parseInt(req.params.id);
      console.log(`DELETE request for element ${elementId} in proposal ${proposalId}`);
      if (isNaN(proposalId) || isNaN(elementId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID and element ID are required",
          details: {
            proposalId: req.params.proposalId,
            elementId: req.params.id
          }
        });
      }
      const currentElement = await storage.getProposalElement(elementId);
      if (!currentElement) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id: elementId }
        });
      }
      if (currentElement.proposalId !== proposalId) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Element does not belong to the specified proposal",
          details: {
            elementId,
            elementProposalId: currentElement.proposalId,
            requestedProposalId: proposalId
          }
        });
      }
      const success = await storage.deleteProposalElement(elementId);
      if (!success) {
        return res.status(500).json({
          success: false,
          error: "Database Error",
          message: "Failed to delete element"
        });
      }
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "ELEMENT_DELETED",
          description: `Element "${currentElement.name}" deleted`,
          userId: req.user?.id || 2,
          metadata: {
            elementId,
            elementType: currentElement.elementType
          }
        });
      } catch (logError) {
        console.error("Failed to log element deletion activity:", logError);
      }
      return res.status(200).json({
        success: true,
        message: "Element deleted successfully",
        data: {
          id: elementId,
          name: currentElement.name
        }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/proposal-elements/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid element ID is required",
          details: { id: req.params.id }
        });
      }
      const currentElement = await storage.getProposalElement(id);
      if (!currentElement) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id }
        });
      }
      try {
        const requestBody = { ...req.body };
        if (requestBody.content !== void 0) {
          try {
            if (typeof requestBody.content === "string") {
              JSON.parse(requestBody.content);
            } else {
              requestBody.content = JSON.stringify(requestBody.content);
            }
          } catch (jsonError) {
            return res.status(400).json({
              success: false,
              error: "Validation Error",
              message: "Element content must be valid JSON",
              details: { contentError: jsonError.message }
            });
          }
        }
        const elementData = insertProposalElementSchema.partial().parse({
          ...requestBody,
          updatedBy: requestBody.updatedBy || 2,
          // Default to user ID 2 if not provided
          // Ensure proposalId is included for activity log
          proposalId: currentElement.proposalId
        });
        const element = await storage.updateProposalElement(id, elementData);
        if (!element) {
          return res.status(404).json({
            success: false,
            error: "Not Found",
            message: "Proposal element not found or could not be updated",
            details: { id }
          });
        }
        try {
          await storage.createProposalActivity({
            proposalId: currentElement.proposalId,
            activityType: "ELEMENT_UPDATED",
            description: `Element "${element.name}" updated`,
            userId: elementData.updatedBy || 2,
            metadata: {
              elementId: element.id,
              elementType: element.elementType,
              changes: Object.keys(req.body).filter((key) => key !== "updatedBy")
            }
          });
        } catch (logError) {
          console.error("Error logging proposal activity:", logError);
        }
        return res.status(200).json({
          success: true,
          data: element,
          message: "Proposal element updated successfully"
        });
      } catch (validationError) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid element data provided",
          details: validationError?.errors || validationError?.message
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposals/:proposalId/elements/:id", async (req, res) => {
    try {
      const proposalId = parseInt(req.params.proposalId);
      const elementId = parseInt(req.params.id);
      console.log(`DELETE request for element ${elementId} in proposal ${proposalId}`);
      if (isNaN(proposalId) || isNaN(elementId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID and element ID are required",
          details: {
            proposalId: req.params.proposalId,
            elementId: req.params.id
          }
        });
      }
      const element = await storage.getProposalElement(elementId);
      if (!element) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id: elementId }
        });
      }
      if (element.proposalId !== proposalId) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Element does not belong to the specified proposal",
          details: {
            elementId,
            elementProposalId: element.proposalId,
            requestedProposalId: proposalId
          }
        });
      }
      const elementName = element.name;
      const elementType = element.elementType;
      const success = await storage.deleteProposalElement(elementId);
      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found or already deleted",
          details: { id: elementId }
        });
      }
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "ELEMENT_DELETED",
          description: `Element "${elementName}" deleted`,
          userId: req.body.userId || 2,
          // Default to user ID 2 if not provided
          metadata: {
            elementId,
            elementType
          }
        });
      } catch (logError) {
        console.error("Error logging proposal activity:", logError);
      }
      return res.status(200).json({
        success: true,
        message: "Proposal element deleted successfully",
        data: { id: elementId }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposal-elements/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid element ID is required",
          details: { id: req.params.id }
        });
      }
      const element = await storage.getProposalElement(id);
      if (!element) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found",
          details: { id }
        });
      }
      const elementName = element.name;
      const elementType = element.elementType;
      const proposalId = element.proposalId;
      const success = await storage.deleteProposalElement(id);
      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal element not found or already deleted",
          details: { id }
        });
      }
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "ELEMENT_DELETED",
          description: `Element "${elementName}" deleted`,
          userId: req.body.userId || 2,
          // Default to user ID 2 if not provided
          metadata: {
            elementId: id,
            elementType
          }
        });
      } catch (logError) {
        console.error("Error logging proposal activity:", logError);
      }
      return res.status(200).json({
        success: true,
        message: "Proposal element deleted successfully",
        data: { id }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposals/:proposalId/collaborators", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to view proposal collaborators"
        });
      }
      const proposalId = parseInt(req.params.proposalId);
      if (isNaN(proposalId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.proposalId }
        });
      }
      const proposal = await storage.getProposal(proposalId);
      if (!proposal) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal not found",
          details: { proposalId }
        });
      }
      const collaborators = await storage.getProposalCollaborators(proposalId);
      res.status(200).json({
        success: true,
        data: collaborators,
        metadata: {
          count: collaborators.length,
          proposalId,
          proposalName: proposal.name,
          proposalStatus: proposal.status,
          timestamp: /* @__PURE__ */ new Date()
        }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/proposals/:proposalId/collaborators", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to add collaborators to proposals"
        });
      }
      const proposalId = parseInt(req.params.proposalId);
      if (isNaN(proposalId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.proposalId }
        });
      }
      const proposal = await storage.getProposal(proposalId);
      if (!proposal) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "The proposal you're trying to add collaborators to does not exist",
          details: { proposalId }
        });
      }
      try {
        const collaboratorData = insertProposalCollaboratorSchema.parse({
          ...req.body,
          proposalId,
          addedBy: req.user.id
        });
        const collaborator = await storage.addProposalCollaborator(collaboratorData);
        try {
          await storage.createProposalActivity({
            proposalId,
            activityType: "COLLABORATOR_ADDED",
            description: `New collaborator added to proposal`,
            userId: req.user.id,
            metadata: {
              collaboratorId: collaborator.id,
              collaboratorUserId: collaborator.userId,
              role: collaborator.role
            }
          });
        } catch (logError) {
          console.error("Error logging proposal activity:", logError);
        }
        return res.status(201).json({
          success: true,
          data: collaborator,
          message: "Collaborator added successfully"
        });
      } catch (validationError) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid collaborator data provided",
          details: validationError?.errors || validationError?.message
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/proposal-collaborators/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to update proposal collaborators"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid collaborator ID is required",
          details: { id: req.params.id }
        });
      }
      try {
        const existingCollaborator = await storage.getProposalCollaborator(id);
        if (!existingCollaborator) {
          return res.status(404).json({
            success: false,
            error: "Not Found",
            message: "Collaborator not found",
            details: { id }
          });
        }
        const previousRole = existingCollaborator.role;
        const proposalId = existingCollaborator.proposalId;
        const collaboratorData = insertProposalCollaboratorSchema.partial().parse(req.body);
        const collaborator = await storage.updateProposalCollaborator(id, collaboratorData);
        if (!collaborator) {
          return res.status(404).json({
            success: false,
            error: "Not Found",
            message: "Collaborator not found or update failed",
            details: { id }
          });
        }
        if (collaboratorData.role && collaboratorData.role !== previousRole) {
          try {
            await storage.createProposalActivity({
              proposalId,
              activityType: "COLLABORATOR_UPDATED",
              description: `Collaborator role changed from "${previousRole}" to "${collaborator.role}"`,
              userId: req.user.id,
              metadata: {
                collaboratorId: collaborator.id,
                collaboratorUserId: collaborator.userId,
                previousRole,
                newRole: collaborator.role
              }
            });
          } catch (logError) {
            console.error("Error logging proposal activity:", logError);
          }
        }
        return res.status(200).json({
          success: true,
          data: collaborator,
          message: "Collaborator updated successfully"
        });
      } catch (validationError) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid collaborator data provided",
          details: validationError?.errors || validationError?.message
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposal-collaborators/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to remove proposal collaborators"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid collaborator ID is required",
          details: { id: req.params.id }
        });
      }
      const collaborator = await storage.getProposalCollaborator(id);
      if (!collaborator) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Collaborator not found",
          details: { id }
        });
      }
      const proposalId = collaborator.proposalId;
      const userId = collaborator.userId;
      const role = collaborator.role;
      const success = await storage.deleteProposalCollaborator(id);
      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Collaborator not found or already deleted",
          details: { id }
        });
      }
      try {
        await storage.createProposalActivity({
          proposalId,
          activityType: "COLLABORATOR_REMOVED",
          description: `Collaborator removed from proposal`,
          userId: req.user.id,
          metadata: {
            collaboratorId: id,
            collaboratorUserId: userId,
            role
          }
        });
      } catch (logError) {
        console.error("Error logging proposal activity:", logError);
      }
      return res.status(200).json({
        success: true,
        message: "Collaborator removed successfully",
        data: { id }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/support-tickets", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const tickets = await db.select().from(supportTickets).where(eq14(supportTickets.customerId, req.user.id)).orderBy(desc4(supportTickets.createdAt));
      res.json(tickets);
    } catch (error) {
      console.error("Error fetching support tickets:", error);
      res.status(500).json({ error: "Failed to fetch support tickets" });
    }
  });
  app2.post("/api/support-tickets", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const categoryMap = {
        "technical": "technical",
        "billing": "billing",
        "howto": "general_inquiry",
        "feature": "feature_request",
        "integration": "technical",
        "other": "general_inquiry"
      };
      const priorityMap = {
        "low": "low",
        "medium": "medium",
        "high": "high",
        "critical": "critical"
      };
      const { title, description, category, priority } = req.body;
      if (!title || !description || !category || !priority) {
        return res.status(400).json({
          error: "Missing required fields",
          details: "title, description, category, and priority are required"
        });
      }
      const ticketData = insertSupportTicketSchema.parse({
        subject: title,
        description,
        customerId: req.user.id,
        type: categoryMap[category] || "general_inquiry",
        priority: priorityMap[priority] || "medium",
        status: "open"
      });
      const [newTicket] = await db.insert(supportTickets).values(ticketData).returning();
      res.status(201).json(newTicket);
    } catch (error) {
      console.error("Error creating support ticket:", error);
      res.status(500).json({
        error: "Failed to create support ticket",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/proposals/:proposalId/comments", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to view proposal comments"
        });
      }
      const proposalId = parseInt(req.params.proposalId);
      if (isNaN(proposalId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.proposalId }
        });
      }
      const proposal = await storage.getProposal(proposalId);
      if (!proposal) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Proposal not found",
          details: { proposalId }
        });
      }
      const comments = await storage.getProposalComments(proposalId);
      const resolvedComments = comments.filter((comment) => comment.resolved === true).length;
      const unresolvedComments = comments.length - resolvedComments;
      res.status(200).json({
        success: true,
        data: comments,
        metadata: {
          count: comments.length,
          resolvedCount: resolvedComments,
          unresolvedCount: unresolvedComments,
          proposalId,
          proposalName: proposal.name,
          proposalStatus: proposal.status,
          timestamp: /* @__PURE__ */ new Date()
        }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.post("/api/proposals/:proposalId/comments", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to add comments to proposals"
        });
      }
      const proposalId = parseInt(req.params.proposalId);
      const proposal = await storage.getProposal(proposalId);
      if (!proposal) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "The proposal you're trying to comment on does not exist",
          details: { proposalId }
        });
      }
      try {
        const commentData = insertProposalCommentSchema.parse({
          ...req.body,
          proposalId,
          userId: req.user.id
        });
        const comment = await storage.createProposalComment(commentData);
        return res.status(201).json({
          success: true,
          data: comment,
          message: "Comment created successfully"
        });
      } catch (validationError) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid comment data provided",
          details: validationError?.errors || validationError?.message
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.patch("/api/proposal-comments/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to update proposal comments"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid comment ID is required",
          details: { id: req.params.id }
        });
      }
      try {
        let commentData = req.body;
        if (commentData.resolved === true) {
          commentData.resolvedBy = req.user.id;
        }
        commentData = insertProposalCommentSchema.partial().parse(commentData);
        const comment = await storage.updateProposalComment(id, commentData);
        if (!comment) {
          return res.status(404).json({
            success: false,
            error: "Not Found",
            message: "Comment not found",
            details: { id }
          });
        }
        return res.status(200).json({
          success: true,
          data: comment,
          message: "Comment updated successfully"
        });
      } catch (validationError) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Invalid comment data provided",
          details: validationError?.errors || validationError?.message
        });
      }
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.delete("/api/proposal-comments/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to delete proposal comments"
        });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid comment ID is required",
          details: { id: req.params.id }
        });
      }
      const deleteSuccess = await storage.deleteProposalComment(id);
      if (!deleteSuccess) {
        return res.status(404).json({
          success: false,
          error: "Not Found",
          message: "Comment not found or already deleted",
          details: { id }
        });
      }
      return res.status(200).json({
        success: true,
        message: "Comment deleted successfully",
        data: { id }
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.get("/api/proposals/:proposalId/activities", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized",
          message: "You must be logged in to view proposal activities"
        });
      }
      const proposalId = parseInt(req.params.proposalId);
      if (isNaN(proposalId)) {
        return res.status(400).json({
          success: false,
          error: "Validation Error",
          message: "Valid proposal ID is required",
          details: { id: req.params.proposalId }
        });
      }
      try {
        const proposal = await storage.getProposal(proposalId);
        if (!proposal) {
          return res.status(404).json({
            success: false,
            error: "Not Found",
            message: "Proposal not found",
            details: { proposalId }
          });
        }
        const activities2 = await storage.getProposalActivities(proposalId);
        const activityTypes = activities2.reduce((acc, activity) => {
          acc[activity.activityType] = (acc[activity.activityType] || 0) + 1;
          return acc;
        }, {});
        return res.status(200).json({
          success: true,
          data: activities2,
          metadata: {
            proposalId,
            proposalName: proposal.name,
            totalCount: activities2.length,
            status: proposal.status,
            activityTypeBreakdown: activityTypes,
            lastActivity: activities2.length > 0 ? activities2[0].createdAt : null,
            timestamp: /* @__PURE__ */ new Date()
          }
        });
      } catch (databaseError) {
        console.error("Database error getting proposal activities:", databaseError);
        return res.status(500).json({
          success: false,
          error: "Database Error",
          message: databaseError?.message || "Failed to retrieve proposal activities",
          // Include the stack trace in development for debugging
          ...process.env.NODE_ENV !== "production" && {
            stack: databaseError?.stack,
            details: databaseError
          }
        });
      }
    } catch (error) {
      console.error("Unexpected error getting proposal activities:", error);
      return res.status(500).json({
        success: false,
        error: "Internal Server Error",
        message: error?.message || "An unexpected error occurred while retrieving proposal activities",
        // Only include details in development for security
        ...process.env.NODE_ENV !== "production" && { details: error }
      });
    }
  });
  app2.use("/api/migration", migrationRouter);
  app2.get("/api/test-notifications", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Not authenticated", isLoggedIn: false });
      }
      const userId = req.user.id;
      const tableExistsResult = await db.execute(sql5`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_name = 'notifications'
        ) as exists
      `);
      const notificationTableExists = tableExistsResult.rows?.[0]?.exists === true;
      let notificationCount = 0;
      if (notificationTableExists) {
        const countResult = await db.execute(sql5`
          SELECT COUNT(*) AS count FROM notifications WHERE user_id = ${userId}
        `);
        notificationCount = parseInt(countResult.rows?.[0]?.count || "0");
      }
      res.json({
        isLoggedIn: true,
        userId,
        username: req.user.username,
        notificationTableExists,
        notificationCount,
        success: true
      });
    } catch (error) {
      handleError(res, error);
    }
  });
  app2.use("/api/telephony", telephony_routes_default);
  app2.use("/api/payments", payment_routes_default);
  const server = createServer(app2);
  return server;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path3 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path2 from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path2.resolve(import.meta.dirname, "client", "src"),
      "@shared": path2.resolve(import.meta.dirname, "shared"),
      "@assets": path2.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path2.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path2.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path3.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// scripts/init-database.ts
init_db();
init_schema();
async function initDatabase2() {
  console.log("Initializing database with default data...");
  const existingPackages = await db.select().from(subscriptionPackages);
  if (existingPackages.length === 0) {
    console.log("Creating default subscription packages...");
    await createDefaultSubscriptionPackages();
  } else {
    console.log(`Found ${existingPackages.length} existing subscription packages`);
  }
  const userCount = await db.execute(`SELECT COUNT(*) FROM users`);
  const count = parseInt(userCount.rows[0].count, 10);
  if (count === 0) {
    console.log("Creating default admin user...");
    await createDefaultAdminUser();
  } else {
    console.log(`Found ${count} existing users`);
  }
  console.log("Database initialization complete!");
}
async function createDefaultSubscriptionPackages() {
  const packages = [
    {
      name: "Starter",
      description: "Basic CRM for small businesses",
      price: "29.99",
      interval: "monthly",
      features: ["Contact Management", "Lead Tracking", "Task Management", "Basic Reports"],
      maxUsers: 2,
      maxContacts: 500,
      maxStorage: 5,
      isActive: true,
      displayOrder: 1
    },
    {
      name: "Professional",
      description: "Advanced CRM with sales automation",
      price: "59.99",
      interval: "monthly",
      features: ["Everything in Starter", "Opportunity Management", "Sales Automation", "Advanced Reports", "Calendar Integration"],
      maxUsers: 5,
      maxContacts: 2500,
      maxStorage: 20,
      isActive: true,
      displayOrder: 2
    },
    {
      name: "Enterprise",
      description: "Complete CRM solution with AI insights",
      price: "99.99",
      interval: "monthly",
      features: ["Everything in Professional", "AI-Powered Insights", "Custom Reports", "Workflow Automation", "API Access"],
      maxUsers: 10,
      maxContacts: 1e4,
      maxStorage: 50,
      isActive: true,
      displayOrder: 3
    },
    {
      name: "Starter Annual",
      description: "Basic CRM for small businesses (annual billing)",
      price: "299.99",
      interval: "yearly",
      features: ["Contact Management", "Lead Tracking", "Task Management", "Basic Reports"],
      maxUsers: 2,
      maxContacts: 500,
      maxStorage: 5,
      isActive: true,
      displayOrder: 4
    },
    {
      name: "Professional Annual",
      description: "Advanced CRM with sales automation (annual billing)",
      price: "599.99",
      interval: "yearly",
      features: ["Everything in Starter", "Opportunity Management", "Sales Automation", "Advanced Reports", "Calendar Integration"],
      maxUsers: 5,
      maxContacts: 2500,
      maxStorage: 20,
      isActive: true,
      displayOrder: 5
    },
    {
      name: "Enterprise Annual",
      description: "Complete CRM solution with AI insights (annual billing)",
      price: "999.99",
      interval: "yearly",
      features: ["Everything in Professional", "AI-Powered Insights", "Custom Reports", "Workflow Automation", "API Access"],
      maxUsers: 10,
      maxContacts: 1e4,
      maxStorage: 50,
      isActive: true,
      displayOrder: 6
    }
  ];
  for (const pkg of packages) {
    await db.insert(subscriptionPackages).values(pkg);
  }
  console.log(`Created ${packages.length} subscription packages`);
}
async function createDefaultAdminUser() {
  await db.execute(`
    INSERT INTO users (
      username, 
      password, 
      first_name, 
      last_name, 
      email, 
      role, 
      is_active, 
      is_verified
    ) VALUES (
      'admin',
      '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8.e5ac7b61e7a12f91f351bed4', -- password
      'Admin',
      'User',
      'admin@averox.com',
      'Admin',
      true,
      true
    )
  `);
  console.log("Created default admin user (username: admin, password: password)");
}
var init_database_default = initDatabase2;

// scripts/reset-and-seed-database.ts
init_db();
init_schema();
import { sql as sql6 } from "drizzle-orm";
async function resetDatabase() {
  const client2 = await pool.connect();
  try {
    console.log("Resetting database...");
    await client2.query("BEGIN");
    const safeTruncate = async (tableName) => {
      const tableExists = await client2.query(
        `SELECT EXISTS (
           SELECT FROM information_schema.tables 
           WHERE table_schema = 'public' 
           AND table_name = $1
         )`,
        [tableName]
      );
      if (tableExists.rows[0].exists) {
        console.log(`Truncating table: ${tableName}`);
        await client2.query(`TRUNCATE ${tableName} CASCADE`);
      } else {
        console.log(`Table ${tableName} does not exist, skipping.`);
      }
    };
    await safeTruncate("social_messages");
    await safeTruncate("social_integrations");
    await safeTruncate("lead_sources");
    await safeTruncate("social_campaigns");
    await safeTruncate("activities");
    await safeTruncate("events");
    await safeTruncate("tasks");
    await safeTruncate("opportunities");
    await safeTruncate("leads");
    await safeTruncate("contacts");
    await safeTruncate("accounts");
    await safeTruncate("api_keys");
    await safeTruncate("communications");
    const usersTableExists = await client2.query(
      `SELECT EXISTS (
         SELECT FROM information_schema.tables 
         WHERE table_schema = 'public' 
         AND table_name = 'users'
       )`
    );
    if (usersTableExists.rows[0].exists) {
      console.log("Deleting non-admin users");
      await client2.query("DELETE FROM users WHERE role != 'Admin'");
    }
    await client2.query("COMMIT");
    console.log("Database reset completed successfully");
  } catch (error) {
    await client2.query("ROLLBACK");
    console.error("Error resetting database:", error);
    throw error;
  } finally {
    client2.release();
  }
}
async function seedAccounts() {
  console.log("Seeding accounts...");
  const accountsData = [
    { name: "Acme Corporation", industry: "Manufacturing", phone: "123-456-7890", website: "https://acme.example.com", employeeCount: 500, isActive: true },
    { name: "TechNova Solutions", industry: "Technology", phone: "234-567-8901", website: "https://technova.example.com", employeeCount: 150, isActive: true },
    { name: "Global Shipping Inc", industry: "Transportation", phone: "345-678-9012", website: "https://globalshipping.example.com", employeeCount: 1200, isActive: true },
    { name: "Emerald Healthcare", industry: "Healthcare", phone: "456-789-0123", website: "https://emerald.example.com", employeeCount: 450, isActive: true },
    { name: "Metro Financial Group", industry: "Finance", phone: "567-890-1234", website: "https://metrofinancial.example.com", employeeCount: 320, isActive: true },
    { name: "Brilliant Education Systems", industry: "Education", phone: "678-901-2345", website: "https://brilliant-edu.example.com", employeeCount: 85, isActive: true },
    { name: "Oceanic Resorts", industry: "Hospitality", phone: "789-012-3456", website: "https://oceanic.example.com", employeeCount: 750, isActive: true },
    { name: "GreenLeaf Agricultural Co", industry: "Agriculture", phone: "890-123-4567", website: "https://greenleaf.example.com", employeeCount: 180, isActive: true },
    { name: "Quantum Energy Ltd", industry: "Energy", phone: "901-234-5678", website: "https://quantum-energy.example.com", employeeCount: 420, isActive: true },
    { name: "Stellar Communication Systems", industry: "Telecommunications", phone: "012-345-6789", website: "https://stellar-comm.example.com", employeeCount: 310, isActive: true }
  ];
  for (const accountData of accountsData) {
    await db.insert(accounts).values({
      ...accountData,
      createdAt: /* @__PURE__ */ new Date(),
      billingAddress: "123 Main St, Suite 100, Business City, 12345",
      shippingAddress: "123 Main St, Suite 100, Business City, 12345",
      notes: "Sample account data"
    });
  }
  console.log(`Successfully seeded ${accountsData.length} accounts`);
}
async function seedContacts() {
  console.log("Seeding contacts...");
  const accountResults = await db.select({ id: accounts.id }).from(accounts).limit(10);
  const accountIds = accountResults.map((a) => a.id);
  const contactsData = [
    { firstName: "John", lastName: "Doe", email: "john.doe@example.com", phone: "123-456-7890", title: "CEO", accountId: accountIds[0] },
    { firstName: "Jane", lastName: "Smith", email: "jane.smith@example.com", phone: "234-567-8901", title: "CTO", accountId: accountIds[1] },
    { firstName: "Robert", lastName: "Johnson", email: "robert.johnson@example.com", phone: "345-678-9012", title: "CFO", accountId: accountIds[2] },
    { firstName: "Emily", lastName: "Davis", email: "emily.davis@example.com", phone: "456-789-0123", title: "COO", accountId: accountIds[3] },
    { firstName: "Michael", lastName: "Wilson", email: "michael.wilson@example.com", phone: "567-890-1234", title: "Director of Sales", accountId: accountIds[4] },
    { firstName: "Sarah", lastName: "Brown", email: "sarah.brown@example.com", phone: "678-901-2345", title: "Marketing Manager", accountId: accountIds[5] },
    { firstName: "David", lastName: "Miller", email: "david.miller@example.com", phone: "789-012-3456", title: "IT Manager", accountId: accountIds[6] },
    { firstName: "Jennifer", lastName: "Taylor", email: "jennifer.taylor@example.com", phone: "890-123-4567", title: "HR Director", accountId: accountIds[7] },
    { firstName: "Christopher", lastName: "Anderson", email: "christopher.anderson@example.com", phone: "901-234-5678", title: "Operations Manager", accountId: accountIds[8] },
    { firstName: "Jessica", lastName: "Thomas", email: "jessica.thomas@example.com", phone: "012-345-6789", title: "Customer Service Manager", accountId: accountIds[9] }
  ];
  for (const contactData of contactsData) {
    await db.insert(contacts).values({
      ...contactData,
      status: "Active",
      createdAt: /* @__PURE__ */ new Date(),
      address: "123 Main St",
      city: "New York",
      state: "NY",
      zip: "10001",
      country: "USA",
      socialProfiles: {
        linkedin: `https://linkedin.com/in/${contactData.firstName.toLowerCase()}-${contactData.lastName.toLowerCase()}`,
        twitter: `https://twitter.com/${contactData.firstName.toLowerCase()}${contactData.lastName.toLowerCase()}`
      }
    });
  }
  console.log(`Successfully seeded ${contactsData.length} contacts`);
}
async function seedLeads() {
  console.log("Seeding leads...");
  const userResults = await db.select({ id: users.id }).from(users).limit(3);
  const userIds = userResults.map((u) => u.id);
  const assignedTo = userIds.length > 0 ? userIds[0] : null;
  const leadsData = [
    { firstName: "Thomas", lastName: "Wright", email: "thomas.wright@example.com", phone: "123-555-7890", company: "Innovate Tech", jobTitle: "CTO", status: "New", source: "Website", score: 85 },
    { firstName: "Amanda", lastName: "Lee", email: "amanda.lee@example.com", phone: "234-555-8901", company: "Digital Solutions", jobTitle: "Marketing Director", status: "Contacted", source: "Referral", score: 70 },
    { firstName: "Richard", lastName: "Harris", email: "richard.harris@example.com", phone: "345-555-9012", company: "Global Enterprises", jobTitle: "CEO", status: "Qualified", source: "Conference", score: 90 },
    { firstName: "Elizabeth", lastName: "Clark", email: "elizabeth.clark@example.com", phone: "456-555-0123", company: "Smart Systems", jobTitle: "Operations Manager", status: "New", source: "LinkedIn", score: 65 },
    { firstName: "Daniel", lastName: "Lewis", email: "daniel.lewis@example.com", phone: "567-555-1234", company: "Future Finance", jobTitle: "CFO", status: "Contacted", source: "Facebook", score: 75 },
    { firstName: "Michelle", lastName: "Walker", email: "michelle.walker@example.com", phone: "678-555-2345", company: "Edu Systems", jobTitle: "Director", status: "Qualified", source: "Email Campaign", score: 80 },
    { firstName: "James", lastName: "Hall", email: "james.hall@example.com", phone: "789-555-3456", company: "Resort Vacations", jobTitle: "Sales Manager", status: "New", source: "Website", score: 60 },
    { firstName: "Patricia", lastName: "Young", email: "patricia.young@example.com", phone: "890-555-4567", company: "Organic Farming", jobTitle: "Owner", status: "Contacted", source: "Trade Show", score: 85 },
    { firstName: "Robert", lastName: "King", email: "robert.king@example.com", phone: "901-555-5678", company: "Power Solutions", jobTitle: "Engineering Lead", status: "Qualified", source: "Google Ads", score: 95 },
    { firstName: "Linda", lastName: "Scott", email: "linda.scott@example.com", phone: "012-555-6789", company: "Telecom Express", jobTitle: "Product Manager", status: "New", source: "Cold Call", score: 70 }
  ];
  for (const leadData of leadsData) {
    await db.insert(leads).values({
      ...leadData,
      assignedTo,
      createdAt: /* @__PURE__ */ new Date(),
      lastContacted: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1e3),
      // Random date in last 30 days
      isQualified: leadData.status === "Qualified",
      budget: Math.floor(Math.random() * 5 + 1) * 1e4,
      // Random budget between 10k and 50k
      timeline: ["1-3 months", "3-6 months", "6-12 months"][Math.floor(Math.random() * 3)],
      requirements: "Looking for a comprehensive solution that integrates with existing systems",
      notes: "Initial contact made. Follow up needed.",
      tags: ["potential", "follow-up", leadData.source.toLowerCase()],
      socialProfiles: {
        linkedin: `https://linkedin.com/in/${leadData.firstName.toLowerCase()}-${leadData.lastName.toLowerCase()}`,
        twitter: `https://twitter.com/${leadData.firstName.toLowerCase()}${leadData.lastName.toLowerCase()}`
      }
    });
  }
  console.log(`Successfully seeded ${leadsData.length} leads`);
}
async function seedOpportunities() {
  console.log("Seeding opportunities...");
  const accountResults = await db.select({ id: accounts.id }).from(accounts).limit(10);
  const accountIds = accountResults.map((a) => a.id);
  const userResults = await db.select({ id: users.id }).from(users).limit(3);
  const userIds = userResults.map((u) => u.id);
  const assignedTo = userIds.length > 0 ? userIds[0] : null;
  const opportunitiesData = [
    { name: "Enterprise Software Implementation", accountId: accountIds[0], stage: "Lead Generation", amount: 125e3, probability: 20, expectedCloseDate: new Date(2025, 5, 15) },
    { name: "Cloud Migration Services", accountId: accountIds[1], stage: "Proposal", amount: 85e3, probability: 50, expectedCloseDate: new Date(2025, 4, 30) },
    { name: "Logistics Software Upgrade", accountId: accountIds[2], stage: "Negotiation", amount: 15e4, probability: 75, expectedCloseDate: new Date(2025, 4, 10) },
    { name: "Patient Management System", accountId: accountIds[3], stage: "Qualification", amount: 95e3, probability: 25, expectedCloseDate: new Date(2025, 6, 20) },
    { name: "Financial Reporting Tools", accountId: accountIds[4], stage: "Proposal", amount: 65e3, probability: 60, expectedCloseDate: new Date(2025, 5, 5) },
    { name: "Educational Platform License", accountId: accountIds[5], stage: "Closing", amount: 45e3, probability: 100, expectedCloseDate: new Date(2025, 3, 25) },
    { name: "Hospitality Management Suite", accountId: accountIds[6], stage: "Negotiation", amount: 11e4, probability: 80, expectedCloseDate: new Date(2025, 4, 15) },
    { name: "Agricultural Analytics Platform", accountId: accountIds[7], stage: "Lead Generation", amount: 7e4, probability: 30, expectedCloseDate: new Date(2025, 7, 10) },
    { name: "Energy Monitoring Solutions", accountId: accountIds[8], stage: "Proposal", amount: 13e4, probability: 55, expectedCloseDate: new Date(2025, 6, 1) },
    { name: "Telecommunications Infrastructure", accountId: accountIds[9], stage: "Closing", amount: 2e5, probability: 0, expectedCloseDate: new Date(2025, 3, 30) }
  ];
  for (const opportunityData of opportunitiesData) {
    await db.insert(opportunities).values({
      ...opportunityData,
      ownerId: assignedTo,
      createdAt: new Date(Date.now() - Math.floor(Math.random() * 60) * 24 * 60 * 60 * 1e3),
      // Random date in last 60 days
      description: "Opportunity for providing services and solutions to meet client needs.",
      nextStep: "Schedule follow-up meeting to discuss requirements in detail",
      competitors: "Major competitors in this space include CompetitorA and CompetitorB",
      notes: "Initial discussions have been positive. Client has expressed strong interest.",
      tags: [opportunityData.stage.toLowerCase().replace(" ", "-"), "priority"]
    });
  }
  console.log(`Successfully seeded ${opportunitiesData.length} opportunities`);
}
async function seedTasks() {
  console.log("Seeding tasks...");
  const userResults = await db.select({ id: users.id }).from(users).limit(3);
  const userIds = userResults.map((u) => u.id);
  const ownerId = userIds.length > 0 ? userIds[0] : null;
  const tasksData = [
    { title: "Prepare sales presentation", status: "Not Started", priority: "High", dueDate: new Date(2025, 4, 15) },
    { title: "Follow up with client about proposal", status: "In Progress", priority: "High", dueDate: new Date(2025, 4, 10) },
    { title: "Research competitor pricing", status: "Completed", priority: "Medium", dueDate: new Date(2025, 4, 5) },
    { title: "Update CRM data", status: "Not Started", priority: "Normal", dueDate: new Date(2025, 4, 20) },
    { title: "Schedule product demo", status: "In Progress", priority: "High", dueDate: new Date(2025, 4, 12) },
    { title: "Send contract for signature", status: "Not Started", priority: "High", dueDate: new Date(2025, 4, 18) },
    { title: "Prepare quarterly report", status: "In Progress", priority: "Medium", dueDate: new Date(2025, 4, 25) },
    { title: "Organize team meeting", status: "Completed", priority: "Normal", dueDate: new Date(2025, 4, 3) },
    { title: "Review new lead sources", status: "Not Started", priority: "Medium", dueDate: new Date(2025, 4, 22) },
    { title: "Create training materials", status: "In Progress", priority: "Normal", dueDate: new Date(2025, 4, 28) }
  ];
  for (const taskData of tasksData) {
    await db.insert(tasks).values({
      ...taskData,
      ownerId,
      createdAt: /* @__PURE__ */ new Date(),
      description: "This is a sample task description that outlines the work to be done.",
      relatedTo: "opportunity",
      relatedToId: Math.floor(Math.random() * 10) + 1,
      // Random ID between 1-10
      reminderDate: new Date(taskData.dueDate.getTime() - 24 * 60 * 60 * 1e3)
      // 1 day before due date
    });
  }
  console.log(`Successfully seeded ${tasksData.length} tasks`);
}
async function seedEvents() {
  console.log("Seeding events...");
  const userResults = await db.select({ id: users.id }).from(users).limit(3);
  const userIds = userResults.map((u) => u.id);
  const ownerId = userIds.length > 0 ? userIds[0] : null;
  const now = /* @__PURE__ */ new Date();
  const eventsData = [
    { title: "Client kickoff meeting", startDate: new Date(2025, 4, 10, 10, 0), endDate: new Date(2025, 4, 10, 11, 30), location: "Conference Room A", status: "Confirmed" },
    { title: "Sales team strategy session", startDate: new Date(2025, 4, 12, 13, 0), endDate: new Date(2025, 4, 12, 15, 0), location: "Main Office", status: "Confirmed" },
    { title: "Product demo for TechNova", startDate: new Date(2025, 4, 15, 14, 0), endDate: new Date(2025, 4, 15, 15, 0), location: "Virtual/Zoom", status: "Tentative" },
    { title: "Quarterly business review", startDate: new Date(2025, 4, 18, 9, 0), endDate: new Date(2025, 4, 18, 12, 0), location: "Board Room", status: "Confirmed" },
    { title: "Industry conference", startDate: new Date(2025, 4, 20, 8, 0), endDate: new Date(2025, 4, 22, 17, 0), location: "Convention Center", status: "Confirmed" },
    { title: "Training workshop", startDate: new Date(2025, 4, 25, 9, 0), endDate: new Date(2025, 4, 25, 16, 0), location: "Training Room", status: "Confirmed" },
    { title: "Contract negotiation meeting", startDate: new Date(2025, 4, 27, 11, 0), endDate: new Date(2025, 4, 27, 12, 30), location: "Client Office", status: "Tentative" },
    { title: "Marketing campaign review", startDate: new Date(2025, 4, 29, 13, 30), endDate: new Date(2025, 4, 29, 15, 0), location: "Marketing Department", status: "Confirmed" },
    { title: "Team building event", startDate: new Date(2025, 5, 2, 14, 0), endDate: new Date(2025, 5, 2, 17, 0), location: "City Park", status: "Confirmed" },
    { title: "Executive leadership meeting", startDate: new Date(2025, 5, 5, 10, 0), endDate: new Date(2025, 5, 5, 12, 0), location: "Executive Suite", status: "Confirmed" }
  ];
  for (const eventData of eventsData) {
    await db.insert(events).values({
      ...eventData,
      ownerId,
      createdAt: /* @__PURE__ */ new Date(),
      description: "This is a sample event description outlining the purpose and agenda.",
      relatedTo: "account",
      relatedToId: Math.floor(Math.random() * 10) + 1,
      // Random ID between 1-10
      isAllDay: false,
      reminderMinutes: 15,
      participants: ["user1@example.com", "user2@example.com"],
      recurringRule: null
    });
  }
  console.log(`Successfully seeded ${eventsData.length} events`);
}
async function seedActivities() {
  console.log("Seeding activities...");
  const leadResults = await db.select({ id: leads.id }).from(leads).limit(5);
  const leadIds = leadResults.map((l) => l.id);
  const accountResults = await db.select({ id: accounts.id }).from(accounts).limit(5);
  const accountIds = accountResults.map((a) => a.id);
  const opportunityResults = await db.select({ id: opportunities.id }).from(opportunities).limit(5);
  const opportunityIds = opportunityResults.map((o) => o.id);
  const userResults = await db.select({ id: users.id }).from(users).limit(3);
  const userIds = userResults.map((u) => u.id);
  const userId = userIds.length > 0 ? userIds[0] : 1;
  const activitiesData = [
    { action: "Made a call", relatedToType: "lead", relatedToId: leadIds[0], detail: "Introduction call - Made initial contact to introduce our services. Outcome: Positive response, scheduled follow-up" },
    { action: "Sent an email", relatedToType: "lead", relatedToId: leadIds[1], detail: "Product information - Sent detailed product information. Outcome: No response yet" },
    { action: "Held a meeting", relatedToType: "account", relatedToId: accountIds[0], detail: "Quarterly review - Conducted quarterly business review. Outcome: Identified new opportunity" },
    { action: "Sent an email", relatedToType: "opportunity", relatedToId: opportunityIds[0], detail: "Proposal follow-up - Sent follow-up regarding proposal. Outcome: Client requested modifications" },
    { action: "Made a call", relatedToType: "lead", relatedToId: leadIds[2], detail: "Qualification call - Called to qualify lead requirements. Outcome: Lead qualified, moved to opportunity" },
    { action: "Held a meeting", relatedToType: "account", relatedToId: accountIds[1], detail: "Demo presentation - Presented product demo to key stakeholders. Outcome: Client impressed, requested pricing" },
    { action: "Sent an email", relatedToType: "opportunity", relatedToId: opportunityIds[1], detail: "Contract details - Sent contract details for review. Outcome: Awaiting feedback" },
    { action: "Made a call", relatedToType: "account", relatedToId: accountIds[2], detail: "Service follow-up - Called to ensure satisfaction with services. Outcome: Positive feedback received" },
    { action: "Sent an email", relatedToType: "lead", relatedToId: leadIds[3], detail: "Case study sharing - Shared relevant case studies. Outcome: Lead expressed increased interest" },
    { action: "Held a meeting", relatedToType: "opportunity", relatedToId: opportunityIds[2], detail: "Negotiation meeting - Met to negotiate final terms. Outcome: Agreement reached on key points" }
  ];
  for (const activityData of activitiesData) {
    await db.insert(activities).values({
      ...activityData,
      userId,
      createdAt: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1e3)
      // Random date in last 30 days
    });
  }
  console.log(`Successfully seeded ${activitiesData.length} activities`);
}
async function seedSocialIntegrations() {
  console.log("Seeding social integrations...");
  const [user] = await db.select().from(users).where(sql6`role = 'Admin'`).limit(1);
  const userId = user?.id || 1;
  const accountResults = await db.select({ id: accounts.id, name: accounts.name }).from(accounts).limit(3);
  if (accountResults.length === 0) {
    console.log("No accounts found, skipping social integrations seeding");
    return;
  }
  const integrationsData = [
    { platform: "Facebook", name: "Facebook Company Page", accountId: "page_123456789", accessToken: "sample_fb_token_123", details: { pageId: "123456789", pageName: "AVEROX CRM" } },
    { platform: "LinkedIn", name: "LinkedIn Company Profile", accountId: "company_987654321", accessToken: "sample_li_token_456", details: { companyId: "987654321", companyName: "AVEROX" } },
    { platform: "Twitter", name: "Twitter Business Account", accountId: "twitter_averoxcrm", accessToken: "sample_tw_token_789", details: { username: "@averoxcrm" } },
    { platform: "Instagram", name: "Instagram Business Profile", accountId: "instagram_567891234", accessToken: "sample_ig_token_012", details: { username: "averoxcrm", businessId: "567891234" } },
    { platform: "WhatsApp", name: "WhatsApp Business Account", accountId: "whatsapp_1234567890", accessToken: "sample_wa_token_345", details: { phoneNumber: "+1234567890", businessName: "AVEROX Support" } },
    { platform: "Email", name: "Marketing Email Integration", accountId: "email_averox", accessToken: "sample_email_token_678", details: { emailAddress: "marketing@averox.example.com" } },
    { platform: "Messenger", name: "Facebook Messenger", accountId: "messenger_123456789", accessToken: "sample_messenger_token_901", details: { pageId: "123456789" } }
  ];
  for (const integrationData of integrationsData) {
    await db.insert(socialIntegrations).values({
      ...integrationData,
      userId,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      isActive: true,
      refreshToken: `refresh_${integrationData.accessToken}`,
      tokenExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
      // 30 days from now
      settings: { autoReply: true, notificationEmail: "alerts@averox.example.com" }
    });
  }
  console.log(`Successfully seeded ${integrationsData.length} social integrations`);
}
async function seedLeadSources() {
  console.log("Seeding lead sources...");
  const sourcesData = [
    { name: "Company Website", platform: "Other", description: "Leads generated from contact forms on our website" },
    { name: "Facebook Lead Ads", platform: "Facebook", description: "Lead generation campaigns on Facebook" },
    { name: "LinkedIn Campaigns", platform: "LinkedIn", description: "Professional network outreach and sponsored content" },
    { name: "Twitter Engagement", platform: "Twitter", description: "Leads from Twitter conversations and promotions" },
    { name: "Instagram Stories", platform: "Instagram", description: "Story ads with swipe-up functionality" },
    { name: "WhatsApp Business", platform: "WhatsApp", description: "Inquiries through WhatsApp business channel" },
    { name: "Email Newsletter", platform: "Email", description: "Subscribers from our monthly newsletter" },
    { name: "Messenger Chatbot", platform: "Messenger", description: "Automated lead capture through Facebook Messenger" },
    { name: "Trade Shows", platform: "Other", description: "In-person lead collection at industry events" },
    { name: "Referral Program", platform: "Other", description: "Customer referrals through our loyalty program" }
  ];
  for (const sourceData of sourcesData) {
    await db.insert(leadSources).values({
      ...sourceData,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      isActive: true,
      conversionRate: Math.random() * 0.2 + 0.05,
      // Random conversion rate between 5-25%
      leadCount: Math.floor(Math.random() * 200) + 50,
      // Random count between 50-250
      settings: {
        autoTagging: true,
        scoreThreshold: 50,
        autoAssignment: true,
        notificationRecipients: ["sales@averox.example.com"]
      }
    });
  }
  console.log(`Successfully seeded ${sourcesData.length} lead sources`);
}
async function seedSocialCampaigns() {
  console.log("Seeding social campaigns...");
  const [user] = await db.select().from(users).where(sql6`role = 'Admin'`).limit(1);
  const userId = user?.id || 1;
  const integrations = await db.select().from(socialIntegrations).limit(5);
  const campaignsData = [
    { name: "Spring Promotion", platform: "Facebook", status: "Active", budget: 5e3, startDate: new Date(2025, 3, 1), endDate: new Date(2025, 4, 30) },
    { name: "B2B Outreach", platform: "LinkedIn", status: "Active", budget: 8e3, startDate: new Date(2025, 3, 15), endDate: new Date(2025, 6, 15) },
    { name: "Product Launch", platform: "Twitter", status: "Planned", budget: 3500, startDate: new Date(2025, 5, 1), endDate: new Date(2025, 5, 31) },
    { name: "Visual Showcase", platform: "Instagram", status: "Active", budget: 2500, startDate: new Date(2025, 4, 1), endDate: new Date(2025, 5, 15) },
    { name: "Customer Support Channel", platform: "WhatsApp", status: "Active", budget: 1e3, startDate: new Date(2025, 3, 1), endDate: new Date(2025, 12, 31) },
    { name: "Monthly Newsletter", platform: "Email", status: "Active", budget: 1500, startDate: new Date(2025, 1, 1), endDate: new Date(2025, 12, 31) },
    { name: "Chat Automation", platform: "Messenger", status: "Active", budget: 2e3, startDate: new Date(2025, 2, 15), endDate: new Date(2025, 12, 31) },
    { name: "Summer Special", platform: "Facebook", status: "Planned", budget: 4500, startDate: new Date(2025, 5, 15), endDate: new Date(2025, 7, 15) },
    { name: "Industry Webinar", platform: "LinkedIn", status: "Draft", budget: 3e3, startDate: new Date(2025, 6, 1), endDate: new Date(2025, 6, 30) },
    { name: "Holiday Promotion", platform: "Email", status: "Draft", budget: 5e3, startDate: new Date(2025, 11, 1), endDate: new Date(2025, 12, 31) }
  ];
  for (const [index, campaignData] of campaignsData.entries()) {
    const integrationId = integrations[index % integrations.length]?.id || null;
    await db.insert(socialCampaigns).values({
      name: campaignData.name,
      platform: campaignData.platform,
      // Cast to any to avoid type issues
      status: campaignData.status,
      ownerId: userId,
      integrationId,
      content: `Campaign content for ${campaignData.name}`,
      startDate: campaignData.startDate,
      endDate: campaignData.endDate,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      isActive: campaignData.status === "Active",
      description: `Campaign targeting ${campaignData.platform} users with focused messaging and offers.`,
      metrics: {
        impressions: Math.floor(Math.random() * 1e5) + 5e3,
        clicks: Math.floor(Math.random() * 5e3) + 500,
        leads: Math.floor(Math.random() * 200) + 20,
        conversion: Math.random() * 0.1 + 0.02,
        // 2-12% conversion rate
        targetAudience: {
          demographics: {
            ageRange: "25-54",
            locations: ["United States", "Canada", "United Kingdom"],
            interests: ["Business", "Technology", "Marketing"]
          },
          targeting: {
            includeKeywords: ["business solutions", "productivity", "efficiency"],
            excludeKeywords: ["free", "cheap"]
          },
          objectives: ["increase_leads", "brand_awareness", "engagement"]
        }
      }
    });
  }
  console.log(`Successfully seeded ${campaignsData.length} social campaigns`);
}
async function seedSocialMessages() {
  console.log("Seeding social messages...");
  const integrations = await db.select().from(socialIntegrations).limit(7);
  const contactResults = await db.select({ id: contacts.id }).from(contacts).limit(5);
  const contactIds = contactResults.map((c) => c.id);
  const leadResults = await db.select({ id: leads.id }).from(leads).limit(5);
  const leadIds = leadResults.map((l) => l.id);
  const messagesData = [];
  for (const integration of integrations) {
    const useContact = integrations.indexOf(integration) % 2 === 0;
    const entityIds = useContact ? contactIds : leadIds;
    for (let i = 0; i < 3; i++) {
      const isInbound = i % 2 === 0;
      const entityId = entityIds[i % entityIds.length];
      let messageText = "";
      let status = "Unread";
      switch (integration.platform) {
        case "Facebook":
          messageText = isInbound ? "Hi there! I saw your post about AVEROX CRM. Can you tell me more about its features?" : "Thanks for reaching out! AVEROX CRM offers comprehensive lead management, contact tracking, and AI-powered insights. Would you like a demo?";
          status = isInbound ? "Unread" : "Read";
          break;
        case "LinkedIn":
          messageText = isInbound ? "Hello, I'm interested in learning more about how AVEROX CRM can help my B2B sales team." : "Great to connect! AVEROX CRM is designed to boost B2B sales efficiency with our workflow automation and analytics. When would be a good time to show you our platform?";
          status = isInbound ? "Read" : "Replied";
          break;
        case "Twitter":
          messageText = isInbound ? "Just came across @averoxcrm - does your platform integrate with our existing marketing tools?" : "Yes! We pride ourselves on our open API and pre-built integrations with all major marketing platforms. Which tools are you currently using?";
          status = isInbound ? "Replied" : "Read";
          break;
        case "Instagram":
          messageText = isInbound ? "Your dashboard screenshots look amazing! Is there a mobile app version?" : "Thank you! Yes, we have fully-featured iOS and Android apps that give you the same powerful features on the go.";
          status = isInbound ? "Read" : "Replied";
          break;
        case "WhatsApp":
          messageText = isInbound ? "Hi, I need some help setting up my team in AVEROX CRM. Are you available for a quick chat?" : "Absolutely! I can help you set up your team right now. How many team members do you need to add?";
          status = isInbound ? "Replied" : "Read";
          break;
        case "Email":
          messageText = isInbound ? "Subject: Pricing Question\n\nHello AVEROX team,\n\nI'm evaluating CRM solutions and would like to know more about your pricing tiers for a 20-person team.\n\nRegards,\nPotential Customer" : "Subject: Re: Pricing Question\n\nHi there,\n\nThanks for your interest in AVEROX CRM! For a 20-person team, our Business Plan would be the most cost-effective at $49/user/month. I've attached a detailed pricing breakdown for your review.\n\nBest regards,\nAVEROX Sales Team";
          status = isInbound ? "Read" : "Replied";
          break;
        case "Messenger":
          messageText = isInbound ? "Quick question - do you offer a trial period?" : "Yes! We offer a full-featured 14-day trial with no credit card required. Would you like me to set that up for you?";
          status = isInbound ? "Unread" : "Read";
          break;
        default:
          messageText = isInbound ? "I have a question about your services." : "Thank you for your question. How can we help you today?";
          status = isInbound ? "Unread" : "Archived";
      }
      let message = {
        integrationId: integration.id,
        externalId: `ext_${Date.now()}_${Math.floor(Math.random() * 1e3)}`,
        message: messageText,
        sender: isInbound ? "user" : "system",
        recipient: isInbound ? "system" : "user",
        status,
        createdAt: new Date(Date.now() - (3 - i) * 24 * 60 * 60 * 1e3),
        // Spread out over last 3 days
        receivedAt: isInbound ? new Date(Date.now() - (3 - i) * 24 * 60 * 60 * 1e3) : null,
        attachments: null,
        metadata: {
          platform: integration.platform,
          messageType: integration.platform === "Email" ? "email" : "chat"
        },
        isDeleted: false
      };
      if (useContact) {
        message.contactId = entityId;
      } else {
        message.leadId = entityId;
      }
      messagesData.push(message);
    }
  }
  for (const message of messagesData) {
    await db.insert(socialMessages).values(message);
  }
  console.log(`Successfully seeded ${messagesData.length} social messages`);
}
async function seedWorkflows() {
  console.log("Seeding workflows...");
  const workflowsData = [
    {
      name: "New Lead Follow-up",
      description: "Automated workflow for initial lead engagement",
      type: "lead",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "delay", config: { duration: 30, unit: "minutes" }, name: "Initial delay" },
        { type: "email", config: { template: "welcome_email", subject: "Welcome to AVEROX" }, name: "Send welcome email" },
        { type: "delay", config: { duration: 2, unit: "days" }, name: "Follow-up delay" },
        { type: "task", config: { title: "Call new lead", assignee: "owner", priority: "High" }, name: "Create follow-up task" }
      ]
    },
    {
      name: "Opportunity Stage Advancement",
      description: "Process for moving opportunities through sales stages",
      type: "opportunity",
      triggerType: "manual",
      active: true,
      steps: [
        { type: "task", config: { title: "Update opportunity details", assignee: "owner", priority: "Medium" }, name: "Review opportunity" },
        { type: "approval", config: { approver: "manager", timeout: 24 }, name: "Manager approval" },
        { type: "condition", config: { field: "amount", operator: ">", value: 5e4 }, name: "Check deal size" },
        { type: "branch", config: {
          condition: "value > 50000",
          truePath: [
            { type: "task", config: { title: "Schedule executive review", assignee: "owner", priority: "High" }, name: "Executive involvement" }
          ],
          falsePath: [
            { type: "task", config: { title: "Prepare standard proposal", assignee: "owner", priority: "Normal" }, name: "Standard process" }
          ]
        }, name: "Deal size branch" }
      ]
    },
    {
      name: "Customer Onboarding",
      description: "Steps to onboard new customers after sale",
      type: "account",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "email", config: { template: "onboarding_welcome", subject: "Welcome to the AVEROX family!" }, name: "Welcome email" },
        { type: "task", config: { title: "Schedule kickoff call", assignee: "owner", priority: "High" }, name: "Kickoff planning" },
        { type: "task", config: { title: "Set up customer in system", assignee: "implementation", priority: "High" }, name: "System setup" },
        { type: "delay", config: { duration: 7, unit: "days" }, name: "Week 1 check-in delay" },
        { type: "task", config: { title: "Week 1 check-in call", assignee: "owner", priority: "Medium" }, name: "Initial follow-up" }
      ]
    },
    {
      name: "Contract Renewal",
      description: "Process for handling upcoming contract renewals",
      type: "account",
      triggerType: "scheduled",
      active: true,
      steps: [
        { type: "delay", config: { duration: 60, unit: "days", beforeField: "contractEndDate" }, name: "60-day reminder" },
        { type: "email", config: { template: "renewal_reminder", subject: "Your AVEROX subscription renewal" }, name: "Renewal notification" },
        { type: "task", config: { title: "Contact for renewal discussion", assignee: "owner", priority: "High" }, name: "Renewal outreach" },
        { type: "delay", config: { duration: 30, unit: "days" }, name: "30-day follow-up delay" },
        { type: "condition", config: { field: "renewalStatus", operator: "==", value: "pending" }, name: "Check renewal status" },
        { type: "branch", config: {
          condition: 'renewalStatus == "pending"',
          truePath: [
            { type: "task", config: { title: "Escalate renewal priority", assignee: "manager", priority: "High" }, name: "Escalation" }
          ],
          falsePath: []
        }, name: "Pending renewal branch" }
      ]
    },
    {
      name: "Lead Nurturing Campaign",
      description: "Multi-touch campaign for lead nurturing",
      type: "lead",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "email", config: { template: "lead_nurture_1", subject: "Discover AVEROX CRM capabilities" }, name: "Initial nurture email" },
        { type: "delay", config: { duration: 3, unit: "days" }, name: "Wait 3 days" },
        { type: "email", config: { template: "lead_nurture_2", subject: "AVEROX case studies and success stories" }, name: "Case studies email" },
        { type: "delay", config: { duration: 4, unit: "days" }, name: "Wait 4 days" },
        { type: "email", config: { template: "lead_nurture_3", subject: "Special offer for AVEROX CRM" }, name: "Offer email" },
        { type: "delay", config: { duration: 5, unit: "days" }, name: "Wait 5 days" },
        { type: "task", config: { title: "Follow up with nurtured lead", assignee: "owner", priority: "Medium" }, name: "Sales follow-up" }
      ]
    },
    {
      name: "Feedback Collection",
      description: "Process to gather and act on customer feedback",
      type: "account",
      triggerType: "scheduled",
      active: true,
      steps: [
        { type: "email", config: { template: "satisfaction_survey", subject: "We value your feedback on AVEROX CRM" }, name: "Survey request" },
        { type: "delay", config: { duration: 3, unit: "days" }, name: "Wait for responses" },
        { type: "condition", config: { field: "surveyResponded", operator: "==", value: true }, name: "Check for response" },
        { type: "branch", config: {
          condition: "surveyResponded == true",
          truePath: [
            { type: "task", config: { title: "Review customer feedback", assignee: "owner", priority: "Medium" }, name: "Feedback review" }
          ],
          falsePath: [
            { type: "email", config: { template: "survey_reminder", subject: "Reminder: We value your feedback" }, name: "Survey reminder" }
          ]
        }, name: "Response branch" }
      ]
    },
    {
      name: "Deal Lost Analysis",
      description: "Follow-up process for lost opportunities",
      type: "opportunity",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "task", config: { title: "Complete loss reason analysis", assignee: "owner", priority: "Medium" }, name: "Loss analysis" },
        { type: "delay", config: { duration: 1, unit: "days" }, name: "Short delay" },
        { type: "email", config: { template: "loss_feedback", subject: "We appreciate your consideration" }, name: "Thank you email" },
        { type: "delay", config: { duration: 90, unit: "days" }, name: "90-day cool off" },
        { type: "task", config: { title: "Reassess opportunity potential", assignee: "owner", priority: "Low" }, name: "Reassessment task" }
      ]
    },
    {
      name: "High-Value Prospect Engagement",
      description: "Executive engagement for high-value prospects",
      type: "lead",
      triggerType: "manual",
      active: true,
      steps: [
        { type: "condition", config: { field: "estimatedValue", operator: ">", value: 1e5 }, name: "Value qualification" },
        { type: "branch", config: {
          condition: "estimatedValue > 100000",
          truePath: [
            { type: "task", config: { title: "Executive outreach planning", assignee: "manager", priority: "High" }, name: "Executive planning" },
            { type: "task", config: { title: "Custom presentation preparation", assignee: "owner", priority: "High" }, name: "Custom materials" },
            { type: "task", config: { title: "Schedule executive meeting", assignee: "owner", priority: "High" }, name: "Executive meeting" }
          ],
          falsePath: [
            { type: "task", config: { title: "Standard lead qualification", assignee: "owner", priority: "Medium" }, name: "Standard process" }
          ]
        }, name: "Value-based routing" }
      ]
    },
    {
      name: "Sales Team Assignment",
      description: "Route leads to appropriate sales team members",
      type: "lead",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "condition", config: { field: "industry", operator: "==", value: "Technology" }, name: "Tech industry check" },
        { type: "branch", config: {
          condition: 'industry == "Technology"',
          truePath: [
            { type: "assignment", config: { assignee: "tech_team", notifyAssignee: true }, name: "Assign to tech team" }
          ],
          falsePath: [
            { type: "condition", config: { field: "industry", operator: "==", value: "Healthcare" }, name: "Healthcare check" },
            { type: "branch", config: {
              condition: 'industry == "Healthcare"',
              truePath: [
                { type: "assignment", config: { assignee: "healthcare_team", notifyAssignee: true }, name: "Assign to healthcare team" }
              ],
              falsePath: [
                { type: "assignment", config: { assignee: "general_team", notifyAssignee: true }, name: "Assign to general team" }
              ]
            }, name: "Healthcare branch" }
          ]
        }, name: "Industry-based routing" }
      ]
    },
    {
      name: "Content Download Follow-up",
      description: "Follow up with leads who download resources",
      type: "lead",
      triggerType: "automatic",
      active: true,
      steps: [
        { type: "email", config: { template: "content_thank_you", subject: "Thank you for downloading our resource" }, name: "Thank you email" },
        { type: "delay", config: { duration: 2, unit: "days" }, name: "Initial delay" },
        { type: "email", config: { template: "related_content", subject: "More resources you might enjoy" }, name: "Related content" },
        { type: "delay", config: { duration: 5, unit: "days" }, name: "Second delay" },
        { type: "task", config: { title: "Follow up on content interest", assignee: "owner", priority: "Medium" }, name: "Sales follow-up" }
      ]
    }
  ];
  console.log("Skipping workflow seeding as the table does not exist yet");
}
async function seedApiKeys() {
  console.log("Seeding API keys...");
  const [admin] = await db.select().from(users).where(sql6`role = 'Admin'`).limit(1);
  const adminId = admin?.id || 1;
  const apiKeysData = [
    { name: "Production API Key", provider: "internal", usageCount: 1250 },
    { name: "Development API Key", provider: "internal", usageCount: 3680 },
    { name: "Mobile App Integration", provider: "internal", usageCount: 5430 },
    { name: "Website Integration", provider: "internal", usageCount: 2870 },
    { name: "Partner Integration - TechNova", provider: "partner", usageCount: 980 },
    { name: "Partner Integration - GlobalShipping", provider: "partner", usageCount: 450 },
    { name: "Marketing Automation", provider: "internal", usageCount: 3210 },
    { name: "Analytics Integration", provider: "internal", usageCount: 1890 },
    { name: "Reporting Tool", provider: "internal", usageCount: 760 },
    { name: "Legacy System Integration", provider: "internal", usageCount: 120 }
  ];
  for (const keyData of apiKeysData) {
    const keyString = `key_${Math.random().toString(36).substring(2, 15)}`;
    const secretString = `sec_${Math.random().toString(36).substring(2, 15)}`;
    await db.insert(apiKeys).values({
      ...keyData,
      ownerId: adminId,
      key: keyString,
      secret: secretString,
      createdAt: new Date(Date.now() - Math.floor(Math.random() * 90) * 24 * 60 * 60 * 1e3),
      // Random date in last 90 days
      updatedAt: /* @__PURE__ */ new Date(),
      lastUsed: new Date(Date.now() - Math.floor(Math.random() * 7) * 24 * 60 * 60 * 1e3),
      // Random date in last 7 days
      isActive: true
    });
  }
  console.log(`Successfully seeded ${apiKeysData.length} API keys`);
}
async function resetAndSeedDatabase() {
  try {
    await resetDatabase();
    await seedAccounts();
    await seedContacts();
    await seedLeads();
    await seedOpportunities();
    await seedTasks();
    await seedEvents();
    await seedActivities();
    await seedSocialIntegrations();
    await seedLeadSources();
    await seedSocialCampaigns();
    await seedSocialMessages();
    await seedWorkflows();
    await seedApiKeys();
    console.log("Database reset and seed completed successfully!");
    return { success: true, message: "Database reset and seed completed successfully!" };
  } catch (error) {
    console.error("Error during database reset and seed:", error);
    return { success: false, message: `Database reset and seed failed: ${error.message}` };
  }
}

// server/index.ts
dotenv2.config();
console.log("OPENAI_API_KEY:", !!process.env.OPENAI_API_KEY);
var pool3 = new pg.Pool({
  connectionString: process.env.DATABASE_URL
});
var resetDb = process.argv.includes("--reset-db");
var SESSION_SECRET = process.env.SESSION_SECRET || "averox-crypto-sphere-secure-session";
var PORT = parseInt(process.env.PORT || "3000", 10);
console.log("Environment check:");
console.log("OPENAI_API_KEY:", process.env.OPENAI_API_KEY ? "Found" : "Missing");
console.log("DATABASE_URL:", process.env.DATABASE_URL ? "Found" : "Missing");
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  try {
    if (resetDb) {
      log("Starting database reset and seed process...");
      const result = await resetAndSeedDatabase();
      log("Reset and seed process result:", result);
    } else {
      await init_database_default();
      log("Database initialized successfully");
    }
  } catch (error) {
    log("Error initializing database:", error instanceof Error ? error.message : String(error));
  }
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development" || process.env.NODE_ENV === "development") {
    await setupVite(app, server);
  } else {
    try {
      serveStatic(app);
    } catch (error) {
      console.warn("Failed to serve static files, falling back to development mode:", error);
      await setupVite(app, server);
    }
  }
  const port = 5001;
  app.listen(5001, "0.0.0.0", () => {
    console.log("\u{1F680} Server running at http://104.251.217.237:5001");
  });
  process.on("uncaughtException", (error) => {
    console.error("[Process] Uncaught Exception:", error);
  });
  process.on("unhandledRejection", (reason, promise) => {
    console.error("[Process] Unhandled Rejection at:", promise, "reason:", reason);
  });
  process.on("SIGTERM", () => {
    console.log("[Process] SIGTERM received, shutting down gracefully");
    server.close(() => {
      console.log("[Process] Process terminated");
    });
  });
  process.on("SIGINT", () => {
    console.log("[Process] SIGINT received, shutting down gracefully");
    server.close(() => {
      console.log("[Process] Process terminated");
    });
  });
})();
